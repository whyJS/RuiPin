// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.Problem = (function() {
    var _this = this;

    function Problem(element) {
      this.enableCheckButtonAfterTimeout = __bind(this.enableCheckButtonAfterTimeout, this);
      this.enableCheckButtonAfterResponse = __bind(this.enableCheckButtonAfterResponse, this);
      this.enableCheckButton = __bind(this.enableCheckButton, this);
      this.refreshAnswers = __bind(this.refreshAnswers, this);
      this.updateMathML = __bind(this.updateMathML, this);
      this.refreshMath = __bind(this.refreshMath, this);
      this.save_internal = __bind(this.save_internal, this);
      this.save = __bind(this.save, this);
      this.gentle_alert = __bind(this.gentle_alert, this);
      this.show = __bind(this.show, this);
      this.reset = __bind(this.reset, this);
      this.check_internal = __bind(this.check_internal, this);
      this.check = __bind(this.check, this);
      this.check_fd = __bind(this.check_fd, this);
      this.check_save_waitfor = __bind(this.check_save_waitfor, this);
      this.setupInputTypes = __bind(this.setupInputTypes, this);
      this.poll = __bind(this.poll, this);
      this.get_queuelen = __bind(this.get_queuelen, this);
      this.queueing = __bind(this.queueing, this);
      this.forceUpdate = __bind(this.forceUpdate, this);
      this.updateProgress = __bind(this.updateProgress, this);
      this.renderProgressState = __bind(this.renderProgressState, this);
      this.bind = __bind(this.bind, this);
      this.el = $(element).find('.problems-wrapper');
      this.id = this.el.data('problem-id');
      this.element_id = this.el.attr('id');
      this.url = this.el.data('url');
      this.has_timed_out = false;
      this.has_response = false;
      this.render();
    }

    Problem.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Problem.prototype.bind = function() {
      var problem_prefix,
        _this = this;
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        this.el.find('.problem > div').each(function(index, element) {
          return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
        });
      }
      window.update_schematics();
      problem_prefix = this.element_id.replace(/problem_/, '');
      this.inputs = this.$("[id^=input_" + problem_prefix + "_]");
      this.$('div.action input:button').click(this.refreshAnswers);
      this.checkButton = this.$('div.action input.check');
      this.checkButtonCheckText = this.checkButton.val();
      this.checkButtonCheckingText = this.checkButton.data('checking');
      this.checkButton.click(this.check_fd);
      this.$('div.action input.reset').click(this.reset);
      this.$('div.action button.show').click(this.show);
      this.$('div.action input.save').click(this.save);
      this.bindResetCorrectness();
      Collapsible.setCollapsibles(this.el);
      this.$('input.math').keyup(this.refreshMath);
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        return this.$('input.math').each(function(index, element) {
          return MathJax.Hub.Queue([_this.refreshMath, null, element]);
        });
      }
    };

    Problem.prototype.renderProgressState = function() {
      var a, detail, earned, possible, progress, progress_template, status;
      detail = this.el.data('progress_detail');
      status = this.el.data('progress_status');
      if (status !== 'none' && (detail != null) && detail.indexOf('/') > 0) {
        a = detail.split('/');
        earned = parseFloat(a[0]);
        possible = parseFloat(a[1]);
        // Translators: %(earned)s is the number of points earned. %(total)s is the total number of points (examples: 0/1, 1/1, 2/3, 5/10). The total number of points will always be at least 1. We pluralize based on the total number of points (example: 0/1 point; 1/2 points);
        progress_template = ngettext('(%(earned)s/%(possible)s point)', '(%(earned)s/%(possible)s points)', possible);
        progress = interpolate(progress_template, {
          'earned': earned,
          'possible': possible
        }, true);
      }
      if (status === 'none' && (detail != null) && detail.indexOf('/') > 0) {
        a = detail.split('/');
        possible = parseFloat(a[1]);
        // Translators: %(num_points)s is the number of points possible (examples: 1, 3, 10). There will always be at least 1 point possible.;
        progress_template = ngettext("(%(num_points)s point possible)", "(%(num_points)s points possible)", possible);
        progress = interpolate(progress_template, {
          'num_points': possible
        }, true);
      }
      return this.$('.problem-progress').html(progress);
    };

    Problem.prototype.updateProgress = function(response) {
      if (response.progress_changed) {
        this.el.data('progress_status', response.progress_status);
        this.el.data('progress_detail', response.progress_detail);
        this.el.trigger('progressChanged');
      }
      return this.renderProgressState();
    };

    Problem.prototype.forceUpdate = function(response) {
      this.el.data('progress_status', response.progress_status);
      this.el.data('progress_detail', response.progress_detail);
      this.el.trigger('progressChanged');
      return this.renderProgressState();
    };

    Problem.prototype.queueing = function() {
      var queuelen;
      this.queued_items = this.$(".xqueue");
      this.num_queued_items = this.queued_items.length;
      if (this.num_queued_items > 0) {
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
        }
        queuelen = this.get_queuelen();
        return window.queuePollerID = window.setTimeout(this.poll, queuelen * 10);
      }
    };

    Problem.prototype.get_queuelen = function() {
      var minlen;
      minlen = Infinity;
      this.queued_items.each(function(index, qitem) {
        var len;
        len = parseInt($.text(qitem));
        if (len < minlen) {
          return minlen = len;
        }
      });
      return minlen;
    };

    Problem.prototype.poll = function() {
      var _this = this;
      return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
        _this.new_queued_items = $(response.html).find(".xqueue");
        if (_this.new_queued_items.length !== _this.num_queued_items) {
          _this.el.html(response.html);
          JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            return _this.bind();
          });
        }
        _this.num_queued_items = _this.new_queued_items.length;
        if (_this.num_queued_items === 0) {
          _this.forceUpdate(response);
          return delete window.queuePollerID;
        } else {
          return window.queuePollerID = window.setTimeout(_this.poll, 1000);
        }
      });
    };

    Problem.inputAjax = function(url, input_id, dispatch, data, callback) {
      data['dispatch'] = dispatch;
      data['input_id'] = input_id;
      return $.postWithPrefix("" + url + "/input_ajax", data, callback);
    };

    Problem.prototype.render = function(content) {
      var _this = this;
      if (content) {
        this.el.attr({
          'aria-busy': 'true',
          'aria-live': 'off',
          'aria-atomic': 'false'
        });
        this.el.html(content);
        JavascriptLoader.executeModuleScripts(this.el, function() {
          _this.setupInputTypes();
          _this.bind();
          return _this.queueing();
        });
        return this.el.attr('aria-busy', 'false');
      } else {
        return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
          _this.el.html(response.html);
          return JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            _this.bind();
            _this.queueing();
            return _this.forceUpdate(response);
          });
        });
      }
    };

    Problem.prototype.setupInputTypes = function() {
      var _this = this;
      this.inputtypeDisplays = {};
      return this.el.find(".capa_inputtype").each(function(index, inputtype) {
        var classes, cls, id, setupMethod, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        id = $(inputtype).attr('id');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          setupMethod = _this.inputtypeSetupMethods[cls];
          if (setupMethod != null) {
            _results.push(_this.inputtypeDisplays[id] = setupMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Problem.prototype.check_save_waitfor = function(callback) {
      var e, inp, _i, _len, _ref,
        _this = this;
      _ref = this.inputs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inp = _ref[_i];
        if ($(inp).is("input[waitfor]")) {
          try {
            $(inp).data("waitfor")(function() {
              _this.refreshAnswers();
              return callback();
            });
          } catch (_error) {
            e = _error;
            if (e.name === "Waitfor Exception") {
              alert(e.message);
            } else {
              alert("Could not grade your answer. The submission was aborted.");
            }
            throw e;
          }
          return true;
        } else {
          return false;
        }
      }
    };

    /*
    # 'check_fd' uses FormData to allow file submissions in the 'problem_check' dispatch,
    #      in addition to simple querystring-based answers
    #
    # NOTE: The dispatch 'problem_check' is being singled out for the use of FormData;
    #       maybe preferable to consolidate all dispatches to use FormData
    */


    Problem.prototype.check_fd = function() {
      var abort_submission, error, error_html, errors, fd, file_not_selected, file_too_large, max_filesize, required_files_not_submitted, settings, timeout_id, unallowed_file_submitted, _i, _len,
        _this = this;
      if (this.el.find('input:file').length === 0) {
        this.check();
        return;
      }
      this.enableCheckButton(false);
      if (!window.FormData) {
        alert("Submission aborted! Sorry, your browser does not support file uploads. If you can, please use Chrome or Safari which have been verified to support file uploads.");
        this.enableCheckButton(true);
        return;
      }
      timeout_id = this.enableCheckButtonAfterTimeout();
      fd = new FormData();
      max_filesize = 4 * 1000 * 1000;
      file_too_large = false;
      file_not_selected = false;
      required_files_not_submitted = false;
      unallowed_file_submitted = false;
      errors = [];
      this.inputs.each(function(index, element) {
        var allowed_files, file, max_size, required_files, _i, _len, _ref, _ref1, _ref2;
        if (element.type === 'file') {
          required_files = $(element).data("required_files");
          allowed_files = $(element).data("allowed_files");
          _ref = element.files;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            if (allowed_files.length !== 0 && (_ref1 = file.name, __indexOf.call(allowed_files, _ref1) < 0)) {
              unallowed_file_submitted = true;
              errors.push("You submitted " + file.name + "; only " + allowed_files + " are allowed.");
            }
            if (_ref2 = file.name, __indexOf.call(required_files, _ref2) >= 0) {
              required_files.splice(required_files.indexOf(file.name), 1);
            }
            if (file.size > max_filesize) {
              file_too_large = true;
              max_size = max_filesize / (1000 * 1000);
              errors.push("Your file " + file.name + " is too large (max size: {max_size}MB)");
            }
            fd.append(element.id, file);
          }
          if (element.files.length === 0) {
            file_not_selected = true;
            fd.append(element.id, '');
          }
          if (required_files.length !== 0) {
            required_files_not_submitted = true;
            return errors.push("You did not submit the required files: " + required_files + ".");
          }
        } else {
          return fd.append(element.id, element.value);
        }
      });
      if (file_not_selected) {
        errors.push('You did not select any files to submit');
      }
      error_html = '<ul>\n';
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        error = errors[_i];
        error_html += '<li>' + error + '</li>\n';
      }
      error_html += '</ul>';
      this.gentle_alert(error_html);
      abort_submission = file_too_large || file_not_selected || unallowed_file_submitted || required_files_not_submitted;
      if (abort_submission) {
        window.clearTimeout(timeout_id);
        this.enableCheckButton(true);
        return;
      }
      settings = {
        type: "POST",
        data: fd,
        processData: false,
        contentType: false,
        complete: this.enableCheckButtonAfterResponse,
        success: function(response) {
          switch (response.success) {
            case 'incorrect':
            case 'correct':
              _this.render(response.contents);
              _this.updateProgress(response);
              break;
            default:
              _this.gentle_alert(response.success);
          }
          return Logger.log('problem_graded', [_this.answers, response.contents], _this.id);
        }
      };
      return $.ajaxWithPrefix("" + this.url + "/problem_check", settings);
    };

    Problem.prototype.check = function() {
      if (!this.check_save_waitfor(this.check_internal)) {
        return this.check_internal();
      }
    };

    Problem.prototype.check_internal = function() {
      var timeout_id,
        _this = this;
      this.enableCheckButton(false);
      timeout_id = this.enableCheckButtonAfterTimeout();
      Logger.log('problem_check', this.answers);
      analytics.track("Problem Checked", {
        problem_id: this.id,
        answers: this.answers
      });
      return $.postWithPrefix("" + this.url + "/problem_check", this.answers, function(response) {
        switch (response.success) {
          case 'incorrect':
          case 'correct':
            window.SR.readElts($(response.contents).find('.status'));
            _this.render(response.contents);
            _this.updateProgress(response);
            if (_this.el.hasClass('showed')) {
              _this.el.removeClass('showed');
            }
            _this.$('div.action input.check').focus();
            break;
          default:
            _this.gentle_alert(response.success);
        }
        return Logger.log('problem_graded', [_this.answers, response.contents], _this.id);
      }).always(this.enableCheckButtonAfterResponse);
    };

    Problem.prototype.reset = function() {
      var _this = this;
      Logger.log('problem_reset', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_reset", {
        id: this.id
      }, function(response) {
        _this.render(response.html);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.show = function() {
      var answer_text,
        _this = this;
      if (!this.el.hasClass('showed')) {
        Logger.log('problem_show', {
          problem: this.id
        });
        answer_text = [];
        return $.postWithPrefix("" + this.url + "/problem_show", function(response) {
          var answers;
          answers = response.answers;
          $.each(answers, function(key, value) {
            var answer, choice, e, solution, _i, _len, _results;
            if ($.isArray(value)) {
              _results = [];
              for (_i = 0, _len = value.length; _i < _len; _i++) {
                choice = value[_i];
                _this.$("label[for='input_" + key + "_" + choice + "']").attr({
                  correct_answer: 'true'
                });
                _results.push(answer_text.push('<p>' + gettext('Answer:') + ' ' + value + '</p>'));
              }
              return _results;
            } else {
              answer = _this.$("#answer_" + key + ", #solution_" + key);
              answer.html(value);
              Collapsible.setCollapsibles(answer);
              try {
                solution = $(value).find('.detailed-solution');
              } catch (_error) {
                e = _error;
                solution = {};
              }
              if (solution.length) {
                return answer_text.push(solution);
              } else {
                return answer_text.push('<p>' + gettext('Answer:') + ' ' + value + '</p>');
              }
            }
          });
          _this.el.find(".capa_inputtype").each(function(index, inputtype) {
            var classes, cls, display, showMethod, _i, _len, _results;
            classes = $(inputtype).attr('class').split(' ');
            _results = [];
            for (_i = 0, _len = classes.length; _i < _len; _i++) {
              cls = classes[_i];
              display = _this.inputtypeDisplays[$(inputtype).attr('id')];
              showMethod = _this.inputtypeShowAnswerMethods[cls];
              if (showMethod != null) {
                _results.push(showMethod(inputtype, display, answers));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
          if (typeof MathJax !== "undefined" && MathJax !== null) {
            _this.el.find('.problem > div').each(function(index, element) {
              return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
            });
          }
          // Translators: the word Answer here refers to the answer to a problem the student must solve.;
          _this.$('.show-label').text(gettext('Hide Answer'));
          _this.$('.show-label .sr').text(gettext('Hide Answer'));
          _this.el.addClass('showed');
          _this.updateProgress(response);
          return window.SR.readElts(answer_text);
        });
      } else {
        this.$('[id^=answer_], [id^=solution_]').text('');
        this.$('[correct_answer]').attr({
          correct_answer: null
        });
        this.el.removeClass('showed');
        // Translators: the word Answer here refers to the answer to a problem the student must solve.;
        this.$('.show-label').text(gettext('Show Answer'));
        this.$('.show-label .sr').text(gettext('Reveal Answer'));
        window.SR.readText(gettext('Answer hidden'));
        return this.el.find(".capa_inputtype").each(function(index, inputtype) {
          var classes, cls, display, hideMethod, _i, _len, _results;
          display = _this.inputtypeDisplays[$(inputtype).attr('id')];
          classes = $(inputtype).attr('class').split(' ');
          _results = [];
          for (_i = 0, _len = classes.length; _i < _len; _i++) {
            cls = classes[_i];
            hideMethod = _this.inputtypeHideAnswerMethods[cls];
            if (hideMethod != null) {
              _results.push(hideMethod(inputtype, display));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      }
    };

    Problem.prototype.gentle_alert = function(msg) {
      var alert_elem;
      if (this.el.find('.capa_alert').length) {
        this.el.find('.capa_alert').remove();
      }
      alert_elem = "<div class='capa_alert'>" + msg + "</div>";
      this.el.find('.action').after(alert_elem);
      this.el.find('.capa_alert').css({
        opacity: 0
      }).animate({
        opacity: 1
      }, 700);
      return window.SR.readElts(this.el.find('.capa_alert'));
    };

    Problem.prototype.save = function() {
      if (!this.check_save_waitfor(this.save_internal)) {
        return this.save_internal();
      }
    };

    Problem.prototype.save_internal = function() {
      var _this = this;
      Logger.log('problem_save', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_save", this.answers, function(response) {
        var saveMessage;
        saveMessage = response.msg;
        _this.gentle_alert(saveMessage);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.refreshMath = function(event, element) {
      var elid, eqn, jax, mathjax_preprocessor, preprocessor_tag, target;
      if (!element) {
        element = event.target;
      }
      elid = element.id.replace(/^input_/, '');
      target = "display_" + elid;
      preprocessor_tag = "inputtype_" + elid;
      mathjax_preprocessor = this.inputtypeDisplays[preprocessor_tag];
      if ((typeof MathJax !== "undefined" && MathJax !== null) && (jax = MathJax.Hub.getAllJax(target)[0])) {
        eqn = $(element).val();
        if (mathjax_preprocessor) {
          eqn = mathjax_preprocessor(eqn);
        }
        MathJax.Hub.Queue(['Text', jax, eqn], [this.updateMathML, jax, element]);
      }
    };

    Problem.prototype.updateMathML = function(jax, element) {
      var exception;
      try {
        return $("#" + element.id + "_dynamath").val(jax.root.toMathML(''));
      } catch (_error) {
        exception = _error;
        if (!exception.restart) {
          throw exception;
        }
        if (typeof MathJax !== "undefined" && MathJax !== null) {
          return MathJax.Callback.After([this.refreshMath, jax], exception.restart);
        }
      }
    };

    Problem.prototype.refreshAnswers = function() {
      this.$('input.schematic').each(function(index, element) {
        return element.schematic.update_value();
      });
      this.$(".CodeMirror").each(function(index, element) {
        if (element.CodeMirror.save) {
          return element.CodeMirror.save();
        }
      });
      return this.answers = this.inputs.serialize();
    };

    Problem.prototype.bindResetCorrectness = function() {
      var $inputtypes,
        _this = this;
      $inputtypes = this.el.find(".capa_inputtype").add(this.el.find(".inputtype"));
      return $inputtypes.each(function(index, inputtype) {
        var bindMethod, classes, cls, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          bindMethod = _this.bindResetCorrectnessByInputtype[cls];
          if (bindMethod != null) {
            _results.push(bindMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Problem.prototype.bindResetCorrectnessByInputtype = {
      formulaequationinput: function(element) {
        return $(element).find('input').on('input', function() {
          var $p;
          $p = $(element).find('p.status');
          // Translators: the word unanswered here is about answering a problem the student must solve.;
          $p.text(gettext("unanswered"));
          return $p.parent().removeClass().addClass("unanswered");
        });
      },
      choicegroup: function(element) {
        var $element, id;
        $element = $(element);
        id = ($element.attr('id').match(/^inputtype_(.*)$/))[1];
        return $element.find('input').on('change', function() {
          var $status;
          $status = $("#status_" + id);
          if ($status[0]) {
            $status.removeClass().addClass("unanswered");
            $status.empty().css('display', 'inline-block');
          } else {
            $("<span>", {
              "class": "unanswered",
              "style": "display: inline-block;",
              "id": "status_" + id
            });
          }
          return $element.find("label").removeClass();
        });
      },
      'option-input': function(element) {
        var $select, id;
        $select = $(element).find('select');
        id = ($select.attr('id').match(/^input_(.*)$/))[1];
        return $select.on('change', function() {
          var $status;
          return $status = $("#status_" + id).removeClass().addClass("unanswered").find('span').text(gettext('Status: unsubmitted'));
        });
      },
      textline: function(element) {
        return $(element).find('input').on('input', function() {
          var $p;
          $p = $(element).find('p.status');
          // Translators: the word unanswered here is about answering a problem the student must solve.;
          $p.text(gettext("unanswered"));
          return $p.parent().removeClass("correct incorrect").addClass("unanswered");
        });
      }
    };

    Problem.prototype.inputtypeSetupMethods = {
      'text-input-dynamath': function(element) {
        /*
        Return: function (eqn) -> eqn that preprocesses the user formula input before
                  it is fed into MathJax. Return 'false' if no preprocessor specified
        */

        var data, preprocessor, preprocessorClass, preprocessorClassName;
        data = $(element).find('.text-input-dynamath_data');
        preprocessorClassName = data.data('preprocessor');
        preprocessorClass = window[preprocessorClassName];
        if (preprocessorClass == null) {
          return false;
        } else {
          preprocessor = new preprocessorClass();
          return preprocessor.fn;
        }
      },
      javascriptinput: function(element) {
        var container, data, display, displayClass, evaluation, params, problemState, submission, submissionField;
        data = $(element).find(".javascriptinput_data");
        params = data.data("params");
        submission = data.data("submission");
        evaluation = data.data("evaluation");
        problemState = data.data("problem_state");
        displayClass = window[data.data('display_class')];
        if (evaluation === '') {
          evaluation = null;
        }
        container = $(element).find(".javascriptinput_container");
        submissionField = $(element).find(".javascriptinput_input");
        display = new displayClass(problemState, submission, evaluation, container, submissionField, params);
        display.render();
        return display;
      },
      cminput: function(container) {
        var element, linenumbers, mode, spaces, tabsize;
        element = $(container).find("textarea");
        tabsize = element.data("tabsize");
        mode = element.data("mode");
        linenumbers = element.data("linenums");
        spaces = Array(parseInt(tabsize) + 1).join(" ");
        return CodeMirror.fromTextArea(element[0], {
          lineNumbers: linenumbers,
          indentUnit: tabsize,
          tabSize: tabsize,
          mode: mode,
          matchBrackets: true,
          lineWrapping: true,
          indentWithTabs: false,
          smartIndent: false,
          extraKeys: {
            "Esc": function(cm) {
              $(".grader-status").focus();
              return false;
            },
            "Tab": function(cm) {
              cm.replaceSelection(spaces, "end");
              return false;
            }
          }
        });
      }
    };

    Problem.prototype.inputtypeShowAnswerMethods = {
      choicegroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("label[for='input_" + input_id + "_" + choice + "']").addClass('choicegroup_correct'));
        }
        return _results;
      },
      javascriptinput: function(element, display, answers) {
        var answer, answer_id;
        answer_id = $(element).attr('id').split("_").slice(1).join("_");
        answer = JSON.parse(answers[answer_id]);
        return display.showAnswer(answer);
      },
      choicetextgroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("section#forinput" + choice).addClass('choicetextgroup_show_correct'));
        }
        return _results;
      },
      imageinput: function(element, display, answers) {
        var canvas, container, ctx, id, types;
        types = {
          rectangle: function(ctx, coords) {
            var rects, reg;
            reg = /^\(([0-9]+),([0-9]+)\)-\(([0-9]+),([0-9]+)\)$/;
            rects = coords.replace(/\s*/g, '').split(/;/);
            $.each(rects, function(index, rect) {
              var abs, height, points, width;
              abs = Math.abs;
              points = reg.exec(rect);
              if (points) {
                width = abs(points[3] - points[1]);
                height = abs(points[4] - points[2]);
                return ctx.rect(points[1], points[2], width, height);
              }
            });
            ctx.stroke();
            return ctx.fill();
          },
          regions: function(ctx, coords) {
            var parseCoords;
            parseCoords = function(coords) {
              var reg;
              reg = JSON.parse(coords);
              if (typeof reg[0][0][0] === "undefined") {
                reg = [reg];
              }
              return reg;
            };
            return $.each(parseCoords(coords), function(index, region) {
              ctx.beginPath();
              $.each(region, function(index, point) {
                if (index === 0) {
                  return ctx.moveTo(point[0], point[1]);
                } else {
                  return ctx.lineTo(point[0], point[1]);
                }
              });
              ctx.closePath();
              ctx.stroke();
              return ctx.fill();
            });
          }
        };
        element = $(element);
        id = element.attr('id').replace(/inputtype_/, '');
        container = element.find("#answer_" + id);
        canvas = document.createElement('canvas');
        canvas.width = container.data('width');
        canvas.height = container.data('height');
        if (canvas.getContext) {
          ctx = canvas.getContext('2d');
        } else {
          return console.log('Canvas is not supported.');
        }
        ctx.fillStyle = 'rgba(255,255,255,.3)';
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = "2";
        if (answers[id]) {
          $.each(answers[id], function(key, value) {
            if ((types[key] != null) && value) {
              return types[key](ctx, value);
            }
          });
          return container.html(canvas);
        } else {
          return console.log("Answer is absent for image input with id=" + id);
        }
      }
    };

    Problem.prototype.inputtypeHideAnswerMethods = {
      choicegroup: function(element, display) {
        element = $(element);
        return element.find('label').removeClass('choicegroup_correct');
      },
      javascriptinput: function(element, display) {
        return display.hideAnswer();
      },
      choicetextgroup: function(element, display) {
        element = $(element);
        return element.find("section[id^='forinput']").removeClass('choicetextgroup_show_correct');
      }
    };

    Problem.prototype.enableCheckButton = function(enable) {
      if (enable) {
        this.checkButton.removeClass('is-disabled');
        return this.checkButton.val(this.checkButtonCheckText);
      } else {
        this.checkButton.addClass('is-disabled');
        return this.checkButton.val(this.checkButtonCheckingText);
      }
    };

    Problem.prototype.enableCheckButtonAfterResponse = function() {
      this.has_response = true;
      if (!this.has_timed_out) {
        return this.enableCheckButton(false);
      } else {
        return this.enableCheckButton(true);
      }
    };

    Problem.prototype.enableCheckButtonAfterTimeout = function() {
      var enableCheckButton,
        _this = this;
      this.has_timed_out = false;
      this.has_response = false;
      enableCheckButton = function() {
        _this.has_timed_out = true;
        if (_this.has_response) {
          return _this.enableCheckButton(true);
        }
      };
      return window.setTimeout(enableCheckButton, 750);
    };

    return Problem;

  }).call(this);

}).call(this);

(function () {
    'use strict';

    var XModule = {};

    XModule.Descriptor = (function () {
        /*
         * Bind the module to an element. This may be called multiple times,
         * if the element content has changed and so the module needs to be rebound
         *
         * @method: constructor
         * @param {html element} the .xmodule_edit section containing all of the descriptor content
         */
        var Descriptor = function (element) {
            this.element = element;
            this.update = _.bind(this.update, this);
        };

        /*
         * Register a callback method to be called when the state of this
         * descriptor is updated. The callback will be passed the results
         * of calling the save method on this descriptor.
         */
        Descriptor.prototype.onUpdate = function (callback) {
            if (!this.callbacks) {
                this.callbacks = [];
            }

            this.callbacks.push(callback);
        };

        /*
         * Notify registered callbacks that the state of this descriptor has changed
         */
        Descriptor.prototype.update = function () {
            var data, callbacks, i, length;

            data = this.save();
            callbacks = this.callbacks;
            length = callbacks.length;

            $.each(callbacks, function (index, callback) {
                callback(data);
            });
        };

        /*
         * Return the current state of the descriptor (to be written to the module store)
         *
         * @method: save
         * @returns {object} An object containing children and data attributes (both optional).
         *                   The contents of the attributes will be saved to the server
         */
        Descriptor.prototype.save = function () {
            return {};
        };

        return Descriptor;
    }());

    this.XBlockToXModuleShim = function (runtime, element) {
        /*
         * Load a single module (either an edit module or a display module)
         * from the supplied element, which should have a data-type attribute
         * specifying the class to load
         */
        var moduleType = $(element).data('type'),
            module;

        if (moduleType === 'None') {
            return;
        }

        try {
            module = new window[moduleType](element);

            if ($(element).hasClass('xmodule_edit')) {
                $(document).trigger('XModule.loaded.edit', [element, module]);
            }

            if ($(element).hasClass('xmodule_display')) {
                $(document).trigger('XModule.loaded.display', [element, module]);
            }

            return module;
        } catch (error) {
            console.error('Unable to load ' + moduleType + ': ' + error.message);
        }
    };

    // Export this module. We do it at the end when everything is ready
    // because some RequireJS scripts require this module. If
    // `window.XModule` appears as defined before this file has a chance
    // to execute fully, then there is a chance that RequireJS will execute
    // some script prematurely.
    this.XModule = XModule;
}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.PeerGrading = (function() {
    PeerGrading.prototype.peer_grading_sel = '.peer-grading';

    PeerGrading.prototype.peer_grading_container_sel = '.peer-grading-container';

    PeerGrading.prototype.error_container_sel = '.error-container';

    PeerGrading.prototype.message_container_sel = '.message-container';

    PeerGrading.prototype.problem_button_sel = '.problem-button';

    PeerGrading.prototype.problem_list_sel = '.problem-list';

    PeerGrading.prototype.progress_bar_sel = '.progress-bar';

    function PeerGrading(element) {
      this.activate_problem = __bind(this.activate_problem, this);
      this.show_results = __bind(this.show_results, this);
      this.construct_progress_bar = __bind(this.construct_progress_bar, this);
      this.el = element;
      this.peer_grading_container = this.$(this.peer_grading_sel);
      this.use_single_location = this.peer_grading_container.data('use-single-location');
      this.peer_grading_outer_container = this.$(this.peer_grading_container_sel);
      this.ajax_url = this.peer_grading_container.data('ajax-url');
      if (this.use_single_location.toLowerCase() === "true") {
        this.activate_problem();
      } else {
        this.error_container = this.$(this.error_container_sel);
        this.error_container.toggle(!this.error_container.is(':empty'));
        this.message_container = this.$(this.message_container_sel);
        this.message_container.toggle(!this.message_container.is(':empty'));
        this.problem_button = this.$(this.problem_button_sel);
        this.problem_button.click(this.show_results);
        this.problem_list = this.$(this.problem_list_sel);
        this.construct_progress_bar();
      }
    }

    PeerGrading.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    PeerGrading.prototype.construct_progress_bar = function() {
      var problems,
        _this = this;
      problems = this.problem_list.find('tr').next();
      return problems.each(function(index, element) {
        var bar_max, bar_value, problem, progress_bar;
        problem = $(element);
        progress_bar = problem.find(_this.progress_bar_sel);
        bar_value = parseInt(problem.data('graded'));
        bar_max = parseInt(problem.data('required')) + bar_value;
        return progress_bar.progressbar({
          value: bar_value,
          max: bar_max
        });
      });
    };

    PeerGrading.prototype.show_results = function(event) {
      var data, location_to_fetch,
        _this = this;
      location_to_fetch = $(event.target).data('location');
      data = {
        'location': location_to_fetch
      };
      return $.postWithPrefix("" + this.ajax_url + "problem", data, function(response) {
        var backend;
        if (response.success) {
          _this.peer_grading_outer_container.after(response.html).remove();
          backend = new PeerGradingProblemBackend(_this.ajax_url, false);
          return new PeerGradingProblem(backend, _this.el);
        } else {
          return _this.gentle_alert(response.error);
        }
      });
    };

    PeerGrading.prototype.activate_problem = function() {
      var backend;
      backend = new PeerGradingProblemBackend(this.ajax_url, false);
      return new PeerGradingProblem(backend, this.el);
    };

    return PeerGrading;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Hinter = (function() {
    function Hinter(element) {
      this.set_bottom_links = __bind(this.set_bottom_links, this);
      this.answer_choice_handle = __bind(this.answer_choice_handle, this);
      this.wizard_link_handle = __bind(this.wizard_link_handle, this);
      this.clear_default_text = __bind(this.clear_default_text, this);
      this.submit_hint = __bind(this.submit_hint, this);
      this.vote = __bind(this.vote, this);
      this.expand = __bind(this.expand, this);
      this.bind = __bind(this.bind, this);
      this.capture_problem = __bind(this.capture_problem, this);
      this.el = $(element).find('.crowdsource-wrapper');
      this.url = this.el.data('url');
      Logger.listen('problem_graded', this.el.data('child-id'), this.capture_problem);
      this.render();
    }

    Hinter.prototype.capture_problem = function(event_type, data, element) {
      var answers, response,
        _this = this;
      answers = data[0];
      response = data[1];
      if (response.search(/class="correct/) === -1) {
        return $.postWithPrefix("" + this.url + "/get_hint", answers, function(response) {
          return _this.render(response.contents);
        });
      } else {
        return $.postWithPrefix("" + this.url + "/get_feedback", answers, function(response) {
          return _this.render(response.contents);
        });
      }
    };

    Hinter.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Hinter.prototype.bind = function() {
      this.$('input.vote').click(this.vote);
      this.$('input.submit-hint').click(this.submit_hint);
      this.$('.custom-hint').click(this.clear_default_text);
      this.$('.expand').click(this.expand);
      this.$('.wizard-link').click(this.wizard_link_handle);
      return this.$('.answer-choice').click(this.answer_choice_handle);
    };

    Hinter.prototype.expand = function(eventObj) {
      var target;
      target = this.$('#' + this.$(eventObj.currentTarget).data('target'));
      if (this.$(target).css('display') === 'none') {
        this.$(target).css('display', 'block');
      } else {
        this.$(target).css('display', 'none');
      }
      return this.set_bottom_links();
    };

    Hinter.prototype.vote = function(eventObj) {
      var all_pks, post_json, target,
        _this = this;
      target = this.$(eventObj.currentTarget);
      all_pks = this.$('#pk-list').attr('data-pk-list');
      post_json = {
        'answer': target.attr('data-answer'),
        'hint': target.data('hintno'),
        'pk_list': all_pks
      };
      return $.postWithPrefix("" + this.url + "/vote", post_json, function(response) {
        return _this.render(response.contents);
      });
    };

    Hinter.prototype.submit_hint = function(eventObj) {
      var post_json, textarea,
        _this = this;
      textarea = $('.custom-hint');
      if (this.answer === '') {
        return;
      }
      post_json = {
        'answer': this.answer,
        'hint': textarea.val()
      };
      return $.postWithPrefix("" + this.url + "/submit_hint", post_json, function(response) {
        return _this.render(response.contents);
      });
    };

    Hinter.prototype.clear_default_text = function(eventObj) {
      var target;
      target = this.$(eventObj.currentTarget);
      if (target.data('cleared') === void 0) {
        target.val('');
        return target.data('cleared', true);
      }
    };

    Hinter.prototype.wizard_link_handle = function(eventObj) {
      var target;
      target = this.$(eventObj.currentTarget);
      return this.go_to(target.attr('dest'));
    };

    Hinter.prototype.answer_choice_handle = function(eventObj) {
      this.answer = this.$(eventObj.target).attr('value');
      this.$('#blank-answer').html(this.answer);
      return this.go_to('p3');
    };

    Hinter.prototype.set_bottom_links = function() {
      var viewbox_height;
      this.$('.bottom').css('margin-top', '0px');
      viewbox_height = parseInt(this.$('.wizard-viewbox').css('height'), 10);
      return this.$('.bottom').each(function(index, obj) {
        var view_height;
        view_height = parseInt($(obj).parent().css('height'), 10);
        return $(obj).css('margin-top', (viewbox_height - view_height) + 'px');
      });
    };

    Hinter.prototype.render = function(content) {
      var hints_exist, styles,
        _this = this;
      if (content) {
        content = content.trim();
      }
      if (content) {
        this.el.html(content);
        this.el.show();
        JavascriptLoader.executeModuleScripts(this.el, function() {
          return _this.bind();
        });
        this.$('#previous-answer-0').css('display', 'inline');
      } else {
        this.el.hide();
      }
      this.answer = '';
      styles = document.body.style;
      if (styles.WebkitTransform === '' || styles.transform === '') {
        this.go_to = this.transform_go_to;
      } else {
        this.go_to = this.legacy_go_to;
      }
      hints_exist = this.$('#hints-exist').html() === 'True';
      if (hints_exist) {
        return this.go_to('p1');
      } else {
        return this.go_to('p2');
      }
    };

    Hinter.prototype.transform_go_to = function(view_id) {
      var id_to_index, translate_string;
      id_to_index = {
        'p1': 0,
        'p2': 1,
        'p3': 2
      };
      translate_string = 'translateX(' + id_to_index[view_id] * -1 * parseInt($('#' + view_id).css('width'), 10) + 'px)';
      this.$('.wizard-container').css('transform', translate_string);
      this.$('.wizard-container').css('-webkit-transform', translate_string);
      return this.set_bottom_links();
    };

    Hinter.prototype.legacy_go_to = function(view_id) {
      this.$('.wizard-view').css('display', 'none');
      this.$('#' + view_id).css('display', 'block');
      return this.set_bottom_links();
    };

    return Hinter;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  this.JavascriptLoader = (function() {
    function JavascriptLoader() {}

    JavascriptLoader.executeModuleScripts = function(el, callback) {
      var callbackCalled, completed, completionHandlerGenerator, completionHandlerGeneratorIE, i, loaded, placeholders,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      placeholders = el.find(".script_placeholder");
      if (placeholders.length === 0) {
        if (callback != null) {
          callback();
        }
        return;
      }
      completed = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = placeholders.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(false);
        }
        return _results;
      })();
      callbackCalled = false;
      completionHandlerGeneratorIE = function(index) {
        return function() {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            return completionHandlerGenerator(index)();
          }
        };
      };
      completionHandlerGenerator = function(index) {
        return function() {
          var allComplete, flag, _i, _len;
          allComplete = true;
          completed[index] = true;
          for (_i = 0, _len = completed.length; _i < _len; _i++) {
            flag = completed[_i];
            if (!flag) {
              allComplete = false;
              break;
            }
          }
          if (allComplete && !callbackCalled) {
            callbackCalled = true;
            if (callback != null) {
              return callback();
            }
          }
        };
      };
      loaded = {};
      return placeholders.each(function(index, placeholder) {
        var s, src;
        src = $(placeholder).attr("data-src");
        if (!(src in loaded)) {
          loaded[src] = true;
          s = document.createElement('script');
          s.setAttribute('src', src);
          s.setAttribute('type', "text/javascript");
          s.onload = completionHandlerGenerator(index);
          s.onreadystatechange = completionHandlerGeneratorIE(index);
          $('head')[0].appendChild(s);
        } else {
          completionHandlerGenerator(index)();
        }
        return $(placeholder).remove();
      });
    };

    return JavascriptLoader;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Sequence = (function() {
    function Sequence(element) {
      this._change_sequential = __bind(this._change_sequential, this);
      this.previous = __bind(this.previous, this);
      this.next = __bind(this.next, this);
      this.goto = __bind(this.goto, this);
      this.tab_container = __bind(this.tab_container, this);
      this.toggleArrows = __bind(this.toggleArrows, this);
      this.updateProgress = __bind(this.updateProgress, this);
      this.el = $(element).find('.sequence');
      this.contents = this.$('.seq_contents');
      this.content_container = this.$('#seq_content');
      this.num_contents = this.$('#sequence-list a[role="tab"]').length;
      this.id = this.el.data('id');
      this.ajaxUrl = this.el.data('ajax-url');
      this.base_page_title = " | " + document.title;
      this.initProgress();
      this.bind();
      this.render(parseInt(this.el.data('position')));
    }

    Sequence.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Sequence.prototype.bind = function() {
      return this.$('#sequence-list a').click(this.goto);
    };

    Sequence.prototype.initProgress = function() {
      return this.progressTable = {};
    };

    Sequence.prototype.updatePageTitle = function() {
      var position_link;
      position_link = this.link_for(this.position);
      if (position_link && position_link.data('page-title')) {
        return document.title = position_link.data('page-title') + this.base_page_title;
      }
    };

    Sequence.prototype.hookUpProgressEvent = function() {
      return $('.problems-wrapper').bind('progressChanged', this.updateProgress);
    };

    Sequence.prototype.mergeProgress = function(p1, p2) {
      var w1, w2;
      if (p1 === "NA") {
        return p2;
      }
      if (p2 === "NA") {
        return p1;
      }
      if (p1 === "done" && p2 === "done") {
        return "done";
      }
      w1 = p1 === "done" || p1 === "in_progress";
      w2 = p2 === "done" || p2 === "in_progress";
      if (w1 || w2) {
        return "in_progress";
      }
      return "none";
    };

    Sequence.prototype.updateProgress = function() {
      var new_progress, _this;
      new_progress = "NA";
      _this = this;
      $('.problems-wrapper').each(function(index) {
        var progress;
        progress = $(this).data('progress_status');
        return new_progress = _this.mergeProgress(progress, new_progress);
      });
      this.progressTable[this.position] = new_progress;
      return this.setProgress(new_progress, this.link_for(this.position));
    };

    Sequence.prototype.setProgress = function(progress, element) {
      element.removeClass('progress-none').removeClass('progress-some').removeClass('progress-done');
      switch (progress) {
        case 'none':
          return element.addClass('progress-none');
        case 'in_progress':
          return element.addClass('progress-some');
        case 'done':
          return element.addClass('progress-done');
      }
    };

    Sequence.prototype.toggleArrows = function() {
      this.$('.sequence-nav-buttons a').unbind('click');
      if (this.contents.length === 0) {
        this.$('.sequence-nav-buttons .prev a').addClass('disabled').attr('aria-hidden', 'true');
        this.$('.sequence-nav-buttons .next a').addClass('disabled').attr('aria-hidden', 'true');
        return;
      }
      if (this.position === 1) {
        this.$('.sequence-nav-buttons .prev a').addClass('disabled').attr('aria-hidden', 'true');
      } else {
        this.$('.sequence-nav-buttons .prev a').removeClass('disabled').attr('aria-hidden', 'false').click(this.previous);
      }
      if (this.position === this.num_contents) {
        return this.$('.sequence-nav-buttons .next a').addClass('disabled').attr('aria-hidden', 'true');
      } else {
        return this.$('.sequence-nav-buttons .next a').removeClass('disabled').attr('aria-hidden', 'false').click(this.next);
      }
    };

    Sequence.prototype.render = function(new_position) {
      var current_tab, sequence_links;
      if (this.position !== new_position) {
        this.el.trigger("sequence:change");
        this.mark_visited(this.position);
        this.mark_active(new_position);
        current_tab = this.tab_container(new_position);
        this.content_container.html(current_tab.text()).attr("aria-labelledby", current_tab.attr("aria-labelledby"));
        XBlock.initializeBlocks(this.content_container);
        window.update_schematics();
        this.position = new_position;
        this.toggleArrows();
        this.hookUpProgressEvent();
        this.updatePageTitle();
        sequence_links = this.content_container.find('a.seqnav');
        sequence_links.click(this.goto);
      }
      return this.$("a.active").blur();
    };

    Sequence.prototype.tab_container = function(new_position) {
      var container, exist, id, modx_full_url,
        _this = this;
      id = "seq_contents_" + (new_position - 1);
      container = null;
      exist = false;
      this.contents.each(function(index, content) {
        if (content.attr("id") === id) {
          exist = true;
          return container = content;
        }
      });
      if (exist) {
        if (this.position !== void 0) {
          this.mark_visited(this.position);
          modx_full_url = "" + this.ajaxUrl + "/goto_position";
          $.postWithPrefix(modx_full_url, {
            position: new_position
          });
        }
      } else {
        modx_full_url = "" + this.ajaxUrl + "/load_position";
        $.ajax({
          url: modx_full_url,
          async: false,
          type: "POST",
          data: {
            position: new_position
          },
          success: function(response) {
            var content;
            content = response["content"];
            container = $("<div/>").attr('id', "seq_contents_" + (new_position - 1)).attr("aria-labelledby", "tab_" + (new_position - 1)).attr("aria-hidden", "true").addClass("seq_contents tex2jax_ignore asciimath2jax_ignore");
            container.html(content);
            return _this.content_container.before(container);
          }
        });
        this.contents.push(container);
      }
      return container;
    };

    Sequence.prototype.goto = function(event) {
      var alert_template, alert_text, new_position;
      event.preventDefault();
      if ($(event.target).hasClass('seqnav')) {
        new_position = $(event.target).attr('href');
      } else {
        new_position = $(event.target).data('element');
      }
      if ((1 <= new_position) && (new_position <= this.num_contents)) {
        Logger.log("seq_goto", {
          old: this.position,
          "new": new_position,
          id: this.id
        });
        analytics.pageview(this.id);
        analytics.track("Accessed Sequential Directly", {
          sequence_id: this.id,
          current_sequential: this.position,
          target_sequential: new_position
        });
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
          delete window.queuePollerID;
        }
        return this.render(new_position);
      } else {
        alert_template = gettext("Sequence error! Cannot navigate to tab %(tab_name)s in the current SequenceModule. Please contact the course staff.");
        alert_text = interpolate(alert_template, {
          tab_name: new_position
        }, true);
        return alert(alert_text);
      }
    };

    Sequence.prototype.next = function(event) {
      return this._change_sequential('seq_next', event);
    };

    Sequence.prototype.previous = function(event) {
      return this._change_sequential('seq_prev', event);
    };

    Sequence.prototype._change_sequential = function(direction, event) {
      var new_position, offset, tracking_messages;
      if (direction !== 'seq_prev' && direction !== 'seq_next') {
        return;
      }
      event.preventDefault();
      offset = {
        seq_next: 1,
        seq_prev: -1
      };
      new_position = this.position + offset[direction];
      Logger.log(direction, {
        old: this.position,
        "new": new_position,
        id: this.id
      });
      analytics.pageview(this.id);
      tracking_messages = {
        seq_prev: "Accessed Previous Sequential",
        seq_next: "Accessed Next Sequential"
      };
      analytics.track(tracking_messages[direction], {
        sequence_id: this.id,
        current_sequential: this.position,
        target_sequential: new_position
      });
      if ($(event.target).closest('nav[class="sequence-bottom"]').length > 0) {
        $.scrollTo(0, 150);
      }
      return this.render(new_position);
    };

    Sequence.prototype.link_for = function(position) {
      return this.$("#sequence-list a[data-element=" + position + "]");
    };

    Sequence.prototype.mark_visited = function(position) {
      var element;
      element = this.link_for(position);
      return element.removeClass("inactive").removeClass("active").addClass("visited");
    };

    Sequence.prototype.mark_active = function(position) {
      var element;
      this.$('#sequence-list [role="tab"]').attr({
        'aria-selected': null
      });
      element = this.link_for(position);
      return element.removeClass("inactive").removeClass("visited").addClass("active").attr({
        "aria-selected": "true",
        'tabindex': '0'
      });
    };

    return Sequence;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Rubric = (function() {
    Rubric.prototype.rubric_category_sel = '.rubric-category';

    Rubric.prototype.rubric_sel = '.rubric';

    function Rubric(el) {
      this.check_complete = __bind(this.check_complete, this);
      this.get_total_score = __bind(this.get_total_score, this);
      this.get_score_list = __bind(this.get_score_list, this);
      this.tracking_callback = __bind(this.tracking_callback, this);
      this.keypress_callback = __bind(this.keypress_callback, this);
      this.initialize = __bind(this.initialize, this);
      this.el = el;
    }

    Rubric.prototype.initialize = function(location) {
      this.$(this.rubric_sel).data("location", location);
      this.$('input[class="score-selection"]').change(this.tracking_callback);
      $(window).unbind('keydown', this.keypress_callback);
      $(window).keydown(this.keypress_callback);
      this.categories = this.$(this.rubric_category_sel);
      this.category = this.$(this.categories.first());
      return this.category_index = 0;
    };

    Rubric.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Rubric.prototype.keypress_callback = function(event) {
      var inputs, max_score, selected;
      if (this.$(event.target).is('input, textarea')) {
        return;
      }
      if (event.which >= 48 && event.which <= 57) {
        selected = event.which - 48;
      } else if (event.which >= 96 && event.which <= 105) {
        selected = event.which - 96;
      } else {
        return;
      }
      if (this.category_index <= this.categories.length) {
        inputs = this.$("input[name='score-selection-" + this.category_index + "']");
        max_score = inputs.length - 1;
        if (selected > max_score || selected < 0) {
          return;
        }
        inputs.filter("input[value=" + selected + "]").click();
        this.category_index++;
        return this.category = this.$(this.categories[this.category_index]);
      }
    };

    Rubric.prototype.tracking_callback = function(event) {
      var category, data, location, target_selection;
      target_selection = this.$(event.target).val();
      category = this.$(event.target).data("category");
      location = this.$(this.rubric_sel).data('location');
      data = {
        location: location,
        selection: target_selection,
        category: category
      };
      return Logger.log('rubric_select', data);
    };

    Rubric.prototype.get_score_list = function() {
      var i, num_categories, score, score_lst, _i, _ref;
      num_categories = this.$(this.rubric_category_sel).length;
      score_lst = [];
      for (i = _i = 0, _ref = num_categories - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        score = this.$("input[name='score-selection-" + i + "']:checked").val();
        score_lst.push(score);
      }
      return score_lst;
    };

    Rubric.prototype.get_total_score = function() {
      var score, score_lst, tot, _i, _len;
      score_lst = this.get_score_list();
      tot = 0;
      for (_i = 0, _len = score_lst.length; _i < _len; _i++) {
        score = score_lst[_i];
        tot += parseInt(score);
      }
      return tot;
    };

    Rubric.prototype.check_complete = function() {
      var i, num_categories, score, _i, _ref;
      num_categories = this.$(this.rubric_category_sel).length;
      for (i = _i = 0, _ref = num_categories - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        score = this.$("input[name='score-selection-" + i + "']:checked").val();
        if (score === void 0) {
          return false;
        }
      }
      return true;
    };

    return Rubric;

  })();

  this.CombinedOpenEnded = (function() {
    CombinedOpenEnded.prototype.wrapper_sel = 'section.xmodule_CombinedOpenEndedModule';

    CombinedOpenEnded.prototype.coe_sel = 'section.combined-open-ended';

    CombinedOpenEnded.prototype.reset_button_sel = '.reset-button';

    CombinedOpenEnded.prototype.next_step_sel = '.next-step-button';

    CombinedOpenEnded.prototype.question_header_sel = '.question-header';

    CombinedOpenEnded.prototype.submit_evaluation_sel = '.submit-evaluation-button';

    CombinedOpenEnded.prototype.result_container_sel = 'div.result-container';

    CombinedOpenEnded.prototype.combined_rubric_sel = '.combined-rubric-container';

    CombinedOpenEnded.prototype.open_ended_child_sel = 'section.open-ended-child';

    CombinedOpenEnded.prototype.error_sel = '.error';

    CombinedOpenEnded.prototype.answer_area_sel = 'textarea.answer';

    CombinedOpenEnded.prototype.answer_area_div_sel = 'div.answer';

    CombinedOpenEnded.prototype.prompt_sel = '.prompt';

    CombinedOpenEnded.prototype.rubric_wrapper_sel = '.rubric-wrapper';

    CombinedOpenEnded.prototype.hint_wrapper_sel = '.hint-wrapper';

    CombinedOpenEnded.prototype.message_wrapper_sel = '.message-wrapper';

    CombinedOpenEnded.prototype.submit_button_sel = '.submit-button';

    CombinedOpenEnded.prototype.skip_button_sel = '.skip-button';

    CombinedOpenEnded.prototype.file_upload_sel = '.file-upload';

    CombinedOpenEnded.prototype.file_upload_box_sel = '.file-upload-box';

    CombinedOpenEnded.prototype.file_upload_preview_sel = '.file-upload-preview';

    CombinedOpenEnded.prototype.fof_sel = 'textarea.feedback-on-feedback';

    CombinedOpenEnded.prototype.sub_id_sel = 'input.submission_id';

    CombinedOpenEnded.prototype.grader_id_sel = 'input.grader_id';

    CombinedOpenEnded.prototype.grader_status_sel = '.grader-status';

    CombinedOpenEnded.prototype.info_rubric_elements_sel = '.rubric-info-item';

    CombinedOpenEnded.prototype.rubric_collapse_sel = '.rubric-collapse';

    CombinedOpenEnded.prototype.next_rubric_sel = '.rubric-next-button';

    CombinedOpenEnded.prototype.previous_rubric_sel = '.rubric-previous-button';

    CombinedOpenEnded.prototype.oe_alert_sel = '.open-ended-alert';

    CombinedOpenEnded.prototype.save_button_sel = '.save-button';

    function CombinedOpenEnded(el) {
      this.graded_callback = __bind(this.graded_callback, this);
      this.setup_score_selection = __bind(this.setup_score_selection, this);
      this.toggle_rubric = __bind(this.toggle_rubric, this);
      this.preview_image = __bind(this.preview_image, this);
      this.remove_attribute = __bind(this.remove_attribute, this);
      this.prompt_hide = __bind(this.prompt_hide, this);
      this.prompt_show = __bind(this.prompt_show, this);
      this.shift_rubric = __bind(this.shift_rubric, this);
      this.previous_rubric = __bind(this.previous_rubric, this);
      this.next_rubric = __bind(this.next_rubric, this);
      this.hide_rubrics = __bind(this.hide_rubrics, this);
      this.collapse_question = __bind(this.collapse_question, this);
      this.replace_text_inputs = __bind(this.replace_text_inputs, this);
      this.hide_file_upload = __bind(this.hide_file_upload, this);
      this.setup_file_upload = __bind(this.setup_file_upload, this);
      this.poll = __bind(this.poll, this);
      this.queueing = __bind(this.queueing, this);
      this.gentle_alert = __bind(this.gentle_alert, this);
      this.next_problem = __bind(this.next_problem, this);
      this.reset = __bind(this.reset, this);
      this.confirm_reset = __bind(this.confirm_reset, this);
      this.skip_post_assessment = __bind(this.skip_post_assessment, this);
      this.save_hint = __bind(this.save_hint, this);
      this.save_assessment = __bind(this.save_assessment, this);
      this.keyup_handler = __bind(this.keyup_handler, this);
      this.keydown_handler = __bind(this.keydown_handler, this);
      this.save_answer = __bind(this.save_answer, this);
      this.confirm_save_answer = __bind(this.confirm_save_answer, this);
      this.replace_answer = __bind(this.replace_answer, this);
      this.store_answer = __bind(this.store_answer, this);
      this.rebind = __bind(this.rebind, this);
      this.message_post = __bind(this.message_post, this);
      this.show_combined_rubric_current = __bind(this.show_combined_rubric_current, this);
      this.get_html = __bind(this.get_html, this);
      this.get_html_callback = __bind(this.get_html_callback, this);
      this.el = el;
      this.$el = $(el);
      this.reinitialize(el);
      $(window).keydown(this.keydown_handler);
      $(window).keyup(this.keyup_handler);
    }

    CombinedOpenEnded.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    CombinedOpenEnded.prototype.reinitialize = function() {
      this.has_been_reset = false;
      this.wrapper = this.$(this.wrapper_sel);
      this.coe = this.$(this.coe_sel);
      this.ajax_url = this.coe.data('ajax-url');
      this.get_html();
      this.coe = this.$(this.coe_sel);
      this.allow_reset = this.coe.data('allow_reset');
      this.id = this.coe.data('id');
      this.state = this.coe.data('state');
      this.task_count = this.coe.data('task-count');
      this.task_number = this.coe.data('task-number');
      this.accept_file_upload = this.coe.data('accept-file-upload');
      this.location = this.coe.data('location');
      this.rub = new Rubric(this.coe);
      this.rub.initialize(this.location);
      this.is_ctrl = false;
      this.reset_button = this.$(this.reset_button_sel);
      this.reset_button.click(this.confirm_reset);
      this.next_problem_button = this.$(this.next_step_sel);
      this.next_problem_button.click(this.next_problem);
      this.question_header = this.$(this.question_header_sel);
      this.question_header.click(this.collapse_question);
      Collapsible.setCollapsibles(this.$el);
      this.submit_evaluation_button = this.$(this.submit_evaluation_sel);
      this.submit_evaluation_button.click(this.message_post);
      this.results_container = this.$(this.result_container_sel);
      this.combined_rubric_container = this.$(this.combined_rubric_sel);
      this.oe = this.$(this.open_ended_child_sel);
      this.errors_area = this.$(this.oe).find(this.error_sel);
      this.answer_area = this.$(this.oe).find(this.answer_area_sel);
      this.prompt_container = this.$(this.oe).find(this.prompt_sel);
      this.rubric_wrapper = this.$(this.oe).find(this.rubric_wrapper_sel);
      this.hint_wrapper = this.$(this.oe).find(this.hint_wrapper_sel);
      this.message_wrapper = this.$(this.oe).find(this.message_wrapper_sel);
      this.submit_button = this.$(this.oe).find(this.submit_button_sel);
      this.save_button = this.$(this.oe).find(this.save_button_sel);
      this.child_state = this.oe.data('state');
      this.child_type = this.oe.data('child-type');
      if (this.child_type === "openended") {
        this.skip_button = this.$(this.oe).find(this.skip_button_sel);
        this.skip_button.click(this.skip_post_assessment);
      }
      this.file_upload_area = this.$(this.oe).find(this.file_upload_sel);
      this.can_upload_files = false;
      this.open_ended_child = this.$(this.oe).find(this.open_ended_child_sel);
      this.out_of_sync_message = 'The problem state got out of sync.  Try reloading the page.';
      if (this.task_number > 1) {
        this.prompt_hide();
      } else if (this.task_number === 1 && this.child_state !== 'initial') {
        this.prompt_hide();
      }
      this.find_assessment_elements();
      this.find_hint_elements();
      return this.rebind();
    };

    CombinedOpenEnded.prototype.get_html_callback = function(response) {
      return this.coe.replaceWith(response.html);
    };

    CombinedOpenEnded.prototype.get_html = function() {
      var url;
      url = "" + this.ajax_url + "/get_html";
      return $.ajaxWithPrefix({
        type: 'POST',
        url: url,
        data: {},
        success: this.get_html_callback,
        async: false
      });
    };

    CombinedOpenEnded.prototype.show_combined_rubric_current = function() {
      var data,
        _this = this;
      data = {};
      return $.postWithPrefix("" + this.ajax_url + "/get_combined_rubric", data, function(response) {
        if (response.success) {
          _this.combined_rubric_container.after(response.html).remove();
          _this.combined_rubric_container = _this.$(_this.combined_rubric_sel);
          _this.toggle_rubric("");
          _this.rubric_collapse = _this.$(_this.rubric_collapse_sel);
          _this.rubric_collapse.click(_this.toggle_rubric);
          _this.hide_rubrics();
          _this.$(_this.previous_rubric_sel).click(_this.previous_rubric);
          _this.$(_this.next_rubric_sel).click(_this.next_rubric);
          if (response.hide_reset) {
            return _this.reset_button.hide();
          }
        }
      });
    };

    CombinedOpenEnded.prototype.message_post = function(event) {
      var evaluation_scoring, external_grader_message, fd, feedback, grader_id, score, settings, submission_id,
        _this = this;
      external_grader_message = $(event.target).parent().parent().parent();
      evaluation_scoring = $(event.target).parent();
      fd = new FormData();
      feedback = this.$(evaluation_scoring).find(this.fof_sel)[0].value;
      submission_id = this.$(external_grader_message).find(this.sub_id_sel)[0].value;
      grader_id = this.$(external_grader_message).find(this.grader_id_sel)[0].value;
      score = this.$(evaluation_scoring).find("input:radio[name='evaluation-score']:checked").val();
      fd.append('feedback', feedback);
      fd.append('submission_id', submission_id);
      fd.append('grader_id', grader_id);
      if (!score) {
        /*
        Translators: A "rating" is a score a student gives to indicate how well
        they feel they were graded on this problem
        */

        this.gentle_alert(gettext("You need to pick a rating before you can submit."));
        return;
      } else {
        fd.append('score', score);
      }
      settings = {
        type: "POST",
        data: fd,
        processData: false,
        contentType: false,
        success: function(response) {
          _this.gentle_alert(response.msg);
          _this.$('section.evaluation').slideToggle();
          return _this.message_wrapper.html(response.message_html);
        }
      };
      return $.ajaxWithPrefix("" + this.ajax_url + "/save_post_assessment", settings);
    };

    CombinedOpenEnded.prototype.rebind = function() {
      this.submit_button.unbind('click');
      this.submit_button.show();
      this.save_button.unbind('click');
      this.save_button.hide();
      this.reset_button.hide();
      this.hide_file_upload();
      this.next_problem_button.hide();
      this.hint_area.attr('disabled', false);
      if (this.task_number === 1 && this.child_state === 'assessing') {
        this.prompt_hide();
      }
      if (this.child_state === 'done') {
        this.rubric_wrapper.hide();
      }
      if (this.child_type === "openended") {
        this.skip_button.hide();
      }
      if (this.allow_reset === "True") {
        this.show_combined_rubric_current();
        this.reset_button.show();
        this.submit_button.hide();
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.hint_area.attr('disabled', true);
        if (this.task_number < this.task_count) {
          /*
          Translators: this message appears when transitioning between openended grading
          types (i.e. self assesment to peer assessment). Sometimes, if a student
          did not perform well at one step, they cannot move on to the next one.
          */

          return this.gentle_alert(gettext("Your score did not meet the criteria to move to the next step."));
        }
      } else if (this.child_state === 'initial') {
        this.answer_area.attr("disabled", false);
        this.submit_button.prop('value', gettext('Submit'));
        this.submit_button.click(this.confirm_save_answer);
        this.setup_file_upload();
        this.save_button.click(this.store_answer);
        return this.save_button.show();
      } else if (this.child_state === 'assessing') {
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.hide_file_upload();
        /*
        Translators: one clicks this button after one has finished filling out the grading
        form for an openended assessment
        */

        this.submit_button.prop('value', gettext('Submit assessment'));
        this.submit_button.click(this.save_assessment);
        this.submit_button.attr("disabled", true);
        if (this.child_type === "openended") {
          this.submit_button.hide();
          this.queueing();
          this.grader_status = this.$(this.grader_status_sel);
          return this.grader_status.html("<span class='grading'>" + gettext("Your response has been submitted. Please check back later for your grade." + "</span>"));
        } else if (this.child_type === "selfassessment") {
          return this.setup_score_selection();
        }
      } else if (this.child_state === 'post_assessment') {
        if (this.child_type === "openended") {
          this.skip_button.show();
          this.skip_post_assessment();
        }
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        /*
        Translators: this button is clicked to submit a student's rating of
        an evaluator's assessment
        */

        this.submit_button.prop('value', gettext('Submit post-assessment'));
        if (this.child_type === "selfassessment") {
          return this.submit_button.click(this.save_hint);
        } else {
          return this.submit_button.click(this.message_post);
        }
      } else if (this.child_state === 'done') {
        this.show_combined_rubric_current();
        this.rubric_wrapper.hide();
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.hint_area.attr('disabled', true);
        this.submit_button.hide();
        if (this.child_type === "openended") {
          this.skip_button.hide();
        }
        if (this.task_number < this.task_count) {
          return this.next_problem_button.show();
        } else {
          return this.reset_button.show();
        }
      }
    };

    CombinedOpenEnded.prototype.find_assessment_elements = function() {
      return this.assessment = this.$('input[name="grade-selection"]');
    };

    CombinedOpenEnded.prototype.find_hint_elements = function() {
      return this.hint_area = this.$('textarea.post_assessment');
    };

    CombinedOpenEnded.prototype.store_answer = function(event) {
      var data,
        _this = this;
      event.preventDefault();
      if (this.child_state === 'initial') {
        data = {
          'student_answer': this.answer_area.val()
        };
        this.save_button.attr("disabled", true);
        return $.postWithPrefix("" + this.ajax_url + "/store_answer", data, function(response) {
          if (response.success) {
            _this.gentle_alert(gettext("Answer saved, but not yet submitted."));
          } else {
            _this.errors_area.html(response.error);
          }
          return _this.save_button.attr("disabled", false);
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.replace_answer = function(response) {
      var answer_area_div;
      if (response.success) {
        this.rubric_wrapper.html(response.rubric_html);
        this.rubric_wrapper.show();
        this.rub = new Rubric(this.coe);
        this.rub.initialize(this.location);
        this.child_state = 'assessing';
        this.find_assessment_elements();
        this.answer_area.val(response.student_response);
        this.rebind();
        answer_area_div = this.$(this.answer_area_div_sel);
        return answer_area_div.html(response.student_response);
      } else {
        this.submit_button.show();
        this.submit_button.attr('disabled', false);
        return this.gentle_alert(response.error);
      }
    };

    CombinedOpenEnded.prototype.confirm_save_answer = function(event) {
      /*
      Translators: This string appears in a confirmation box after one tries to submit
      an openended problem
      */

      var confirmation_text,
        _this = this;
      confirmation_text = gettext('Please confirm that you wish to submit your work. You will not be able to make any changes after submitting.');
      return accessible_confirm(confirmation_text, function() {
        return _this.save_answer(event);
      });
    };

    CombinedOpenEnded.prototype.save_answer = function(event) {
      var fd, files, max_filesize, settings, that, valid_files_attached,
        _this = this;
      this.$el.find(this.oe_alert_sel).remove();
      this.submit_button.attr("disabled", true);
      this.submit_button.hide();
      event.preventDefault();
      this.answer_area.attr("disabled", true);
      max_filesize = 2 * 1000 * 1000;
      if (this.child_state === 'initial') {
        files = "";
        valid_files_attached = false;
        if (this.can_upload_files === true) {
          files = this.$(this.file_upload_box_sel)[0].files[0];
          if (files !== void 0) {
            valid_files_attached = true;
            if (files.size > max_filesize) {
              files = "";
              this.submit_button.show();
              this.submit_button.attr('disabled', false);
              this.gentle_alert(gettext("You are trying to upload a file that is too large for our system.  Please choose a file under 2MB or paste a link to it into the answer box."));
              return;
            }
          }
        }
        fd = new FormData();
        fd.append('student_answer', this.answer_area.val());
        fd.append('student_file', files);
        fd.append('valid_files_attached', valid_files_attached);
        that = this;
        settings = {
          type: "POST",
          data: fd,
          processData: false,
          contentType: false,
          async: false,
          success: function(response) {
            return _this.replace_answer(response);
          }
        };
        return $.ajaxWithPrefix("" + this.ajax_url + "/save_answer", settings);
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.keydown_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === false) {
        return this.is_ctrl = true;
      } else if (this.is_ctrl === true && event.which === 13 && this.child_state === 'assessing' && this.rub.check_complete()) {
        return this.save_assessment(event);
      }
    };

    CombinedOpenEnded.prototype.keyup_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === true) {
        return this.is_ctrl = false;
      }
    };

    CombinedOpenEnded.prototype.save_assessment = function(event) {
      var checked_assessment, data, score_list,
        _this = this;
      this.submit_button.attr("disabled", true);
      this.submit_button.hide();
      event.preventDefault();
      if (this.child_state === 'assessing' && this.rub.check_complete()) {
        checked_assessment = this.rub.get_total_score();
        score_list = this.rub.get_score_list();
        data = {
          'assessment': checked_assessment,
          'score_list': score_list
        };
        return $.postWithPrefix("" + this.ajax_url + "/save_assessment", data, function(response) {
          if (response.success) {
            _this.child_state = response.state;
            if (_this.child_state === 'post_assessment') {
              _this.hint_wrapper.html(response.hint_html);
              _this.find_hint_elements();
            } else if (_this.child_state === 'done') {
              _this.rubric_wrapper.hide();
            }
            return _this.rebind();
          } else {
            return _this.gentle_alert(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.save_hint = function(event) {
      var data,
        _this = this;
      event.preventDefault();
      if (this.child_state === 'post_assessment') {
        data = {
          'hint': this.hint_area.val()
        };
        return $.postWithPrefix("" + this.ajax_url + "/save_post_assessment", data, function(response) {
          if (response.success) {
            _this.message_wrapper.html(response.message_html);
            _this.child_state = 'done';
            return _this.rebind();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.skip_post_assessment = function() {
      var _this = this;
      if (this.child_state === 'post_assessment') {
        return $.postWithPrefix("" + this.ajax_url + "/skip_post_assessment", {}, function(response) {
          if (response.success) {
            _this.child_state = 'done';
            return _this.rebind();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.confirm_reset = function(event) {
      var message,
        _this = this;
      message = gettext('Are you sure you want to remove your previous response to this question?');
      return accessible_confirm(message, function() {
        return _this.reset(event);
      });
    };

    CombinedOpenEnded.prototype.reset = function(event) {
      var _this = this;
      event.preventDefault();
      if (this.child_state === 'done' || this.allow_reset === "True") {
        return $.postWithPrefix("" + this.ajax_url + "/reset", {}, function(response) {
          if (response.success) {
            _this.answer_area.val('');
            _this.rubric_wrapper.html('');
            _this.hint_wrapper.html('');
            _this.message_wrapper.html('');
            _this.child_state = 'initial';
            _this.coe.after(response.html).remove();
            _this.allow_reset = "False";
            _this.reinitialize(_this.element);
            _this.has_been_reset = true;
            _this.rebind();
            return _this.reset_button.hide();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.next_problem = function() {
      var _this = this;
      if (this.child_state === 'done') {
        return $.postWithPrefix("" + this.ajax_url + "/next_problem", {}, function(response) {
          if (response.success) {
            _this.answer_area.val('');
            _this.rubric_wrapper.html('');
            _this.hint_wrapper.html('');
            _this.message_wrapper.html('');
            _this.child_state = 'initial';
            _this.coe.after(response.html).remove();
            _this.reinitialize(_this.element);
            _this.rebind();
            _this.next_problem_button.hide();
            if (!response.allow_reset) {
              return _this.gentle_alert(gettext("Moved to next step."));
            } else {
              /*
              Translators: this message appears when transitioning between openended grading
              types (i.e. self assesment to peer assessment). Sometimes, if a student
              did not perform well at one step, they cannot move on to the next one.
              */

              _this.gentle_alert(gettext("Your score did not meet the criteria to move to the next step."));
              return _this.show_combined_rubric_current();
            }
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.gentle_alert = function(msg) {
      var alert_elem;
      if (this.$el.find(this.oe_alert_sel).length) {
        this.$el.find(this.oe_alert_sel).remove();
      }
      alert_elem = "<div class='open-ended-alert' role='alert'>" + msg + "</div>";
      this.$el.find('.open-ended-action').after(alert_elem);
      return this.$el.find(this.oe_alert_sel).css({
        opacity: 0
      }).animate({
        opacity: 1
      }, 700);
    };

    CombinedOpenEnded.prototype.queueing = function() {
      if (this.child_state === "assessing" && this.child_type === "openended") {
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
        }
        return window.queuePollerID = window.setTimeout(this.poll, 10000);
      }
    };

    CombinedOpenEnded.prototype.poll = function() {
      var _this = this;
      return $.postWithPrefix("" + this.ajax_url + "/check_for_score", function(response) {
        if (response.state === "done" || response.state === "post_assessment") {
          delete window.queuePollerID;
          return _this.reload();
        } else {
          return window.queuePollerID = window.setTimeout(_this.poll, 10000);
        }
      });
    };

    CombinedOpenEnded.prototype.setup_file_upload = function() {
      if (this.accept_file_upload === "True") {
        if (window.File && window.FileReader && window.FileList && window.Blob) {
          this.can_upload_files = true;
          this.file_upload_area.html('<input type="file" class="file-upload-box"><img class="file-upload-preview" src="#" alt="Uploaded image" />');
          this.file_upload_area.show();
          this.$(this.file_upload_preview_sel).hide();
          return this.$(this.file_upload_box_sel).change(this.preview_image);
        } else {
          return this.gentle_alert(gettext('File uploads are required for this question, but are not supported in your browser. Try the newest version of Google Chrome. Alternatively, if you have uploaded the image to another website, you can paste a link to it into the answer box.'));
        }
      }
    };

    CombinedOpenEnded.prototype.hide_file_upload = function() {
      if (this.accept_file_upload === "True") {
        return this.file_upload_area.hide();
      }
    };

    CombinedOpenEnded.prototype.replace_text_inputs = function() {
      var answer_class, answer_id, answer_val, new_text;
      answer_class = this.answer_area.attr('class');
      answer_id = this.answer_area.attr('id');
      answer_val = this.answer_area.val();
      new_text = '';
      new_text = "<div class='" + answer_class + "' id='" + answer_id + "'>" + answer_val + "</div>";
      return this.answer_area.replaceWith(new_text);
    };

    CombinedOpenEnded.prototype.reload = function() {
      return this.reinitialize();
    };

    CombinedOpenEnded.prototype.collapse_question = function(event) {
      var new_text;
      this.prompt_container.slideToggle();
      this.prompt_container.toggleClass('open');
      if (this.prompt_container.hasClass('open')) {
        /*
        Translators: "Show Question" is some text that, when clicked, shows a question's
        content that had been hidden
        */

        new_text = gettext("Show Question");
        Logger.log('oe_show_question', {
          location: this.location
        });
      } else {
        /*
        Translators: "Hide Question" is some text that, when clicked, hides a question's
        content
        */

        Logger.log('oe_hide_question', {
          location: this.location
        });
        new_text = gettext("Hide Question");
      }
      this.question_header.text(new_text);
      return false;
    };

    CombinedOpenEnded.prototype.hide_rubrics = function() {
      var rub, rubrics, _i, _len, _results;
      rubrics = this.$(this.combined_rubric_sel);
      _results = [];
      for (_i = 0, _len = rubrics.length; _i < _len; _i++) {
        rub = rubrics[_i];
        if (this.$(rub).data('status') === "shown") {
          _results.push(this.$(rub).show());
        } else {
          _results.push(this.$(rub).hide());
        }
      }
      return _results;
    };

    CombinedOpenEnded.prototype.next_rubric = function() {
      this.shift_rubric(1);
      return false;
    };

    CombinedOpenEnded.prototype.previous_rubric = function() {
      this.shift_rubric(-1);
      return false;
    };

    CombinedOpenEnded.prototype.shift_rubric = function(i) {
      var number, rub, rubrics, _i, _len;
      rubrics = this.$(this.combined_rubric_sel);
      number = 0;
      for (_i = 0, _len = rubrics.length; _i < _len; _i++) {
        rub = rubrics[_i];
        if (this.$(rub).data('status') === "shown") {
          number = this.$(rub).data('number');
        }
        this.$(rub).data('status', 'hidden');
      }
      if (i === 1 && number < rubrics.length - 1) {
        number = number + i;
      }
      if (i === -1 && number > 0) {
        number = number + i;
      }
      this.$(rubrics[number]).data('status', 'shown');
      return this.hide_rubrics();
    };

    CombinedOpenEnded.prototype.prompt_show = function() {
      if (this.prompt_container.is(":hidden") === true) {
        this.prompt_container.slideToggle();
        this.prompt_container.toggleClass('open');
        return this.question_header.text(gettext("Hide Question"));
      }
    };

    CombinedOpenEnded.prototype.prompt_hide = function() {
      if (this.prompt_container.is(":visible") === true) {
        this.prompt_container.slideToggle();
        this.prompt_container.toggleClass('open');
        return this.question_header.text(gettext("Show Question"));
      }
    };

    CombinedOpenEnded.prototype.log_feedback_click = function(event) {
      var generated_event_type, target;
      target = this.$(event.target);
      if (target.hasClass('see-full-feedback')) {
        return Logger.log('oe_show_full_feedback', {});
      } else if (target.hasClass('respond-to-feedback')) {
        return Logger.log('oe_show_respond_to_feedback', {});
      } else {
        generated_event_type = link_text.toLowerCase().replace(" ", "_");
        return Logger.log("oe_" + generated_event_type, {});
      }
    };

    CombinedOpenEnded.prototype.log_feedback_selection = function(event) {
      var target_selection;
      target_selection = this.$(event.target).val();
      return Logger.log('oe_feedback_response_selected', {
        value: target_selection
      });
    };

    CombinedOpenEnded.prototype.remove_attribute = function(name) {
      if (this.$(this.file_upload_preview_sel).attr(name)) {
        return this.$(this.file_upload_preview_sel)[0].removeAttribute(name);
      }
    };

    CombinedOpenEnded.prototype.preview_image = function() {
      var reader,
        _this = this;
      if (this.$(this.file_upload_box_sel)[0].files && this.$(this.file_upload_box_sel)[0].files[0]) {
        reader = new FileReader();
        reader.onload = function(e) {
          var height_px, max_dim, scale_factor, width_px;
          max_dim = 150;
          _this.remove_attribute('src');
          _this.remove_attribute('height');
          _this.remove_attribute('width');
          _this.$(_this.file_upload_preview_sel).attr('src', e.target.result);
          height_px = _this.$(_this.file_upload_preview_sel)[0].height;
          width_px = _this.$(_this.file_upload_preview_sel)[0].width;
          scale_factor = 0;
          if (height_px > width_px) {
            scale_factor = height_px / max_dim;
          } else {
            scale_factor = width_px / max_dim;
          }
          _this.$(_this.file_upload_preview_sel)[0].width = width_px / scale_factor;
          _this.$(_this.file_upload_preview_sel)[0].height = height_px / scale_factor;
          return _this.$(_this.file_upload_preview_sel).show();
        };
        return reader.readAsDataURL(this.$(this.file_upload_box_sel)[0].files[0]);
      }
    };

    CombinedOpenEnded.prototype.toggle_rubric = function(event) {
      var info_rubric_elements;
      info_rubric_elements = this.$(this.info_rubric_elements_sel);
      info_rubric_elements.slideToggle();
      return false;
    };

    CombinedOpenEnded.prototype.setup_score_selection = function() {
      return this.$("input[class='score-selection']").change(this.graded_callback);
    };

    CombinedOpenEnded.prototype.graded_callback = function() {
      if (this.rub.check_complete()) {
        this.submit_button.attr("disabled", false);
        return this.submit_button.show();
      }
    };

    return CombinedOpenEnded;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.InlineDiscussion = (function(_super) {
    __extends(InlineDiscussion, _super);

    function InlineDiscussion(element) {
      this.el = $(element).find('.discussion-module');
      this.view = new DiscussionModuleView({
        el: this.el
      });
    }

    return InlineDiscussion;

  })(XModule.Descriptor);

}).call(this);

(function (undefined) {
    'use strict';

    this.Time = {
        format: format,
        formatFull: formatFull,
        convert: convert
    };

    return;

    function format(time, formatFull) {
        var hours, minutes, seconds;

        if (!_.isFinite(time)) {
            time = 0;
        }

        seconds = Math.floor(time);
        minutes = Math.floor(seconds / 60);
        hours = Math.floor(minutes / 60);
        seconds = seconds % 60;
        minutes = minutes % 60;

        if (formatFull) {
            return '' + _pad(hours) + ':' + _pad(minutes) + ':' + _pad(seconds % 60);
        } else if (hours) {
            return '' + _pad(hours) + ':' + _pad(minutes) + ':' + _pad(seconds % 60);
        } else {
            return '' + _pad(minutes) + ':' + _pad(seconds % 60);
        }
    }

    function formatFull(time) {
        // The returned value will not be user-facing. So no need for
        // internationalization.
        return format(time, true);
    }

    function convert(time, oldSpeed, newSpeed) {
        return (time * oldSpeed / newSpeed).toFixed(3);
    }

    function _pad(number) {
        if (number < 10) {
            return '0' + number;
        } else {
            return '' + number;
        }
    }
}).call(this);

window.Poll = function (el) {
    RequireJS.require(['PollMain'], function (PollMain) {
        new PollMain(el);
    });
};

var SequenceNav = function($element) {
	var _this = this;
	var $element = $element;
	var $wrapper = $element.find('.sequence-list-wrapper');
	var $list = $element.find('#sequence-list');
	var $arrows = $element.find('.sequence-nav-buttons');
	var maxScroll = $list.width() - $wrapper.width() + 20;
	var $leftShadow = $('<div class="left-shadow"></div>');
	var $rightShadow = $('<div class="right-shadow"></div>');
	var $body = $('body');
	var listOrigin;
	var mouseOrigin;

	var startDrag = function(e) {
		updateWidths();
		mouseOrigin = e.pageX;
		listOrigin = $list.position().left;
		$body.css('-webkit-user-select', 'none');
		$body.bind('mousemove', moveDrag);
		$body.bind('mouseup', stopDrag);
	};

	var moveDrag = function(e) {
		var offset = e.pageX - mouseOrigin;
		var targetLeft = clamp(listOrigin + offset, -maxScroll, 0);

		updateHorizontalPosition(targetLeft);

		setShadows(targetLeft);
	};

	var stopDrag = function(e) {
		$body.css('-webkit-user-select', 'auto');
		$body.unbind('mousemove', moveDrag);
		$body.unbind('mouseup', stopDrag);
	};

	var setShadows = function(left) {
		var left = left || $list.position().left;
		var padding = 30;

		var leftPercent = clamp(-left / padding, 0, 1);
		$leftShadow.css('opacity', leftPercent);

		var rightPercent = clamp((maxScroll + left) / padding, 0, 1);
		$rightShadow.css('opacity', rightPercent);
	};

	var clamp = function(val, min, max) {
	    if(val > max) return max;
	    if(val < min) return min;
	    return val;
	};

	var updateWidths = function(e) {
		maxScroll = $list.width() - $wrapper.width() + 20;
		var targetLeft = clamp($list.position().left, -maxScroll, 0);
		updateHorizontalPosition(targetLeft);
		setShadows(targetLeft);
	};

	var updateHorizontalPosition = function(left) {
		$list.css({
			'left': left + 'px'
		});
	};

	var checkPosition = function(e) {
		var $active = $element.find('.active');
		if(!$active[0]) {
			return;
		}
		if($active.position().left + $active.width() > $wrapper.width() - $list.position().left) {
			$list.animate({
				'left': (-$active.position().left + $wrapper.width() - $active.width() - 10) + 'px'
			}, {
				step: setShadows
			});
		} else if($active.position().left < -$list.position().left) {
			$list.animate({
				'left': (-$active.position().left + 10) + 'px'
			}, {
				step: setShadows
			});
		}
	};

	$wrapper.append($leftShadow).append($rightShadow);
	setShadows(0);
	$wrapper.bind('mousedown', startDrag);
	$arrows.bind('click', checkPosition);
	$(window).bind('resize', updateWidths);
	setTimeout(function() {
		checkPosition();
	}, 200);
};

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define(
    'GstMain',

    // Even though it is not explicitly in this module, we have to specify
    // 'GeneralMethods' as a dependency. It expands some of the core JS objects
    // with additional useful methods that are used in other modules.
    ['State', 'GeneralMethods', 'Sliders', 'Inputs', 'Graph', 'ElOutput', 'GLabelElOutput'],
    function (State, GeneralMethods, Sliders, Inputs, Graph, ElOutput, GLabelElOutput) {

    return GstMain;

    function GstMain(gstId) {
        var config, gstClass, state;

        if ($('#' + gstId).attr('data-processed') !== 'processed') {
            $('#' + gstId).attr('data-processed', 'processed');
        } else {
            // console.log('MESSAGE: Already processed GST with ID ' + gstId + '. Skipping.');

            return;
        }

        // Get the JSON configuration, parse it, and store as an object.
        try {
            config = JSON.parse($('#' + gstId + '_json').html()).root;
        } catch (err) {
            console.log('ERROR: could not parse config JSON.');
            console.log('$("#" + gstId + "_json").html() = ', $('#' + gstId + '_json').html());
            console.log('JSON.parse(...) = ', JSON.parse($('#' + gstId + '_json').html()));
            console.log('config = ', config);

            return;
        }

        // Get the class name of the GST. All elements are assigned a class
        // name that is based on the class name of the GST. For example, inputs
        // are assigned a class name '{GST class name}_input'.
        if (typeof config['@class'] !== 'string') {
            console.log('ERROR: Could not get the class name of GST.');
            console.log('config["@class"] = ', config['@class']);

            return;
        }
        gstClass = config['@class'];

        // Parse the configuration settings for parameters, and store them in a
        // state object.
        state = State(gstId, config);

        state.showDebugInfo = false;

        // It is possible that something goes wrong while extracting parameters
        // from the JSON config object. In this case, we will not continue.
        if (state === undefined) {
            console.log('ERROR: The state object was not initialized properly.');

            return;
        }

        // Create the sliders and the text inputs, attaching them to
        // appropriate parameters.
        Sliders(gstId, state);
        Inputs(gstId, gstClass, state);

        // Configure functions that output to an element instead of the graph.
        ElOutput(config, state);

        // Configure functions that output to an element instead of the graph
        // label.
        GLabelElOutput(config, state);

        // Configure and display the graph. Attach event for the graph to be
        // updated on any change of a slider or a text input.
        Graph(gstId, config, state);
    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Generated by CoffeeScript 1.6.3
(function() {
  this.JavascriptLoader = (function() {
    function JavascriptLoader() {}

    JavascriptLoader.executeModuleScripts = function(el, callback) {
      var callbackCalled, completed, completionHandlerGenerator, completionHandlerGeneratorIE, i, loaded, placeholders,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      placeholders = el.find(".script_placeholder");
      if (placeholders.length === 0) {
        if (callback != null) {
          callback();
        }
        return;
      }
      completed = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = placeholders.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(false);
        }
        return _results;
      })();
      callbackCalled = false;
      completionHandlerGeneratorIE = function(index) {
        return function() {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            return completionHandlerGenerator(index)();
          }
        };
      };
      completionHandlerGenerator = function(index) {
        return function() {
          var allComplete, flag, _i, _len;
          allComplete = true;
          completed[index] = true;
          for (_i = 0, _len = completed.length; _i < _len; _i++) {
            flag = completed[_i];
            if (!flag) {
              allComplete = false;
              break;
            }
          }
          if (allComplete && !callbackCalled) {
            callbackCalled = true;
            if (callback != null) {
              return callback();
            }
          }
        };
      };
      loaded = {};
      return placeholders.each(function(index, placeholder) {
        var s, src;
        src = $(placeholder).attr("data-src");
        if (!(src in loaded)) {
          loaded[src] = true;
          s = document.createElement('script');
          s.setAttribute('src', src);
          s.setAttribute('type', "text/javascript");
          s.onload = completionHandlerGenerator(index);
          s.onreadystatechange = completionHandlerGeneratorIE(index);
          $('head')[0].appendChild(s);
        } else {
          completionHandlerGenerator(index)();
        }
        return $(placeholder).remove();
      });
    };

    return JavascriptLoader;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  this.Conditional = (function() {
    function Conditional(element, callerElId) {
      var dependencies;
      this.el = $(element).find('.conditional-wrapper');
      this.callerElId = callerElId;
      if (callerElId !== void 0) {
        dependencies = this.el.data('depends');
        if ((typeof dependencies === 'string') && (dependencies.length > 0) && (dependencies.indexOf(callerElId) === -1)) {
          return;
        }
      }
      this.url = this.el.data('url');
      this.render(element);
    }

    Conditional.prototype.render = function(element) {
      var _this = this;
      return $.postWithPrefix("" + this.url + "/conditional_get", function(response) {
        var i, parentEl, parentId, _i, _len, _ref;
        _this.el.html('');
        _ref = response.html;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _this.el.append(i);
        }
        parentEl = $(element).parent();
        parentId = parentEl.attr('id');
        if (response.message === false) {
          if (parentEl.hasClass('vert')) {
            parentEl.hide();
          } else {
            $(element).hide();
          }
        } else {
          if (parentEl.hasClass('vert')) {
            parentEl.show();
          } else {
            $(element).show();
          }
        }
        return XBlock.initializeBlocks(_this.el);
      });
    };

    return Conditional;

  })();

}).call(this);

/*
 * d3 - Data-Driven Documents
 * https://github.com/mbostock/d3
 * 
 * 
 * Copyright (c) 2013, Michael Bostock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * The name Michael Bostock may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
d3=function(){function n(n){return null!=n&&!isNaN(n)}function t(n){return n.length}function e(n){for(var t=1;n*t%1;)t*=10;return t}function r(n,t){try{for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}catch(r){n.prototype=t}}function u(){}function i(){}function a(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function o(){}function c(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new u;return t.on=function(t,u){var i,a=r.get(t);return arguments.length<2?a&&a.on:(a&&(a.on=null,e=e.slice(0,i=e.indexOf(a)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function l(){oa.event.stopPropagation(),oa.event.preventDefault()}function f(){for(var n,t=oa.event;n=t.sourceEvent;)t=n;return t}function s(n){for(var t=new o,e=0,r=arguments.length;++e<r;)t[arguments[e]]=c(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=oa.event;u.target=n,oa.event=u,t[u.type].apply(e,r)}finally{oa.event=i}}},t}function h(n,t){var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>ma&&(la.scrollX||la.scrollY)){e=oa.select(ca.body).append("svg").style("position","absolute").style("top",0).style("left",0);var u=e[0][0].getScreenCTM();ma=!(u.f||u.e),e.remove()}return ma?(r.x=t.pageX,r.y=t.pageY):(r.x=t.clientX,r.y=t.clientY),r=r.matrixTransform(n.getScreenCTM().inverse()),[r.x,r.y]}var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}function g(n){for(var t=-1,e=n.length,r=[];++t<e;)r.push(n[t]);return r}function p(n){return Array.prototype.slice.call(n)}function d(n){return Ma(n,Ea),n}function m(n){return function(){return xa(n,this)}}function v(n){return function(){return ba(n,this)}}function y(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=oa.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?o:a:n.local?i:u}function M(n){return n.trim().replace(/\s+/g," ")}function x(n){return RegExp("(?:^|\\s+)"+oa.requote(n)+"(?:\\s+|$)","g")}function _(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=n.trim().split(/\s+/).map(w);var u=n.length;return"function"==typeof t?r:e}function w(n){var t=x(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",M(u+" "+n))):e.setAttribute("class",M(u.replace(t," ")))}}function S(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function E(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function k(n){return{__data__:n}}function A(n){return function(){return Sa(this,n)}}function q(n){return arguments.length||(n=oa.ascending),function(t,e){return!t-!e||n(t.__data__,e.__data__)}}function N(){}function T(n,t,e){function r(){var t=this[a];t&&(this.removeEventListener(n,t,t.$),delete this[a])}function u(){var u=c(t,va(arguments));r.call(this),this.addEventListener(n,this[a]=u,u.$=e),u._=t}function i(){var t,e=RegExp("^__on([^.]+)"+oa.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var a="__on"+n,o=n.indexOf("."),c=C;o>0&&(n=n.substring(0,o));var l=qa.get(n);return l&&(n=l,c=z),o?t?u:r:t?N:i}function C(n,t){return function(e){var r=oa.event;oa.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{oa.event=r}}}function z(n,t){var e=C(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||r.compareDocumentPosition(t)&8)||e.call(t,n)}}function D(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],a=0,o=i.length;o>a;a++)(u=i[a])&&t(u,a,e);return n}function j(n){return Ma(n,Na),n}function L(){}function F(n,t,e){return new H(n,t,e)}function H(n,t,e){this.h=n,this.s=t,this.l=e}function P(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(a-i)*n/60:180>n?a:240>n?i+(a-i)*(240-n)/60:i}function u(n){return Math.round(r(n)*255)}var i,a;return n%=360,0>n&&(n+=360),t=0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,a=.5>=e?e*(1+t):e+t-e*t,i=2*e-a,tt(u(n+120),u(n),u(n-120))}function R(n){return n>0?1:0>n?-1:0}function O(n){return Math.acos(Math.max(-1,Math.min(1,n)))}function Y(n){return n>1?La/2:-1>n?-La/2:Math.asin(n)}function U(n){return(Math.exp(n)-Math.exp(-n))/2}function I(n){return(Math.exp(n)+Math.exp(-n))/2}function V(n){return(n=Math.sin(n/2))*n}function X(n,t,e){return new Z(n,t,e)}function Z(n,t,e){this.h=n,this.c=t,this.l=e}function B(n,t,e){return $(e,Math.cos(n*=Ha)*t,Math.sin(n)*t)}function $(n,t,e){return new J(n,t,e)}function J(n,t,e){this.l=n,this.a=t,this.b=e}function G(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=W(u)*Ya,r=W(r)*Ua,i=W(i)*Ia,tt(nt(3.2404542*u-1.5371385*r-.4985314*i),nt(-.969266*u+1.8760108*r+.041556*i),nt(.0556434*u-.2040259*r+1.0572252*i))}function K(n,t,e){return X(Math.atan2(e,t)*Pa,Math.sqrt(t*t+e*e),n)}function W(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function Q(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function nt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function tt(n,t,e){return new et(n,t,e)}function et(n,t,e){this.r=n,this.g=t,this.b=e}function rt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function ut(n,t,e){var r,u,i,a=0,o=0,c=0;if(r=/([a-z]+)\((.*)\)/i.exec(n))switch(u=r[2].split(","),r[1]){case"hsl":return e(parseFloat(u[0]),parseFloat(u[1])/100,parseFloat(u[2])/100);case"rgb":return t(ct(u[0]),ct(u[1]),ct(u[2]))}return(i=Za.get(n))?t(i.r,i.g,i.b):(null!=n&&n.charAt(0)==="#"&&(n.length===4?(a=n.charAt(1),a+=a,o=n.charAt(2),o+=o,c=n.charAt(3),c+=c):n.length===7&&(a=n.substring(1,3),o=n.substring(3,5),c=n.substring(5,7)),a=parseInt(a,16),o=parseInt(o,16),c=parseInt(c,16)),t(a,o,c))}function it(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),a=Math.max(n,t,e),o=a-i,c=(a+i)/2;return o?(u=.5>c?o/(a+i):o/(2-a-i),r=n==a?(t-e)/o+(e>t?6:0):t==a?(e-n)/o+2:(n-t)/o+4,r*=60):u=r=0,F(r,u,c)}function at(n,t,e){n=ot(n),t=ot(t),e=ot(e);var r=Q((.4124564*n+.3575761*t+.1804375*e)/Ya),u=Q((.2126729*n+.7151522*t+.072175*e)/Ua),i=Q((.0193339*n+.119192*t+.9503041*e)/Ia);return $(116*u-16,500*(r-u),200*(u-i))}function ot(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function ct(n){var t=parseFloat(n);return n.charAt(n.length-1)==="%"?Math.round(2.55*t):t}function lt(n){return"function"==typeof n?n:function(){return n}}function ft(n){return n}function st(n){return n.length===1?function(t,e){n(null==t?e:null)}:n}function ht(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var a=oa.xhr(n,t,i);return a.row=function(n){return arguments.length?a.response((e=n)==null?r:u(n)):e},a.row(e)}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function a(t){return t.map(o).join(n)}function o(n){return c.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var c=RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(f>=c)return a;if(u)return u=!1,i;var t=f;if(n.charCodeAt(t)===34){for(var e=t;e++<c;)if(n.charCodeAt(e)===34){if(n.charCodeAt(e+1)!==34)break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,n.charCodeAt(e+2)===10&&++f):10===r&&(u=!0),n.substring(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),o=1;if(10===r)u=!0;else if(13===r)u=!0,n.charCodeAt(f)===10&&(++f,++o);else if(r!==l)continue;return n.substring(t,f-o)}return n.substring(t)}for(var r,u,i={},a={},o=[],c=n.length,f=0,s=0;(r=e())!==a;){for(var h=[];r!==i&&r!==a;)h.push(r),r=e();(!t||(h=t(h,s++)))&&o.push(h)}return o},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new i,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(a).join("\n")},e}function gt(){for(var n,t=Date.now(),e=Ka;e;)n=t-e.then,n>=e.delay&&(e.flush=e.callback(n)),e=e.next;var r=pt()-t;r>24?(isFinite(r)&&(clearTimeout($a),$a=setTimeout(gt,r)),Ba=0):(Ba=1,Wa(gt))}function pt(){for(var n=null,t=Ka,e=1/0;t;)t.flush?(delete Ga[t.callback.id],t=n?n.next=t.next:Ka=t.next):(e=Math.min(e,t.then+t.delay),t=(n=t).next);return e}function dt(n,t){var e=Math.pow(10,Math.abs(8-t)*3);return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function mt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function vt(n){return n+""}function yt(n,t){co.hasOwnProperty(n.type)&&co[n.type](n,t)}function Mt(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1]);t.lineEnd()}function xt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)Mt(n[e],t,1);t.polygonEnd()}function bt(){function n(n,t){n*=Ha,t=t*Ha/2+La/4;var e=n-r,a=Math.cos(t),o=Math.sin(t),c=i*o,l=fo,f=so,s=u*a+c*Math.cos(e),h=c*Math.sin(e);fo=l*s-f*h,so=f*s+l*h,r=n,u=a,i=o}var t,e,r,u,i;ho.point=function(a,o){ho.point=n,r=(t=a)*Ha,u=Math.cos(o=(e=o)*Ha/2+La/4),i=Math.sin(o)},ho.lineEnd=function(){n(t,e)}}function _t(n){function t(n,t){r>n&&(r=n),n>i&&(i=n),u>t&&(u=t),t>a&&(a=t)}function e(){o.point=o.lineEnd=N}var r,u,i,a,o={point:t,lineStart:N,lineEnd:N,polygonStart:function(){o.lineEnd=e},polygonEnd:function(){o.point=t}};return function(t){return a=i=-(r=u=1/0),oa.geo.stream(t,n(o)),[[r,u],[i,a]]}}function wt(n,t){if(!go){++po,n*=Ha;var e=Math.cos(t*=Ha);mo+=(e*Math.cos(n)-mo)/po,vo+=(e*Math.sin(n)-vo)/po,yo+=(Math.sin(t)-yo)/po}}function St(){var n,t;go=1,Et(),go=2;var e=Mo.point;Mo.point=function(r,u){e(n=r,t=u)},Mo.lineEnd=function(){Mo.point(n,t),kt(),Mo.lineEnd=kt}}function Et(){function n(n,u){n*=Ha;var i=Math.cos(u*=Ha),a=i*Math.cos(n),o=i*Math.sin(n),c=Math.sin(u),l=Math.atan2(Math.sqrt((l=e*c-r*o)*l+(l=r*a-t*c)*l+(l=t*o-e*a)*l),t*a+e*o+r*c);po+=l,mo+=l*(t+(t=a)),vo+=l*(e+(e=o)),yo+=l*(r+(r=c))}var t,e,r;go>1||(1>go&&(go=1,po=mo=vo=yo=0),Mo.point=function(u,i){u*=Ha;var a=Math.cos(i*=Ha);t=a*Math.cos(u),e=a*Math.sin(u),r=Math.sin(i),Mo.point=n})}function kt(){Mo.point=wt}function At(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function qt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function Nt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Tt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function Ct(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function zt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function Dt(){return!0}function jt(n){return[Math.atan2(n[1],n[0]),Math.asin(Math.max(-1,Math.min(1,n[2])))]}function Lt(n,t){return Math.abs(n[0]-t[0])<Fa&&Math.abs(n[1]-t[1])<Fa}function Ft(n,t,e,r,u){var i=[],a=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(Lt(e,r)){u.lineStart();for(var o=0;t>o;++o)u.point((e=n[o])[0],e[1]);return u.lineEnd(),void 0}var c={point:e,points:n,other:null,visited:!1,entry:!0,subject:!0},l={point:e,points:[e],other:c,visited:!1,entry:!1,subject:!1};c.other=l,i.push(c),a.push(l),c={point:r,points:[r],other:null,visited:!1,entry:!1,subject:!0},l={point:r,points:[r],other:c,visited:!1,entry:!0,subject:!1},c.other=l,i.push(c),a.push(l)}}),a.sort(t),Ht(i),Ht(a),i.length){if(e)for(var o=1,c=!e(a[0].point),l=a.length;l>o;++o)a[o].entry=c=!c;for(var f,s,h,g=i[0];;){for(f=g;f.visited;)if((f=f.next)===g)return;s=f.points,u.lineStart();do{if(f.visited=f.other.visited=!0,f.entry){if(f.subject)for(var o=0;o<s.length;o++)u.point((h=s[o])[0],h[1]);else r(f.point,f.next.point,1,u);f=f.next}else{if(f.subject){s=f.prev.points;for(var o=s.length;--o>=0;)u.point((h=s[o])[0],h[1])}else r(f.point,f.prev.point,-1,u);f=f.prev}f=f.other,s=f.points}while(!f.visited);u.lineEnd()}}}function Ht(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.next=e=n[r],e.prev=u,u=e;u.next=e=n[0],e.prev=u}}function Pt(n,t,e){return function(r){function u(t,e){n(t,e)&&r.point(t,e)}function i(n,t){m.point(n,t)}function a(){v.point=i,m.lineStart()}function o(){v.point=u,m.lineEnd()}function c(n,t){M.point(n,t),d.push([n,t])}function l(){M.lineStart(),d=[]}function f(){c(d[0][0],d[0][1]),M.lineEnd();var n,t=M.clean(),e=y.buffer(),u=e.length;if(!u)return p=!0,g+=Yt(d,-1),d=null,void 0;if(d=null,1&t){n=e[0],h+=Yt(n,1);var i,u=n.length-1,a=-1;for(r.lineStart();++a<u;)r.point((i=n[a])[0],i[1]);return r.lineEnd(),void 0}u>1&&2&t&&e.push(e.pop().concat(e.shift())),s.push(e.filter(Rt))}var s,h,g,p,d,m=t(r),v={point:u,lineStart:a,lineEnd:o,polygonStart:function(){v.point=c,v.lineStart=l,v.lineEnd=f,p=!1,g=h=0,s=[],r.polygonStart()},polygonEnd:function(){v.point=u,v.lineStart=a,v.lineEnd=o,s=oa.merge(s),s.length?Ft(s,Ut,null,e,r):(-Fa>h||p&&-Fa>g)&&(r.lineStart(),e(null,null,1,r),r.lineEnd()),r.polygonEnd(),s=null},sphere:function(){r.polygonStart(),r.lineStart(),e(null,null,1,r),r.lineEnd(),r.polygonEnd()}},y=Ot(),M=t(y);return v}}function Rt(n){return n.length>1}function Ot(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:N,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Yt(n,t){if(!(e=n.length))return 0;for(var e,r,u,i=0,a=0,o=n[0],c=o[0],l=o[1],f=Math.cos(l),s=Math.atan2(t*Math.sin(c)*f,Math.sin(l)),h=1-t*Math.cos(c)*f,g=s;++i<e;)o=n[i],f=Math.cos(l=o[1]),r=Math.atan2(t*Math.sin(c=o[0])*f,Math.sin(l)),u=1-t*Math.cos(c)*f,Math.abs(h-2)<Fa&&Math.abs(u-2)<Fa||(Math.abs(u)<Fa||Math.abs(h)<Fa||(Math.abs(Math.abs(r-s)-La)<Fa?u+h>2&&(a+=4*(r-s)):a+=Math.abs(h-2)<Fa?4*(r-g):((3*La+r-s)%(2*La)-La)*(h+u)),g=s,s=r,h=u);return a}function Ut(n,t){return((n=n.point)[0]<0?n[1]-La/2-Fa:La/2-n[1])-((t=t.point)[0]<0?t[1]-La/2-Fa:La/2-t[1])}function It(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,a){var o=i>0?La:-La,c=Math.abs(i-e);Math.abs(c-La)<Fa?(n.point(e,r=(r+a)/2>0?La/2:-La/2),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(o,r),n.point(i,r),t=0):u!==o&&c>=La&&(Math.abs(e-u)<Fa&&(e-=u*Fa),Math.abs(i-o)<Fa&&(i-=o*Fa),r=Vt(e,r,i,a),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(o,r),t=0),n.point(e=i,r=a),u=o},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function Vt(n,t,e,r){var u,i,a=Math.sin(n-e);return Math.abs(a)>Fa?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*a)):(t+r)/2}function Xt(n,t,e,r){var u;if(null==n)u=e*La/2,r.point(-La,u),r.point(0,u),r.point(La,u),r.point(La,0),r.point(La,-u),r.point(0,-u),r.point(-La,-u),r.point(-La,0),r.point(-La,u);else if(Math.abs(n[0]-t[0])>Fa){var i=(n[0]<t[0]?1:-1)*La;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Zt(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,l,f;return{lineStart:function(){l=c=!1,f=1},point:function(s,h){var g,p=[s,h],d=t(s,h),m=a?d?0:u(s,h):d?u(s+(0>s?La:-La),h):0;if(!e&&(l=c=d)&&n.lineStart(),d!==c&&(g=r(e,p),(Lt(e,g)||Lt(p,g))&&(p[0]+=Fa,p[1]+=Fa,d=t(p[0],p[1]))),d!==c)f=0,d?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(o&&e&&a^d){var v;m&i||!(v=r(p,e,!0))||(f=0,a?(n.lineStart(),n.point(v[0][0],v[0][1]),n.point(v[1][0],v[1][1]),n.lineEnd()):(n.point(v[1][0],v[1][1]),n.lineEnd(),n.lineStart(),n.point(v[0][0],v[0][1])))}!d||e&&Lt(e,p)||n.point(p[0],p[1]),e=p,c=d,i=m},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return f|(l&&c)<<1}}}function r(n,t,e){var r=At(n),u=At(t),a=[1,0,0],o=Nt(r,u),c=qt(o,o),l=o[0],f=c-l*l;if(!f)return!e&&n;var s=i*c/f,h=-i*l/f,g=Nt(a,o),p=Ct(a,s),d=Ct(o,h);Tt(p,d);var m=g,v=qt(p,m),y=qt(m,m),M=v*v-y*(qt(p,p)-1);if(!(0>M)){var x=Math.sqrt(M),b=Ct(m,(-v-x)/y);if(Tt(b,p),b=jt(b),!e)return b;var _,w=n[0],S=t[0],E=n[1],k=t[1];w>S&&(_=w,w=S,S=_);var A=S-w,q=Math.abs(A-La)<Fa,N=q||Fa>A;if(!q&&E>k&&(_=E,E=k,k=_),N?q?E+k>0^b[1]<(Math.abs(b[0]-w)<Fa?E:k):E<=b[1]&&b[1]<=k:A>La^(w<=b[0]&&b[0]<=S)){var T=Ct(m,(-v+x)/y);return Tt(T,p),[b,jt(T)]}}}function u(t,e){var r=a?n:La-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),a=i>0,o=Math.abs(i)>Fa,c=ie(n,6*Ha);return Pt(t,e,c)}function Bt(n,t,e,r){function u(r,u){return Math.abs(r[0]-n)<Fa?u>0?0:3:Math.abs(r[0]-e)<Fa?u>0?2:1:Math.abs(r[1]-t)<Fa?u>0?1:0:u>0?3:2}function i(n,t){return a(n.point,t.point)}function a(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}function o(u,i){var a=i[0]-u[0],o=i[1]-u[1],c=[0,1];return Math.abs(a)<Fa&&Math.abs(o)<Fa?n<=u[0]&&u[0]<=e&&t<=u[1]&&u[1]<=r:$t(n-u[0],a,c)&&$t(u[0]-e,-a,c)&&$t(t-u[1],o,c)&&$t(u[1]-r,-o,c)?(c[1]<1&&(i[0]=u[0]+c[1]*a,i[1]=u[1]+c[1]*o),c[0]>0&&(u[0]+=c[0]*a,u[1]+=c[0]*o),!0):!1}return function(c){function l(i){var a=u(i,-1),o=f([0===a||3===a?n:e,a>1?r:t]);return o}function f(n){for(var t=0,e=M.length,r=n[1],u=0;e>u;++u)for(var i=1,a=M[u],o=a.length,c=a[0];o>i;++i)b=a[i],c[1]<=r?b[1]>r&&s(c,b,n)>0&&++t:b[1]<=r&&s(c,b,n)<0&&--t,c=b;return 0!==t}function s(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(e[0]-n[0])*(t[1]-n[1])}function h(i,o,c,l){var f=0,s=0;if(null==i||(f=u(i,c))!==(s=u(o,c))||a(i,o)<0^c>0){do l.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+c+4)%4)!==s)}else l.point(o[0],o[1])}function g(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function p(n,t){g(n,t)&&c.point(n,t)}function d(){C.point=v,M&&M.push(x=[]),q=!0,A=!1,E=k=0/0}function m(){y&&(v(_,w),S&&A&&T.rejoin(),y.push(T.buffer())),C.point=p,A&&c.lineEnd()}function v(n,t){n=Math.max(-bo,Math.min(bo,n)),t=Math.max(-bo,Math.min(bo,t));var e=g(n,t);if(M&&x.push([n,t]),q)_=n,w=t,S=e,q=!1,e&&(c.lineStart(),c.point(n,t));else if(e&&A)c.point(n,t);else{var r=[E,k],u=[n,t];o(r,u)?(A||(c.lineStart(),c.point(r[0],r[1])),c.point(u[0],u[1]),e||c.lineEnd()):(c.lineStart(),c.point(n,t))}E=n,k=t,A=e}var y,M,x,_,w,S,E,k,A,q,N=c,T=Ot(),C={point:p,lineStart:d,lineEnd:m,polygonStart:function(){c=T,y=[],M=[]},polygonEnd:function(){c=N,(y=oa.merge(y)).length?(c.polygonStart(),Ft(y,i,l,h,c),c.polygonEnd()):f([n,t])&&(c.polygonStart(),c.lineStart(),h(null,null,1,c),c.lineEnd(),c.polygonEnd()),y=M=x=null}};return C}}function $t(n,t,e){if(Math.abs(t)<Fa)return 0>=n;var r=n/t;if(t>0){if(r>e[1])return!1;r>e[0]&&(e[0]=r)}else{if(r<e[0])return!1;r<e[1]&&(e[1]=r)}return!0}function Jt(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function Gt(n){function t(t){function r(e,r){e=n(e,r),t.point(e[0],e[1])}function i(){f=0/0,d.point=a,t.lineStart()}function a(r,i){var a=At([r,i]),o=n(r,i);e(f,s,l,h,g,p,f=o[0],s=o[1],l=r,h=a[0],g=a[1],p=a[2],u,t),t.point(f,s)}function o(){d.point=r,t.lineEnd()}function c(){var n,r,c,m,v,y,M;i(),d.point=function(t,e){a(n=t,r=e),c=f,m=s,v=h,y=g,M=p,d.point=a},d.lineEnd=function(){e(f,s,l,h,g,p,c,m,n,v,y,M,u,t),d.lineEnd=o,o()}}var l,f,s,h,g,p,d={point:r,lineStart:i,lineEnd:o,polygonStart:function(){t.polygonStart(),d.lineStart=c},polygonEnd:function(){t.polygonEnd(),d.lineStart=i}};return d}function e(t,u,i,a,o,c,l,f,s,h,g,p,d,m){var v=l-t,y=f-u,M=v*v+y*y;if(M>4*r&&d--){var x=a+h,b=o+g,_=c+p,w=Math.sqrt(x*x+b*b+_*_),S=Math.asin(_/=w),E=Math.abs(Math.abs(_)-1)<Fa?(i+s)/2:Math.atan2(b,x),k=n(E,S),A=k[0],q=k[1],N=A-t,T=q-u,C=y*N-v*T;(C*C/M>r||Math.abs((v*N+y*T)/M-.5)>.3)&&(e(t,u,i,a,o,c,A,q,E,x/=w,b/=w,_,d,m),m.point(A,q),e(A,q,E,x,b,_,l,f,s,h,g,p,d,m))}}var r=.5,u=16;return t.precision=function(n){return arguments.length?(u=(r=n*n)>0&&16,t):Math.sqrt(r)},t}function Kt(n){return Wt(function(){return n})()}function Wt(n){function t(n){return n=a(n[0]*Ha,n[1]*Ha),[n[0]*f+o,c-n[1]*f]}function e(n){return n=a.invert((n[0]-o)/f,(c-n[1])/f),n&&[n[0]*Pa,n[1]*Pa]}function r(){a=Jt(i=te(d,m,v),u);var n=u(g,p);return o=s-n[0]*f,c=h+n[1]*f,t}var u,i,a,o,c,l=Gt(function(n,t){return n=u(n,t),[n[0]*f+o,c-n[1]*f]}),f=150,s=480,h=250,g=0,p=0,d=0,m=0,v=0,y=xo,M=ft,x=null,b=null;return t.stream=function(n){return Qt(i,y(l(M(n))))},t.clipAngle=function(n){return arguments.length?(y=null==n?(x=n,xo):Zt((x=+n)*Ha),t):x},t.clipExtent=function(n){return arguments.length?(b=n,M=null==n?ft:Bt(n[0][0],n[0][1],n[1][0],n[1][1]),t):b},t.scale=function(n){return arguments.length?(f=+n,r()):f},t.translate=function(n){return arguments.length?(s=+n[0],h=+n[1],r()):[s,h]},t.center=function(n){return arguments.length?(g=n[0]%360*Ha,p=n[1]%360*Ha,r()):[g*Pa,p*Pa]},t.rotate=function(n){return arguments.length?(d=n[0]%360*Ha,m=n[1]%360*Ha,v=n.length>2?n[2]%360*Ha:0,r()):[d*Pa,m*Pa,v*Pa]},oa.rebind(t,l,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function Qt(n,t){return{point:function(e,r){r=n(e*Ha,r*Ha),e=r[0],t.point(e>La?e-2*La:-La>e?e+2*La:e,r[1])},sphere:function(){t.sphere()},lineStart:function(){t.lineStart()},lineEnd:function(){t.lineEnd()},polygonStart:function(){t.polygonStart()},polygonEnd:function(){t.polygonEnd()}}}function ne(n,t){return[n,t]}function te(n,t,e){return n?t||e?Jt(re(n),ue(t,e)):re(n):t||e?ue(t,e):ne}function ee(n){return function(t,e){return t+=n,[t>La?t-2*La:-La>t?t+2*La:t,e]}}function re(n){var t=ee(n);return t.invert=ee(-n),t}function ue(n,t){function e(n,t){var e=Math.cos(t),o=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),f=l*r+o*u;return[Math.atan2(c*i-f*a,o*r-l*u),Math.asin(Math.max(-1,Math.min(1,f*i+c*a)))]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),a=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),o=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),f=l*i-c*a;return[Math.atan2(c*i+l*a,o*r+f*u),Math.asin(Math.max(-1,Math.min(1,f*r-o*u)))]},e}function ie(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,a,o){null!=u?(u=ae(e,u),i=ae(e,i),(a>0?i>u:u>i)&&(u+=2*a*La)):(u=n+2*a*La,i=n);for(var c,l=a*t,f=u;a>0?f>i:i>f;f-=l)o.point((c=jt([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function ae(n,t){var e=At(t);e[0]-=n,zt(e);var r=O(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Fa)%(2*Math.PI)}function oe(n,t,e){var r=oa.range(n,t-Fa,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function ce(n,t,e){var r=oa.range(n,t-Fa,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function le(n){return n.source}function fe(n){return n.target}function se(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),a=Math.cos(r),o=Math.sin(r),c=u*Math.cos(n),l=u*Math.sin(n),f=a*Math.cos(e),s=a*Math.sin(e),h=2*Math.asin(Math.sqrt(V(r-t)+u*a*V(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*f,u=e*l+t*s,a=e*i+t*o;return[Math.atan2(u,r)*Pa,Math.atan2(a,Math.sqrt(r*r+u*u))*Pa]}:function(){return[n*Pa,t*Pa]};return p.distance=h,p}function he(){function n(n,u){var i=Math.sin(u*=Ha),a=Math.cos(u),o=Math.abs((n*=Ha)-t),c=Math.cos(o);_o+=Math.atan2(Math.sqrt((o=a*Math.sin(o))*o+(o=r*i-e*a*c)*o),e*i+r*a*c),t=n,e=i,r=a}var t,e,r;wo.point=function(u,i){t=u*Ha,e=Math.sin(i*=Ha),r=Math.cos(i),wo.point=n},wo.lineEnd=function(){wo.point=wo.lineEnd=N}}function ge(n){var t=0,e=La/3,r=Wt(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*La/180,e=n[1]*La/180):[180*(t/La),180*(e/La)]},u}function pe(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),a-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),a=Math.sqrt(i)/u;return e.invert=function(n,t){var e=a-t;return[Math.atan2(n,e)/u,Math.asin((i-(n*n+e*e)*u*u)/(2*u))]},e}function de(n,t){var e=n(t[0]),r=n([.5*(t[0][0]+t[1][0]),t[0][1]]),u=n([t[1][0],t[0][1]]),i=n(t[1]),a=r[1]-e[1],o=r[0]-e[0],c=u[1]-r[1],l=u[0]-r[0],f=a/o,s=c/l,h=.5*(f*s*(e[1]-u[1])+s*(e[0]+r[0])-f*(r[0]+u[0]))/(s-f),g=(.5*(e[0]+r[0])-h)/f+.5*(e[1]+r[1]),p=i[0]-h,d=i[1]-g,m=e[0]-h,v=e[1]-g,y=p*p+d*d,M=m*m+v*v,x=Math.atan2(d,p),b=Math.atan2(v,m);return function(t){var e=t[0]-h,r=t[1]-g,u=e*e+r*r,i=Math.atan2(r,e);return u>y&&M>u&&i>x&&b>i?n.invert(t):void 0}}function me(){function n(n,t){Eo+=u*n-r*t,r=n,u=t}var t,e,r,u;ko.point=function(i,a){ko.point=n,t=r=i,e=u=a},ko.lineEnd=function(){n(t,e)}}function ve(){function n(n,t){a.push("M",n,",",t,i)}function t(n,t){a.push("M",n,",",t),o.point=e}function e(n,t){a.push("L",n,",",t)}function r(){o.point=n}function u(){a.push("Z")}var i=we(4.5),a=[],o={point:n,lineStart:function(){o.point=t},lineEnd:r,polygonStart:function(){o.lineEnd=u},polygonEnd:function(){o.lineEnd=r,o.point=n},pointRadius:function(n){return i=we(n),o},result:function(){if(a.length){var n=a.join("");return a=[],n}}};return o}function ye(n,t){go||(mo+=n,vo+=t,++yo)}function Me(){function n(n,r){var u=n-t,i=r-e,a=Math.sqrt(u*u+i*i);mo+=a*(t+n)/2,vo+=a*(e+r)/2,yo+=a,t=n,e=r}var t,e;if(1!==go){if(!(1>go))return;go=1,mo=vo=yo=0}Ao.point=function(r,u){Ao.point=n,t=r,e=u}}function xe(){Ao.point=ye}function be(){function n(n,t){var e=u*n-r*t;mo+=e*(r+n),vo+=e*(u+t),yo+=3*e,r=n,u=t}var t,e,r,u;2>go&&(go=2,mo=vo=yo=0),Ao.point=function(i,a){Ao.point=n,t=r=i,e=u=a},Ao.lineEnd=function(){n(t,e)}}function _e(n){function t(t,e){n.moveTo(t,e),n.arc(t,e,a,0,2*La)}function e(t,e){n.moveTo(t,e),o.point=r}function r(t,e){n.lineTo(t,e)}function u(){o.point=t}function i(){n.closePath()}var a=4.5,o={point:t,lineStart:function(){o.point=e},lineEnd:u,polygonStart:function(){o.lineEnd=i},polygonEnd:function(){o.lineEnd=u,o.point=t},pointRadius:function(n){return a=n,o},result:N};return o}function we(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Se(n){var t=Gt(function(t,e){return n([t*Pa,e*Pa])});return function(n){return n=t(n),{point:function(t,e){n.point(t*Ha,e*Ha)},sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}}function Ee(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),a=Math.cos(u);return[Math.atan2(n*i,r*a),Math.asin(r&&e*i/r)]},e}function ke(n,t){function e(n,t){var e=Math.abs(Math.abs(t)-La/2)<Fa?0:a/Math.pow(u(t),i);return[e*Math.sin(i*n),a-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(La/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),a=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=a-t,r=R(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(a/r,1/i))-La/2]},e):qe}function Ae(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return Math.abs(u)<Fa?ne:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-R(u)*Math.sqrt(n*n+e*e)]},e)}function qe(n,t){return[n,Math.log(Math.tan(La/4+t/2))]}function Ne(n){var t,e=Kt(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var a=i.apply(e,arguments);if(a===e){if(t=null==n){var o=La*r(),c=u();i([[c[0]-o,c[1]-o],[c[0]+o,c[1]+o]])}}else t&&(a=null);return a},e.clipExtent(null)}function Te(n,t){var e=Math.cos(t)*Math.sin(n);return[Math.log((1+e)/(1-e))/2,Math.atan2(Math.tan(t),Math.cos(n))]}function Ce(n){function t(t){function a(){l.push("M",i(n(f),o))}for(var c,l=[],f=[],s=-1,h=t.length,g=lt(e),p=lt(r);++s<h;)u.call(this,c=t[s],s)?f.push([+g.call(this,c,s),+p.call(this,c,s)]):f.length&&(a(),f=[]);return f.length&&a(),l.length?l.join(""):null}var e=ze,r=De,u=Dt,i=je,a=i.key,o=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(a="function"==typeof n?i=n:(i=Do.get(n)||je).key,t):a},t.tension=function(n){return arguments.length?(o=n,t):o},t}function ze(n){return n[0]}function De(n){return n[1]}function je(n){return n.join("L")}function Le(n){return je(n)+"Z"}function Fe(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function He(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function Pe(n,t){return n.length<4?je(n):n[1]+Ye(n.slice(1,n.length-1),Ue(n,t))}function Re(n,t){return n.length<3?je(n):n[0]+Ye((n.push(n[0]),n),Ue([n[n.length-2]].concat(n,[n[1]]),t))}function Oe(n,t){return n.length<3?je(n):n[0]+Ye(n,Ue(n,t))}function Ye(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return je(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],a=t[0],o=a,c=1;if(e&&(r+="Q"+(i[0]-a[0]*2/3)+","+(i[1]-a[1]*2/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){o=t[1],i=n[c],c++,r+="C"+(u[0]+a[0])+","+(u[1]+a[1])+","+(i[0]-o[0])+","+(i[1]-o[1])+","+i[0]+","+i[1];for(var l=2;l<t.length;l++,c++)i=n[c],o=t[l],r+="S"+(i[0]-o[0])+","+(i[1]-o[1])+","+i[0]+","+i[1]}if(e){var f=n[c];r+="Q"+(i[0]+o[0]*2/3)+","+(i[1]+o[1]*2/3)+","+f[0]+","+f[1]}return r}function Ue(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],a=n[1],o=1,c=n.length;++o<c;)e=i,i=a,a=n[o],r.push([u*(a[0]-e[0]),u*(a[1]-e[1])]);return r}function Ie(n){if(n.length<3)return je(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],a=[u,u,u,(r=n[1])[0]],o=[i,i,i,r[1]],c=[u,",",i];for($e(c,a,o);++t<e;)r=n[t],a.shift(),a.push(r[0]),o.shift(),o.push(r[1]),$e(c,a,o);for(t=-1;++t<2;)a.shift(),a.push(r[0]),o.shift(),o.push(r[1]),$e(c,a,o);return c.join("")}function Ve(n){if(n.length<4)return je(n);for(var t,e=[],r=-1,u=n.length,i=[0],a=[0];++r<3;)t=n[r],i.push(t[0]),a.push(t[1]);for(e.push(Be(Fo,i)+","+Be(Fo,a)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),a.shift(),a.push(t[1]),$e(e,i,a);return e.join("")}function Xe(n){for(var t,e,r=-1,u=n.length,i=u+4,a=[],o=[];++r<4;)e=n[r%u],a.push(e[0]),o.push(e[1]);for(t=[Be(Fo,a),",",Be(Fo,o)],--r;++r<i;)e=n[r%u],a.shift(),a.push(e[0]),o.shift(),o.push(e[1]),$e(t,a,o);return t.join("")}function Ze(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],a=n[0][1],o=n[e][0]-i,c=n[e][1]-a,l=-1;++l<=e;)r=n[l],u=l/e,r[0]=t*r[0]+(1-t)*(i+u*o),r[1]=t*r[1]+(1-t)*(a+u*c);return Ie(n)}function Be(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function $e(n,t,e){n.push("C",Be(jo,t),",",Be(jo,e),",",Be(Lo,t),",",Be(Lo,e),",",Be(Fo,t),",",Be(Fo,e))}function Je(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Ge(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],a=r[0]=Je(u,i);++t<e;)r[t]=(a+(a=Je(u=i,i=n[t+1])))/2;return r[t]=a,r}function Ke(n){for(var t,e,r,u,i=[],a=Ge(n),o=-1,c=n.length-1;++o<c;)t=Je(n[o],n[o+1]),Math.abs(t)<1e-6?a[o]=a[o+1]=0:(e=a[o]/t,r=a[o+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),a[o]=u*e,a[o+1]=u*r));for(o=-1;++o<=c;)u=(n[Math.min(c,o+1)][0]-n[Math.max(0,o-1)][0])/(6*(1+a[o]*a[o])),i.push([u||0,a[o]*u||0]);return i}function We(n){return n.length<3?je(n):n[0]+Ye(n,Ke(n))}function Qe(n,t,e,r){var u,i,a,o,c,l,f;return u=r[n],i=u[0],a=u[1],u=r[t],o=u[0],c=u[1],u=r[e],l=u[0],f=u[1],(f-a)*(o-i)-(c-a)*(l-i)>0}function nr(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function tr(n,t,e,r){var u=n[0],i=e[0],a=t[0]-u,o=r[0]-i,c=n[1],l=e[1],f=t[1]-c,s=r[1]-l,h=(o*(c-l)-s*(u-i))/(s*a-o*f);
return[u+h*a,c+h*f]}function er(n,t){var e={list:n.map(function(n,t){return{index:t,x:n[0],y:n[1]}}).sort(function(n,t){return n.y<t.y?-1:n.y>t.y?1:n.x<t.x?-1:n.x>t.x?1:0}),bottomSite:null},r={list:[],leftEnd:null,rightEnd:null,init:function(){r.leftEnd=r.createHalfEdge(null,"l"),r.rightEnd=r.createHalfEdge(null,"l"),r.leftEnd.r=r.rightEnd,r.rightEnd.l=r.leftEnd,r.list.unshift(r.leftEnd,r.rightEnd)},createHalfEdge:function(n,t){return{edge:n,side:t,vertex:null,l:null,r:null}},insert:function(n,t){t.l=n,t.r=n.r,n.r.l=t,n.r=t},leftBound:function(n){var t=r.leftEnd;do t=t.r;while(t!=r.rightEnd&&u.rightOf(t,n));return t=t.l},del:function(n){n.l.r=n.r,n.r.l=n.l,n.edge=null},right:function(n){return n.r},left:function(n){return n.l},leftRegion:function(n){return n.edge==null?e.bottomSite:n.edge.region[n.side]},rightRegion:function(n){return n.edge==null?e.bottomSite:n.edge.region[Ho[n.side]]}},u={bisect:function(n,t){var e={region:{l:n,r:t},ep:{l:null,r:null}},r=t.x-n.x,u=t.y-n.y,i=r>0?r:-r,a=u>0?u:-u;return e.c=n.x*r+n.y*u+.5*(r*r+u*u),i>a?(e.a=1,e.b=u/r,e.c/=r):(e.b=1,e.a=r/u,e.c/=u),e},intersect:function(n,t){var e=n.edge,r=t.edge;if(!e||!r||e.region.r==r.region.r)return null;var u=e.a*r.b-e.b*r.a;if(Math.abs(u)<1e-10)return null;var i,a,o=(e.c*r.b-r.c*e.b)/u,c=(r.c*e.a-e.c*r.a)/u,l=e.region.r,f=r.region.r;l.y<f.y||l.y==f.y&&l.x<f.x?(i=n,a=e):(i=t,a=r);var s=o>=a.region.r.x;return s&&i.side==="l"||!s&&i.side==="r"?null:{x:o,y:c}},rightOf:function(n,t){var e=n.edge,r=e.region.r,u=t.x>r.x;if(u&&n.side==="l")return 1;if(!u&&n.side==="r")return 0;if(e.a===1){var i=t.y-r.y,a=t.x-r.x,o=0,c=0;if(!u&&e.b<0||u&&e.b>=0?c=o=i>=e.b*a:(c=t.x+t.y*e.b>e.c,e.b<0&&(c=!c),c||(o=1)),!o){var l=r.x-e.region.l.x;c=e.b*(a*a-i*i)<l*i*(1+2*a/l+e.b*e.b),e.b<0&&(c=!c)}}else{var f=e.c-e.a*t.x,s=t.y-f,h=t.x-r.x,g=f-r.y;c=s*s>h*h+g*g}return n.side==="l"?c:!c},endPoint:function(n,e,r){n.ep[e]=r,n.ep[Ho[e]]&&t(n)},distance:function(n,t){var e=n.x-t.x,r=n.y-t.y;return Math.sqrt(e*e+r*r)}},i={list:[],insert:function(n,t,e){n.vertex=t,n.ystar=t.y+e;for(var r=0,u=i.list,a=u.length;a>r;r++){var o=u[r];if(!(n.ystar>o.ystar||n.ystar==o.ystar&&t.x>o.vertex.x))break}u.splice(r,0,n)},del:function(n){for(var t=0,e=i.list,r=e.length;r>t&&e[t]!=n;++t);e.splice(t,1)},empty:function(){return i.list.length===0},nextEvent:function(n){for(var t=0,e=i.list,r=e.length;r>t;++t)if(e[t]==n)return e[t+1];return null},min:function(){var n=i.list[0];return{x:n.vertex.x,y:n.ystar}},extractMin:function(){return i.list.shift()}};r.init(),e.bottomSite=e.list.shift();for(var a,o,c,l,f,s,h,g,p,d,m,v,y,M=e.list.shift();;)if(i.empty()||(a=i.min()),M&&(i.empty()||M.y<a.y||M.y==a.y&&M.x<a.x))o=r.leftBound(M),c=r.right(o),h=r.rightRegion(o),v=u.bisect(h,M),s=r.createHalfEdge(v,"l"),r.insert(o,s),d=u.intersect(o,s),d&&(i.del(o),i.insert(o,d,u.distance(d,M))),o=s,s=r.createHalfEdge(v,"r"),r.insert(o,s),d=u.intersect(s,c),d&&i.insert(s,d,u.distance(d,M)),M=e.list.shift();else{if(i.empty())break;o=i.extractMin(),l=r.left(o),c=r.right(o),f=r.right(c),h=r.leftRegion(o),g=r.rightRegion(c),m=o.vertex,u.endPoint(o.edge,o.side,m),u.endPoint(c.edge,c.side,m),r.del(o),i.del(c),r.del(c),y="l",h.y>g.y&&(p=h,h=g,g=p,y="r"),v=u.bisect(h,g),s=r.createHalfEdge(v,y),r.insert(l,s),u.endPoint(v,Ho[y],m),d=u.intersect(l,s),d&&(i.del(l),i.insert(l,d,u.distance(d,h))),d=u.intersect(s,f),d&&i.insert(s,d,u.distance(d,h))}for(o=r.right(r.leftEnd);o!=r.rightEnd;o=r.right(o))t(o.edge)}function rr(n){return n.x}function ur(n){return n.y}function ir(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function ar(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var a=.5*(e+u),o=.5*(r+i),c=t.nodes;c[0]&&ar(n,c[0],e,r,a,o),c[1]&&ar(n,c[1],a,r,u,o),c[2]&&ar(n,c[2],e,o,a,i),c[3]&&ar(n,c[3],a,o,u,i)}}function or(n,t){n=oa.rgb(n),t=oa.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,a=t.g-r,o=t.b-u;return function(n){return"#"+rt(Math.round(e+i*n))+rt(Math.round(r+a*n))+rt(Math.round(u+o*n))}}function cr(n){var t=[n.a,n.b],e=[n.c,n.d],r=fr(t),u=lr(t,e),i=fr(sr(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Pa,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*Pa:0}function lr(n,t){return n[0]*t[0]+n[1]*t[1]}function fr(n){var t=Math.sqrt(lr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function sr(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function hr(n,t){return t-=n,function(e){return n+t*e}}function gr(n,t){var e,r=[],u=[],i=oa.transform(n),a=oa.transform(t),o=i.translate,c=a.translate,l=i.rotate,f=a.rotate,s=i.skew,h=a.skew,g=i.scale,p=a.scale;return o[0]!=c[0]||o[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:hr(o[0],c[0])},{i:3,x:hr(o[1],c[1])})):c[0]||c[1]?r.push("translate("+c+")"):r.push(""),l!=f?(l-f>180?f+=360:f-l>180&&(l+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:hr(l,f)})):f&&r.push(r.pop()+"rotate("+f+")"),s!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:hr(s,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:hr(g[0],p[0])},{i:e-2,x:hr(g[1],p[1])})):(p[0]!=1||p[1]!=1)&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function pr(n,t){var e,r={},u={};for(e in n)e in t?r[e]=vr(e)(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function dr(n,t){var e,r,u,i,a,o=0,c=0,l=[],f=[];for(Ro.lastIndex=0,r=0;e=Ro.exec(t);++r)e.index&&l.push(t.substring(o,c=e.index)),f.push({i:l.length,x:e[0]}),l.push(null),o=Ro.lastIndex;for(o<t.length&&l.push(t.substring(o)),r=0,i=f.length;(e=Ro.exec(n))&&i>r;++r)if(a=f[r],a.x==e[0]){if(a.i)if(l[a.i+1]==null)for(l[a.i-1]+=a.x,l.splice(a.i,1),u=r+1;i>u;++u)f[u].i--;else for(l[a.i-1]+=a.x+l[a.i+1],l.splice(a.i,2),u=r+1;i>u;++u)f[u].i-=2;else if(l[a.i+1]==null)l[a.i]=a.x;else for(l[a.i]=a.x+l[a.i+1],l.splice(a.i+1,1),u=r+1;i>u;++u)f[u].i--;f.splice(r,1),i--,r--}else a.x=hr(parseFloat(e[0]),parseFloat(a.x));for(;i>r;)a=f.pop(),l[a.i+1]==null?l[a.i]=a.x:(l[a.i]=a.x+l[a.i+1],l.splice(a.i+1,1)),i--;return l.length===1?l[0]==null?f[0].x:function(){return t}:function(n){for(r=0;i>r;++r)l[(a=f[r]).i]=a.x(n);return l.join("")}}function mr(n,t){for(var e,r=oa.interpolators.length;--r>=0&&!(e=oa.interpolators[r](n,t)););return e}function vr(n){return"transform"==n?gr:mr}function yr(n,t){var e,r=[],u=[],i=n.length,a=t.length,o=Math.min(n.length,t.length);for(e=0;o>e;++e)r.push(mr(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;a>e;++e)u[e]=t[e];return function(n){for(e=0;o>e;++e)u[e]=r[e](n);return u}}function Mr(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function xr(n){return function(t){return 1-n(1-t)}}function br(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function _r(n){return n*n}function wr(n){return n*n*n}function Sr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function kr(n){return 1-Math.cos(n*La/2)}function Ar(n){return Math.pow(2,10*(n-1))}function qr(n){return 1-Math.sqrt(1-n*n)}function Nr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/(2*La)*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,10*-r)*Math.sin(2*(r-e)*La/t)}}function Tr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Cr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function zr(n,t){n=oa.hcl(n),t=oa.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,a=t.c-r,o=t.l-u;return i>180?i-=360:-180>i&&(i+=360),function(n){return B(e+i*n,r+a*n,u+o*n)+""}}function Dr(n,t){n=oa.hsl(n),t=oa.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,a=t.s-r,o=t.l-u;return i>180?i-=360:-180>i&&(i+=360),function(n){return P(e+i*n,r+a*n,u+o*n)+""}}function jr(n,t){n=oa.lab(n),t=oa.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,a=t.a-r,o=t.b-u;return function(n){return G(e+i*n,r+a*n,u+o*n)+""}}function Lr(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Fr(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return(e-n)*t}}function Hr(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return Math.max(0,Math.min(1,(e-n)*t))}}function Pr(n){for(var t=n.source,e=n.target,r=Or(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function Rr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Or(n,t){if(n===t)return n;for(var e=Rr(n),r=Rr(t),u=e.pop(),i=r.pop(),a=null;u===i;)a=u,u=e.pop(),i=r.pop();return a}function Yr(n){n.fixed|=2}function Ur(n){n.fixed&=-7}function Ir(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Vr(n){n.fixed&=-5}function Xr(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,a=n.nodes,o=a.length,c=-1;++c<o;)i=a[c],null!=i&&(Xr(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var l=t*e[n.point.index];n.charge+=n.pointCharge=l,r+=l*n.point.x,u+=l*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Zr(n,t){return oa.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=Gr,n}function Br(n){return n.children}function $r(n){return n.value}function Jr(n,t){return t.value-n.value}function Gr(n){return oa.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function Kr(n){return n.x}function Wr(n){return n.y}function Qr(n,t,e){n.y0=t,n.y=e}function nu(n){return oa.range(n.length)}function tu(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function eu(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function ru(n){return n.reduce(uu,0)}function uu(n,t){return n+t[1]}function iu(n,t){return au(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function au(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function ou(n){return[oa.min(n),oa.max(n)]}function cu(n,t){return n.parent==t.parent?1:2}function lu(n){var t=n.children;return t&&t.length?t[0]:n._tree.thread}function fu(n){var t,e=n.children;return e&&(t=e.length)?e[t-1]:n._tree.thread}function su(n,t){var e=n.children;if(e&&(u=e.length))for(var r,u,i=-1;++i<u;)t(r=su(e[i],t),n)>0&&(n=r);return n}function hu(n,t){return n.x-t.x}function gu(n,t){return t.x-n.x}function pu(n,t){return n.depth-t.depth}function du(n,t){function e(n,r){var u=n.children;if(u&&(a=u.length))for(var i,a,o=null,c=-1;++c<a;)i=u[c],e(i,o),o=i;t(n,r)}e(n,null)}function mu(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i]._tree,t.prelim+=e,t.mod+=e,e+=t.shift+(r+=t.change)}function vu(n,t,e){n=n._tree,t=t._tree;var r=e/(t.number-n.number);n.change+=r,t.change-=r,t.shift+=e,t.prelim+=e,t.mod+=e}function yu(n,t,e){return n._tree.ancestor.parent==t.parent?n._tree.ancestor:e}function Mu(n,t){return n.value-t.value}function xu(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function bu(n,t){n._pack_next=t,t._pack_prev=n}function _u(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return u*u-e*e-r*r>.001}function wu(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(l=e.length)){var e,r,u,i,a,o,c,l,f=1/0,s=-1/0,h=1/0,g=-1/0;if(e.forEach(Su),r=e[0],r.x=-r.r,r.y=0,t(r),l>1&&(u=e[1],u.x=u.r,u.y=0,t(u),l>2))for(i=e[2],Au(r,u,i),t(i),xu(r,i),r._pack_prev=i,xu(i,u),u=r._pack_next,a=3;l>a;a++){Au(r,u,i=e[a]);var p=0,d=1,m=1;for(o=u._pack_next;o!==u;o=o._pack_next,d++)if(_u(o,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==o._pack_prev&&!_u(c,i);c=c._pack_prev,m++);p?(m>d||d==m&&u.r<r.r?bu(r,u=o):bu(r=c,u),a--):(xu(r,i),u=i,t(i))}var v=(f+s)/2,y=(h+g)/2,M=0;for(a=0;l>a;a++)i=e[a],i.x-=v,i.y-=y,M=Math.max(M,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=M,e.forEach(Eu)}}function Su(n){n._pack_next=n._pack_prev=n}function Eu(n){delete n._pack_next,delete n._pack_prev}function ku(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,a=u.length;++i<a;)ku(u[i],t,e,r)}function Au(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var a=t.r+e.r,o=u*u+i*i;a*=a,r*=r;var c=.5+(r-a)/(2*o),l=Math.sqrt(Math.max(0,2*a*(r+o)-(r-=o)*r-a*a))/(2*o);e.x=n.x+c*u+l*i,e.y=n.y+c*i-l*u}else e.x=n.x+r,e.y=n.y}function qu(n){return 1+oa.max(n,function(n){return n.y})}function Nu(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Tu(n){var t=n.children;return t&&t.length?Tu(t[0]):n}function Cu(n){var t,e=n.children;return e&&(t=e.length)?Cu(e[t-1]):n}function zu(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Du(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function ju(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Lu(n){return n.rangeExtent?n.rangeExtent():ju(n.range())}function Fu(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Hu(n,t){var e,r=0,u=n.length-1,i=n[r],a=n[u];return i>a&&(e=r,r=u,u=e,e=i,i=a,a=e),(t=t(a-i))&&(n[r]=t.floor(i),n[u]=t.ceil(a)),n}function Pu(n,t,e,r){var u=[],i=[],a=0,o=Math.min(n.length,t.length)-1;for(n[o]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++a<=o;)u.push(e(n[a-1],n[a])),i.push(r(t[a-1],t[a]));return function(t){var e=oa.bisect(n,t,1,o)-1;return i[e](u[e](t))}}function Ru(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?Pu:Fu,c=r?Hr:Fr;return a=u(n,t,c,e),o=u(t,n,c,mr),i}function i(n){return a(n)}var a,o;return i.invert=function(n){return o(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Lr)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Iu(n,t)},i.tickFormat=function(t,e){return Vu(n,t,e)},i.nice=function(){return Hu(n,Yu),u()},i.copy=function(){return Ru(n,t,e,r)},u()}function Ou(n,t){return oa.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Yu(n){return n=Math.pow(10,Math.round(Math.log(n)/Math.LN10)-1),n&&{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}}function Uu(n,t){var e=ju(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Iu(n,t){return oa.range.apply(oa,Uu(n,t))}function Vu(n,t,e){var r=-Math.floor(Math.log(Uu(n,t)[2])/Math.LN10+.01);return oa.format(e?e.replace(ro,function(n,t,e,u,i,a,o,c,l,f){return[t,e,u,i,a,o,c,l||"."+(r-2*("%"===f)),f].join("")}):",."+r+"f")}function Xu(n,t,e,r){function u(t){return n(e(t))}return u.invert=function(t){return r(n.invert(t))},u.domain=function(t){return arguments.length?(t[0]<0?(e=$u,r=Ju):(e=Zu,r=Bu),n.domain(t.map(e)),u):n.domain().map(r)},u.base=function(n){return arguments.length?(t=+n,u):t},u.nice=function(){return n.domain(Hu(n.domain(),Gu(t))),u},u.ticks=function(){var u=ju(n.domain()),i=[];if(u.every(isFinite)){var a=Math.log(t),o=Math.floor(u[0]/a),c=Math.ceil(u[1]/a),l=r(u[0]),f=r(u[1]),s=t%1?2:t;if(e===$u)for(i.push(-Math.pow(t,-o));o++<c;)for(var h=s-1;h>0;h--)i.push(-Math.pow(t,-o)*h);else{for(;c>o;o++)for(var h=1;s>h;h++)i.push(Math.pow(t,o)*h);i.push(Math.pow(t,o))}for(o=0;i[o]<l;o++);for(c=i.length;i[c-1]>f;c--);i=i.slice(o,c)}return i},u.tickFormat=function(n,i){if(arguments.length<2&&(i=$o),!arguments.length)return i;var a,o=Math.log(t),c=Math.max(.1,n/u.ticks().length),l=e===$u?(a=-1e-12,Math.floor):(a=1e-12,Math.ceil);return function(n){return n/r(o*l(e(n)/o+a))<=c?i(n):""}},u.copy=function(){return Xu(n.copy(),t,e,r)},Ou(u,n)}function Zu(n){return Math.log(0>n?0:n)}function Bu(n){return Math.exp(n)}function $u(n){return-Math.log(n>0?0:-n)}function Ju(n){return-Math.exp(-n)}function Gu(n){n=Math.log(n);var t={floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}};return function(){return t}}function Ku(n,t){function e(t){return n(r(t))}var r=Wu(t),u=Wu(1/t);return e.invert=function(t){return u(n.invert(t))},e.domain=function(t){return arguments.length?(n.domain(t.map(r)),e):n.domain().map(u)},e.ticks=function(n){return Iu(e.domain(),n)},e.tickFormat=function(n,t){return Vu(e.domain(),n,t)},e.nice=function(){return e.domain(Hu(e.domain(),Yu))},e.exponent=function(n){if(!arguments.length)return t;var i=e.domain();return r=Wu(t=n),u=Wu(1/t),e.domain(i)},e.copy=function(){return Ku(n.copy(),t)},Ou(e,n)}function Wu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Qu(n,t){function e(t){return a[((i.get(t)||i.set(t,n.push(t)))-1)%a.length]}function r(t,e){return oa.range(n.length).map(function(n){return t+e*n})}var i,a,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new u;for(var a,o=-1,c=r.length;++o<c;)i.has(a=r[o])||i.set(a,n.push(a));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(a=n,o=0,t={t:"range",a:arguments},e):a},e.rangePoints=function(u,i){arguments.length<2&&(i=0);var c=u[0],l=u[1],f=(l-c)/(Math.max(1,n.length-1)+i);return a=r(n.length<2?(c+l)/2:c+f*i/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var l=u[1]<u[0],f=u[l-0],s=u[1-l],h=(s-f)/(n.length-i+2*c);return a=r(f+h*c,h),l&&a.reverse(),o=h*(1-i),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var l=u[1]<u[0],f=u[l-0],s=u[1-l],h=Math.floor((s-f)/(n.length-i+2*c)),g=s-f-(n.length-i)*h;return a=r(f+Math.round(g/2),h),l&&a.reverse(),o=Math.round(h*(1-i)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return ju(t.a[0])},e.copy=function(){return Qu(n,t)},e.domain(n)}function ni(n,t){function e(){var e=0,i=t.length;for(u=[];++e<i;)u[e-1]=oa.quantile(n,e/i);return r}function r(n){return isNaN(n=+n)?0/0:t[oa.bisect(u,n)]}var u;return r.domain=function(t){return arguments.length?(n=t.filter(function(n){return!isNaN(n)}).sort(oa.ascending),e()):n},r.range=function(n){return arguments.length?(t=n,e()):t},r.quantiles=function(){return u},r.copy=function(){return ni(n,t)},e()}function ti(n,t,e){function r(t){return e[Math.max(0,Math.min(a,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),a=e.length-1,r}var i,a;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.copy=function(){return ti(n,t,e)},u()}function ei(n,t){function e(e){return t[oa.bisect(n,e)]}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.copy=function(){return ei(n,t)},e}function ri(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Iu(n,t)},t.tickFormat=function(t,e){return Vu(n,t,e)},t.copy=function(){return ri(n)},t}function ui(n){return n.innerRadius}function ii(n){return n.outerRadius}function ai(n){return n.startAngle}function oi(n){return n.endAngle}function ci(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]+Qo,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function li(n){function t(t){function c(){d.push("M",o(n(v),s),f,l(n(m.reverse()),s),"Z")}for(var h,g,p,d=[],m=[],v=[],y=-1,M=t.length,x=lt(e),b=lt(u),_=e===r?function(){return g}:lt(r),w=u===i?function(){return p}:lt(i);++y<M;)a.call(this,h=t[y],y)?(m.push([g=+x.call(this,h,y),p=+b.call(this,h,y)]),v.push([+_.call(this,h,y),+w.call(this,h,y)])):m.length&&(c(),m=[],v=[]);return m.length&&c(),d.length?d.join(""):null}var e=ze,r=ze,u=0,i=De,a=Dt,o=je,c=o.key,l=o,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(a=n,t):a},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?o=n:(o=Do.get(n)||je).key,l=o.reverse||o,f=o.closed?"M":"L",t):c},t.tension=function(n){return arguments.length?(s=n,t):s},t}function fi(n){return n.radius}function si(n){return[n.x,n.y]}function hi(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]+Qo;return[e*Math.cos(r),e*Math.sin(r)]}}function gi(){return 64}function pi(){return"circle"}function di(n){var t=Math.sqrt(n/La);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function mi(n,t){return Ma(n,ic),n.id=t,n}function vi(n,t,e,r){var u=n.id;return D(n,"function"==typeof e?function(n,i,a){n.__transition__[u].tween.set(t,r(e.call(n,n.__data__,i,a)))}:(e=r(e),function(n){n.__transition__[u].tween.set(t,e)}))}function yi(n){return null==n&&(n=""),function(){this.textContent=n}}function Mi(n,t,e,r){var i=n.__transition__||(n.__transition__={active:0,count:0}),a=i[e];if(!a){var o=r.time;return a=i[e]={tween:new u,event:oa.dispatch("start","end"),time:o,ease:r.ease,delay:r.delay,duration:r.duration},++i.count,oa.timer(function(r){function u(r){return i.active>e?l():(i.active=e,h.start.call(n,f,t),a.tween.forEach(function(e,r){(r=r.call(n,f,t))&&d.push(r)}),c(r)||oa.timer(c,0,o),1)}function c(r){if(i.active!==e)return l();for(var u=(r-g)/p,a=s(u),o=d.length;o>0;)d[--o].call(n,a);return u>=1?(l(),h.end.call(n,f,t),1):void 0}function l(){return--i.count?delete i[e]:delete n.__transition__,1}var f=n.__data__,s=a.ease,h=a.event,g=a.delay,p=a.duration,d=[];return r>=g?u(r):oa.timer(u,g,o),1},0,o),a}}function xi(n,t){n.attr("transform",function(n){return"translate("+t(n)+",0)"})}function bi(n,t){n.attr("transform",function(n){return"translate(0,"+t(n)+")"})}function _i(n,t,e){if(r=[],e&&t.length>1){for(var r,u,i,a=ju(n.domain()),o=-1,c=t.length,l=(t[1]-t[0])/++e;++o<c;)for(u=e;--u>0;)(i=+t[o]-u*l)>=a[0]&&r.push(i);for(--o,u=0;++u<e&&(i=+t[o]+u*l)<a[1];)r.push(i)}return r}function wi(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Si(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new hc(e-1)),1),e}function i(n,e){return t(n=new hc(+n),e),n}function a(n,r,i){var a=u(n),o=[];if(i>1)for(;r>a;)e(a)%i||o.push(new Date(+a)),t(a,1);else for(;r>a;)o.push(new Date(+a)),t(a,1);return o}function o(n,t,e){try{hc=wi;var r=new wi;return r._=n,a(r,t,e)}finally{hc=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=a;var c=n.utc=Ei(n);return c.floor=c,c.round=Ei(r),c.ceil=Ei(u),c.offset=Ei(i),c.range=o,n}function Ei(n){return function(t,e){try{hc=wi;var r=new wi;return r._=t,n(r,e)._}finally{hc=Date}}}function ki(n,t,e,r){for(var u,i,a=0,o=t.length,c=e.length;o>a;){if(r>=c)return-1;if(u=t.charCodeAt(a++),37===u){if(i=Tc[t.charAt(a++)],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function Ai(n){return RegExp("^(?:"+n.map(oa.requote).join("|")+")","i")}function qi(n){for(var t=new u,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Ni(n,t,e){n+="";var r=n.length;return e>r?Array(e-r+1).join(t)+n:n}function Ti(n,t,e){wc.lastIndex=0;var r=wc.exec(t.substring(e));return r?e+=r[0].length:-1}function Ci(n,t,e){_c.lastIndex=0;var r=_c.exec(t.substring(e));return r?e+=r[0].length:-1}function zi(n,t,e){kc.lastIndex=0;var r=kc.exec(t.substring(e));return r?(n.m=Ac.get(r[0].toLowerCase()),e+=r[0].length):-1}function Di(n,t,e){Sc.lastIndex=0;var r=Sc.exec(t.substring(e));return r?(n.m=Ec.get(r[0].toLowerCase()),e+=r[0].length):-1}function ji(n,t,e){return ki(n,""+Nc.c,t,e)}function Li(n,t,e){return ki(n,""+Nc.x,t,e)}function Fi(n,t,e){return ki(n,""+Nc.X,t,e)}function Hi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+4));return r?(n.y=+r[0],e+=r[0].length):-1}function Pi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.y=Ri(+r[0]),e+=r[0].length):-1}function Ri(n){return n+(n>68?1900:2e3)}function Oi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.m=r[0]-1,e+=r[0].length):-1}function Yi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.d=+r[0],e+=r[0].length):-1}function Ui(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.H=+r[0],e+=r[0].length):-1}function Ii(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.M=+r[0],e+=r[0].length):-1}function Vi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.S=+r[0],e+=r[0].length):-1}function Xi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+3));return r?(n.L=+r[0],e+=r[0].length):-1}function Zi(n,t,e){var r=zc.get(t.substring(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}function Bi(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=~~(Math.abs(t)/60),u=Math.abs(t)%60;return e+Ni(r,"0",2)+Ni(u,"0",2)}function $i(n){return n.toISOString()}function Ji(n,t,e){function r(t){return n(t)}return r.invert=function(t){return Ki(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Ki)},r.nice=function(n){return r.domain(Hu(r.domain(),function(){return n}))},r.ticks=function(e,u){var i=Gi(r.domain());if("function"!=typeof e){var a=i[1]-i[0],o=a/e,c=oa.bisect(jc,o);if(c==jc.length)return t.year(i,e);if(!c)return n.ticks(e).map(Ki);Math.log(o/jc[c-1])<Math.log(jc[c]/o)&&--c,e=t[c],u=e[1],e=e[0].range}return e(i[0],new Date(+i[1]+1),u)},r.tickFormat=function(){return e},r.copy=function(){return Ji(n.copy(),t,e)},oa.rebind(r,n,"range","rangeRound","interpolate","clamp")}function Gi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ki(n){return new Date(n)}function Wi(n){return function(t){for(var e=n.length-1,r=n[e];!r[1](t);)r=n[--e];return r[0](t)}}function Qi(n){var t=new Date(n,0,1);return t.setFullYear(n),t}function na(n){var t=n.getFullYear(),e=Qi(t),r=Qi(t+1);return t+(n-e)/(r-e)}function ta(n){var t=new Date(Date.UTC(n,0,1));return t.setUTCFullYear(n),t}function ea(n){var t=n.getUTCFullYear(),e=ta(t),r=ta(t+1);return t+(n-e)/(r-e)}function ra(n){return n.responseText}function ua(n){return JSON.parse(n.responseText)}function ia(n){var t=ca.createRange();return t.selectNode(ca.body),t.createContextualFragment(n.responseText)}function aa(n){return n.responseXML}var oa={version:"3.1.4"};Date.now||(Date.now=function(){return+new Date});var ca=document,la=window;try{ca.createElement("div").style.setProperty("opacity",0,"")}catch(fa){var sa=la.CSSStyleDeclaration.prototype,ha=sa.setProperty;sa.setProperty=function(n,t,e){ha.call(this,n,t+"",e)}}oa.ascending=function(n,t){return t>n?-1:n>t?1:n>=t?0:0/0},oa.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},oa.min=function(n,t){var e,r,u=-1,i=n.length;if(arguments.length===1){for(;++u<i&&((e=n[u])==null||e!=e);)e=void 0;for(;++u<i;)(r=n[u])!=null&&e>r&&(e=r)}else{for(;++u<i&&((e=t.call(n,n[u],u))==null||e!=e);)e=void 0;for(;++u<i;)(r=t.call(n,n[u],u))!=null&&e>r&&(e=r)}return e},oa.max=function(n,t){var e,r,u=-1,i=n.length;if(arguments.length===1){for(;++u<i&&((e=n[u])==null||e!=e);)e=void 0;for(;++u<i;)(r=n[u])!=null&&r>e&&(e=r)}else{for(;++u<i&&((e=t.call(n,n[u],u))==null||e!=e);)e=void 0;for(;++u<i;)(r=t.call(n,n[u],u))!=null&&r>e&&(e=r)}return e},oa.extent=function(n,t){var e,r,u,i=-1,a=n.length;if(arguments.length===1){for(;++i<a&&((e=u=n[i])==null||e!=e);)e=u=void 0;for(;++i<a;)(r=n[i])!=null&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<a&&((e=u=t.call(n,n[i],i))==null||e!=e);)e=void 0;for(;++i<a;)(r=t.call(n,n[i],i))!=null&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},oa.sum=function(n,t){var e,r=0,u=n.length,i=-1;if(arguments.length===1)for(;++i<u;)isNaN(e=+n[i])||(r+=e);else for(;++i<u;)isNaN(e=+t.call(n,n[i],i))||(r+=e);return r},oa.mean=function(t,e){var r,u=t.length,i=0,a=-1,o=0;if(arguments.length===1)for(;++a<u;)n(r=t[a])&&(i+=(r-i)/++o);else for(;++a<u;)n(r=e.call(t,t[a],a))&&(i+=(r-i)/++o);return o?i:void 0},oa.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},oa.median=function(t,e){return arguments.length>1&&(t=t.map(e)),t=t.filter(n),t.length?oa.quantile(t.sort(oa.ascending),.5):void 0},oa.bisector=function(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n.call(t,t[i],i)<e?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;e<n.call(t,t[i],i)?u=i:r=i+1}return r}}};var ga=oa.bisector(function(n){return n});oa.bisectLeft=ga.left,oa.bisect=oa.bisectRight=ga.right,oa.shuffle=function(n){for(var t,e,r=n.length;r;)e=Math.random()*r--|0,t=n[r],n[r]=n[e],n[e]=t;return n},oa.permute=function(n,t){for(var e=[],r=-1,u=t.length;++r<u;)e[r]=n[t[r]];return e},oa.zip=function(){if(!(u=arguments.length))return[];for(var n=-1,e=oa.min(arguments,t),r=Array(e);++n<e;)for(var u,i=-1,a=r[n]=Array(u);++i<u;)a[i]=arguments[i][n];return r},oa.transpose=function(n){return oa.zip.apply(oa,n)},oa.keys=function(n){var t=[];for(var e in n)t.push(e);return t},oa.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},oa.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},oa.merge=function(n){return Array.prototype.concat.apply([],n)},oa.range=function(n,t,r){if(arguments.length<3&&(r=1,arguments.length<2&&(t=n,n=0)),1/0===(t-n)/r)throw Error("infinite range");var u,i=[],a=e(Math.abs(r)),o=-1;if(n*=a,t*=a,r*=a,0>r)for(;(u=n+r*++o)>t;)i.push(u/a);else for(;(u=n+r*++o)<t;)i.push(u/a);return i},oa.map=function(n){var t=new u;for(var e in n)t.set(e,n[e]);return t},r(u,{has:function(n){return pa+n in this},get:function(n){return this[pa+n]},set:function(n,t){return this[pa+n]=t},remove:function(n){return n=pa+n,n in this&&delete this[n]},keys:function(){var n=[];return this.forEach(function(t){n.push(t)}),n},values:function(){var n=[];return this.forEach(function(t,e){n.push(e)}),n},entries:function(){var n=[];return this.forEach(function(t,e){n.push({key:t,value:e})}),n},forEach:function(n){for(var t in this)t.charCodeAt(0)===da&&n.call(this,t.substring(1),this[t])}});var pa="\0",da=pa.charCodeAt(0);oa.nest=function(){function n(t,o,c){if(c>=a.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,g=-1,p=o.length,d=a[c++],m=new u;++g<p;)(h=m.get(l=d(f=o[g])))?h.push(f):m.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,c))}):(f={},s=function(e,r){f[e]=n(t,r,c)}),m.forEach(s),f}function t(n,e){if(e>=a.length)return n;var r=[],u=o[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,i={},a=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(oa.map,e,0),0)},i.key=function(n){return a.push(n),i},i.sortKeys=function(n){return o[a.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},oa.set=function(n){var t=new i;if(n)for(var e=0;e<n.length;e++)t.add(n[e]);return t},r(i,{has:function(n){return pa+n in this},add:function(n){return this[pa+n]=!0,n},remove:function(n){return n=pa+n,n in this&&delete this[n]},values:function(){var n=[];return this.forEach(function(t){n.push(t)}),n},forEach:function(n){for(var t in this)t.charCodeAt(0)===da&&n.call(this,t.substring(1))}}),oa.behavior={},oa.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=a(n,t,t[e]);return n},oa.dispatch=function(){for(var n=new o,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=c(n);return n},o.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.substring(e+1),n=n.substring(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(arguments.length===2){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},oa.event=null,oa.mouse=function(n){return h(n,f())};var ma=/WebKit/.test(la.navigator.userAgent)?-1:0,va=p;
try{va(ca.documentElement.childNodes)[0].nodeType}catch(ya){va=g}var Ma=[].__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]};oa.touches=function(n,t){return arguments.length<2&&(t=f().touches),t?va(t).map(function(t){var e=h(n,t);return e.identifier=t.identifier,e}):[]},oa.behavior.drag=function(){function n(){this.on("mousedown.drag",t).on("touchstart.drag",t)}function t(){function n(){var n=o.parentNode;return null!=s?oa.touches(n).filter(function(n){return n.identifier===s})[0]:oa.mouse(n)}function t(){if(!o.parentNode)return u();var t=n(),e=t[0]-h[0],r=t[1]-h[1];g|=e|r,h=t,l(),c({type:"drag",x:t[0]+a[0],y:t[1]+a[1],dx:e,dy:r})}function u(){c({type:"dragend"}),g&&(l(),oa.event.target===f&&p.on("click.drag",i,!0)),p.on(null!=s?"touchmove.drag-"+s:"mousemove.drag",null).on(null!=s?"touchend.drag-"+s:"mouseup.drag",null)}function i(){l(),p.on("click.drag",null)}var a,o=this,c=e.of(o,arguments),f=oa.event.target,s=oa.event.touches?oa.event.changedTouches[0].identifier:null,h=n(),g=0,p=oa.select(la).on(null!=s?"touchmove.drag-"+s:"mousemove.drag",t).on(null!=s?"touchend.drag-"+s:"mouseup.drag",u,!0);r?(a=r.apply(o,arguments),a=[a.x-h[0],a.y-h[1]]):a=[0,0],null==s&&l(),c({type:"dragstart"})}var e=s(n,"drag","dragstart","dragend"),r=null;return n.origin=function(t){return arguments.length?(r=t,n):r},oa.rebind(n,e,"on")};var xa=function(n,t){return t.querySelector(n)},ba=function(n,t){return t.querySelectorAll(n)},_a=ca.documentElement,wa=_a.matchesSelector||_a.webkitMatchesSelector||_a.mozMatchesSelector||_a.msMatchesSelector||_a.oMatchesSelector,Sa=function(n,t){return wa.call(n,t)};"function"==typeof Sizzle&&(xa=function(n,t){return Sizzle(n,t)[0]||null},ba=function(n,t){return Sizzle.uniqueSort(Sizzle(n,t))},Sa=Sizzle.matchesSelector);var Ea=[];oa.selection=function(){return Ta},oa.selection.prototype=Ea,Ea.select=function(n){var t,e,r,u,i=[];"function"!=typeof n&&(n=m(n));for(var a=-1,o=this.length;++a<o;){i.push(t=[]),t.parentNode=(r=this[a]).parentNode;for(var c=-1,l=r.length;++c<l;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return d(i)},Ea.selectAll=function(n){var t,e,r=[];"function"!=typeof n&&(n=v(n));for(var u=-1,i=this.length;++u<i;)for(var a=this[u],o=-1,c=a.length;++o<c;)(e=a[o])&&(r.push(t=va(n.call(e,e.__data__,o))),t.parentNode=e);return d(r)};var ka={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};oa.ns={prefix:ka,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.substring(0,t),n=n.substring(t+1)),ka.hasOwnProperty(e)?{space:ka[e],local:n}:n}},Ea.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=oa.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(y(t,n[t]));return this}return this.each(y(n,t))},oa.requote=function(n){return n.replace(Aa,"\\$&")};var Aa=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;Ea.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=n.trim().split(/^|\s+/g)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!x(n[u]).test(t))return!1;return!0}for(t in n)this.each(_(t,n[t]));return this}return this.each(_(n,t))},Ea.style=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t="");for(e in n)this.each(S(e,n[e],t));return this}if(2>r)return la.getComputedStyle(this.node(),null).getPropertyValue(n);e=""}return this.each(S(n,t,e))},Ea.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(E(t,n[t]));return this}return this.each(E(n,t))},Ea.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Ea.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Ea.append=function(n){function t(){return this.appendChild(ca.createElementNS(this.namespaceURI,n))}function e(){return this.appendChild(ca.createElementNS(n.space,n.local))}return n=oa.ns.qualify(n),this.select(n.local?e:t)},Ea.insert=function(n,t){function e(e,r){return this.insertBefore(ca.createElementNS(this.namespaceURI,n),t.call(this,e,r))}function r(e,r){return this.insertBefore(ca.createElementNS(n.space,n.local),t.call(this,e,r))}return n=oa.ns.qualify(n),"function"!=typeof t&&(t=m(t)),this.select(n.local?r:e)},Ea.remove=function(){return this.each(function(){var n=this.parentNode;n&&n.removeChild(this)})},Ea.data=function(n,t){function e(n,e){var r,i,a,o=n.length,s=e.length,h=Math.min(o,s),g=Array(s),p=Array(s),d=Array(o);if(t){var m,v=new u,y=new u,M=[];for(r=-1;++r<o;)m=t.call(i=n[r],i.__data__,r),v.has(m)?d[r]=i:v.set(m,i),M.push(m);for(r=-1;++r<s;)m=t.call(e,a=e[r],r),(i=v.get(m))?(g[r]=i,i.__data__=a):y.has(m)||(p[r]=k(a)),y.set(m,a),v.remove(m);for(r=-1;++r<o;)v.has(M[r])&&(d[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],a=e[r],i?(i.__data__=a,g[r]=i):p[r]=k(a);for(;s>r;++r)p[r]=k(e[r]);for(;o>r;++r)d[r]=n[r]}p.update=g,p.parentNode=g.parentNode=d.parentNode=n.parentNode,c.push(p),l.push(g),f.push(d)}var r,i,a=-1,o=this.length;if(!arguments.length){for(n=Array(o=(r=this[0]).length);++a<o;)(i=r[a])&&(n[a]=i.__data__);return n}var c=j([]),l=d([]),f=d([]);if("function"==typeof n)for(;++a<o;)e(r=this[a],n.call(r,r.parentNode.__data__,a));else for(;++a<o;)e(r=this[a],n);return l.enter=function(){return c},l.exit=function(){return f},l},Ea.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Ea.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=A(n));for(var i=0,a=this.length;a>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var o=0,c=e.length;c>o;o++)(r=e[o])&&n.call(r,r.__data__,o)&&t.push(r)}return d(u)},Ea.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},Ea.sort=function(n){n=q.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Ea.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(T(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(T(n,t,e))};var qa=oa.map({mouseenter:"mouseover",mouseleave:"mouseout"});qa.forEach(function(n){"on"+n in ca&&qa.remove(n)}),Ea.each=function(n){return D(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Ea.call=function(n){var t=va(arguments);return n.apply(t[0]=this,t),this},Ea.empty=function(){return!this.node()},Ea.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null};var Na=[];oa.selection.enter=j,oa.selection.enter.prototype=Na,Na.append=Ea.append,Na.insert=Ea.insert,Na.empty=Ea.empty,Na.node=Ea.node,Na.select=function(n){for(var t,e,r,u,i,a=[],o=-1,c=this.length;++o<c;){r=(u=this[o]).update,a.push(t=[]),t.parentNode=u.parentNode;for(var l=-1,f=u.length;++l<f;)(i=u[l])?(t.push(r[l]=e=n.call(u.parentNode,i.__data__,l)),e.__data__=i.__data__):t.push(null)}return d(a)},Ea.transition=function(){var n,t,e=ec||++ac,r=[],u=Object.create(oc);u.time=Date.now();for(var i=-1,a=this.length;++i<a;){r.push(n=[]);for(var o=this[i],c=-1,l=o.length;++c<l;)(t=o[c])&&Mi(t,c,e,u),n.push(t)}return mi(r,e)};var Ta=d([[ca]]);Ta[0].parentNode=_a,oa.select=function(n){return"string"==typeof n?Ta.select(n):d([[n]])},oa.selectAll=function(n){return"string"==typeof n?Ta.selectAll(n):d([va(n)])},oa.behavior.zoom=function(){function n(){this.on("mousedown.zoom",o).on("mousemove.zoom",f).on(Da+".zoom",c).on("dblclick.zoom",h).on("touchstart.zoom",g).on("touchmove.zoom",p).on("touchend.zoom",g)}function t(n){return[(n[0]-_[0])/w,(n[1]-_[1])/w]}function e(n){return[n[0]*w+_[0],n[1]*w+_[1]]}function r(n){w=Math.max(S[0],Math.min(S[1],n))}function u(n,t){t=e(t),_[0]+=n[0]-t[0],_[1]+=n[1]-t[1]}function i(){y&&y.domain(v.range().map(function(n){return(n-_[0])/w}).map(v.invert)),x&&x.domain(M.range().map(function(n){return(n-_[1])/w}).map(M.invert))}function a(n){i(),oa.event.preventDefault(),n({type:"zoom",scale:w,translate:_})}function o(){function n(){f=1,u(oa.mouse(i),h),a(o)}function e(){f&&l(),s.on("mousemove.zoom",null).on("mouseup.zoom",null),f&&oa.event.target===c&&s.on("click.zoom",r,!0)}function r(){l(),s.on("click.zoom",null)}var i=this,o=E.of(i,arguments),c=oa.event.target,f=0,s=oa.select(la).on("mousemove.zoom",n).on("mouseup.zoom",e),h=t(oa.mouse(i));la.focus(),l()}function c(){d||(d=t(oa.mouse(this))),r(Math.pow(2,Ca()*.002)*w),u(oa.mouse(this),d),a(E.of(this,arguments))}function f(){d=null}function h(){var n=oa.mouse(this),e=t(n),i=Math.log(w)/Math.LN2;r(Math.pow(2,oa.event.shiftKey?Math.ceil(i)-1:Math.floor(i)+1)),u(n,e),a(E.of(this,arguments))}function g(){var n=oa.touches(this),e=Date.now();if(m=w,d={},n.forEach(function(n){d[n.identifier]=t(n)}),l(),n.length===1){if(500>e-b){var i=n[0],o=t(n[0]);r(2*w),u(i,o),a(E.of(this,arguments))}b=e}}function p(){var n=oa.touches(this),t=n[0],e=d[t.identifier];if(i=n[1]){var i,o=d[i.identifier];t=[(t[0]+i[0])/2,(t[1]+i[1])/2],e=[(e[0]+o[0])/2,(e[1]+o[1])/2],r(oa.event.scale*m)}u(t,e),b=null,a(E.of(this,arguments))}var d,m,v,y,M,x,b,_=[0,0],w=1,S=za,E=s(n,"zoom");return n.translate=function(t){return arguments.length?(_=t.map(Number),i(),n):_},n.scale=function(t){return arguments.length?(w=+t,i(),n):w},n.scaleExtent=function(t){return arguments.length?(S=null==t?za:t.map(Number),n):S},n.x=function(t){return arguments.length?(y=t,v=t.copy(),_=[0,0],w=1,n):y},n.y=function(t){return arguments.length?(x=t,M=t.copy(),_=[0,0],w=1,n):x},oa.rebind(n,E,"on")};var Ca,za=[0,1/0],Da="onwheel"in ca?(Ca=function(){return-oa.event.deltaY*(oa.event.deltaMode?120:1)},"wheel"):"onmousewheel"in ca?(Ca=function(){return oa.event.wheelDelta},"mousewheel"):(Ca=function(){return-oa.event.detail},"MozMousePixelScroll");L.prototype.toString=function(){return this.rgb()+""},oa.hsl=function(n,t,e){return arguments.length===1?n instanceof H?F(n.h,n.s,n.l):ut(""+n,it,F):F(+n,+t,+e)};var ja=H.prototype=new L;ja.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),F(this.h,this.s,this.l/n)},ja.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),F(this.h,this.s,n*this.l)},ja.rgb=function(){return P(this.h,this.s,this.l)};var La=Math.PI,Fa=1e-6,Ha=La/180,Pa=180/La;oa.hcl=function(n,t,e){return arguments.length===1?n instanceof Z?X(n.h,n.c,n.l):n instanceof J?K(n.l,n.a,n.b):K((n=at((n=oa.rgb(n)).r,n.g,n.b)).l,n.a,n.b):X(+n,+t,+e)};var Ra=Z.prototype=new L;Ra.brighter=function(n){return X(this.h,this.c,Math.min(100,this.l+Oa*(arguments.length?n:1)))},Ra.darker=function(n){return X(this.h,this.c,Math.max(0,this.l-Oa*(arguments.length?n:1)))},Ra.rgb=function(){return B(this.h,this.c,this.l).rgb()},oa.lab=function(n,t,e){return arguments.length===1?n instanceof J?$(n.l,n.a,n.b):n instanceof Z?B(n.l,n.c,n.h):at((n=oa.rgb(n)).r,n.g,n.b):$(+n,+t,+e)};var Oa=18,Ya=.95047,Ua=1,Ia=1.08883,Va=J.prototype=new L;Va.brighter=function(n){return $(Math.min(100,this.l+Oa*(arguments.length?n:1)),this.a,this.b)},Va.darker=function(n){return $(Math.max(0,this.l-Oa*(arguments.length?n:1)),this.a,this.b)},Va.rgb=function(){return G(this.l,this.a,this.b)},oa.rgb=function(n,t,e){return arguments.length===1?n instanceof et?tt(n.r,n.g,n.b):ut(""+n,tt,P):tt(~~n,~~t,~~e)};var Xa=et.prototype=new L;Xa.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),tt(Math.min(255,Math.floor(t/n)),Math.min(255,Math.floor(e/n)),Math.min(255,Math.floor(r/n)))):tt(u,u,u)},Xa.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),tt(Math.floor(n*this.r),Math.floor(n*this.g),Math.floor(n*this.b))},Xa.hsl=function(){return it(this.r,this.g,this.b)},Xa.toString=function(){return"#"+rt(this.r)+rt(this.g)+rt(this.b)};var Za=oa.map({aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"});Za.forEach(function(n,t){Za.set(n,ut(t,tt,P))}),oa.functor=lt,oa.xhr=function(n,t,e){function r(){var n=c.status;!n&&c.responseText||n>=200&&300>n||304===n?i.load.call(u,o.call(u,c)):i.error.call(u,c)}var u={},i=oa.dispatch("progress","load","error"),a={},o=ft,c=new(la.XDomainRequest&&/^(http(s)?:)?\/\//.test(n)?XDomainRequest:XMLHttpRequest);return"onload"in c?c.onload=c.onerror=r:c.onreadystatechange=function(){c.readyState>3&&r()},c.onprogress=function(n){var t=oa.event;oa.event=n;try{i.progress.call(u,c)}finally{oa.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.response=function(n){return o=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(va(arguments)))}}),u.send=function(e,r,i){if(arguments.length===2&&"function"==typeof r&&(i=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var o in a)c.setRequestHeader(o,a[o]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),c.send(null==r?null:r),u},u.abort=function(){return c.abort(),u},oa.rebind(u,i,"on"),arguments.length===2&&"function"==typeof t&&(e=t,t=null),null==e?u:u.get(st(e))},oa.csv=ht(",","text/csv"),oa.tsv=ht("	","text/tab-separated-values");var Ba,$a,Ja=0,Ga={},Ka=null;oa.timer=function(n,t,e){if(arguments.length<3){if(arguments.length<2)t=0;else if(!isFinite(t))return;e=Date.now()}var r=Ga[n.id];r&&r.callback===n?(r.then=e,r.delay=t):Ga[n.id=++Ja]=Ka={callback:n,then:e,delay:t,next:Ka},Ba||($a=clearTimeout($a),Ba=1,Wa(gt))},oa.timer.flush=function(){for(var n,t=Date.now(),e=Ka;e;)n=t-e.then,e.delay||(e.flush=e.callback(n)),e=e.next;pt()};var Wa=la.requestAnimationFrame||la.webkitRequestAnimationFrame||la.mozRequestAnimationFrame||la.oRequestAnimationFrame||la.msRequestAnimationFrame||function(n){setTimeout(n,17)},Qa=".",no=",",to=[3,3],eo=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"].map(dt);oa.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=oa.round(n,mt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,Math.floor((0>=e?e+1:e-1)/3)*3))),eo[8+e/3]},oa.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)},oa.format=function(n){var t=ro.exec(n),e=t[1]||" ",r=t[2]||">",u=t[3]||"",i=t[4]||"",a=t[5],o=+t[6],c=t[7],l=t[8],f=t[9],s=1,h="",g=!1;switch(l&&(l=+l.substring(1)),(a||"0"===e&&"="===r)&&(a=e="0",r="=",c&&(o-=Math.floor((o-1)/4))),f){case"n":c=!0,f="g";break;case"%":s=100,h="%",f="f";break;case"p":s=100,h="%",f="r";break;case"b":case"o":case"x":case"X":i&&(i="0"+f.toLowerCase());case"c":case"d":g=!0,l=0;break;case"s":s=-1,f="r"}"#"===i&&(i=""),"r"!=f||l||(f="g"),null!=l&&("g"==f?l=Math.max(1,Math.min(21,l)):("e"==f||"f"==f)&&(l=Math.max(0,Math.min(20,l)))),f=uo.get(f)||vt;var p=a&&c;return function(n){if(g&&n%1)return"";var t=0>n||0===n&&0>1/n?(n=-n,"-"):u;if(0>s){var d=oa.formatPrefix(n,l);n=d.scale(n),h=d.symbol}else n*=s;n=f(n,l),!a&&c&&(n=io(n));var m=i.length+n.length+(p?0:t.length),v=o>m?Array(m=o-m+1).join(e):"";return p&&(n=io(v+n)),Qa&&n.replace(".",Qa),t+=i,("<"===r?t+n+v:">"===r?v+t+n:"^"===r?v.substring(0,m>>=1)+t+n+v.substring(m):t+(p?n:v+n))+h}};var ro=/(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,uo=oa.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=oa.round(n,mt(n,t))).toFixed(Math.max(0,Math.min(20,mt(n*(1+1e-15),t))))}}),io=ft;if(to){var ao=to.length;io=function(n){for(var t=n.lastIndexOf("."),e=t>=0?"."+n.substring(t+1):(t=n.length,""),r=[],u=0,i=to[0];t>0&&i>0;)r.push(n.substring(t-=i,t+i)),i=to[u=(u+1)%ao];return r.reverse().join(no||"")+e}}oa.geo={},oa.geo.stream=function(n,t){oo.hasOwnProperty(n.type)?oo[n.type](n,t):yt(n,t)};var oo={Feature:function(n,t){yt(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)yt(e[r].geometry,t)}},co={Sphere:function(n,t){t.sphere()},Point:function(n,t){var e=n.coordinates;t.point(e[0],e[1])},MultiPoint:function(n,t){for(var e,r=n.coordinates,u=-1,i=r.length;++u<i;)e=r[u],t.point(e[0],e[1])},LineString:function(n,t){Mt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)Mt(e[r],t,0)},Polygon:function(n,t){xt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)xt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)yt(e[r],t)}};oa.geo.area=function(n){return lo=0,oa.geo.stream(n,ho),lo};var lo,fo,so,ho={sphere:function(){lo+=4*La},point:N,lineStart:N,lineEnd:N,polygonStart:function(){fo=1,so=0,ho.lineStart=bt},polygonEnd:function(){var n=2*Math.atan2(so,fo);lo+=0>n?4*La+n:n,ho.lineStart=ho.lineEnd=ho.point=N}};oa.geo.bounds=_t(ft),oa.geo.centroid=function(n){go=po=mo=vo=yo=0,oa.geo.stream(n,Mo);var t;return po&&Math.abs(t=Math.sqrt(mo*mo+vo*vo+yo*yo))>Fa?[Math.atan2(vo,mo)*Pa,Math.asin(Math.max(-1,Math.min(1,yo/t)))*Pa]:void 0};var go,po,mo,vo,yo,Mo={sphere:function(){2>go&&(go=2,po=mo=vo=yo=0)},point:wt,lineStart:Et,lineEnd:kt,polygonStart:function(){2>go&&(go=2,po=mo=vo=yo=0),Mo.lineStart=St},polygonEnd:function(){Mo.lineStart=Et}},xo=Pt(Dt,It,Xt),bo=1e9;oa.geo.projection=Kt,oa.geo.projectionMutator=Wt,(oa.geo.equirectangular=function(){return Kt(ne)}).raw=ne.invert=ne,oa.geo.rotation=function(n){function t(t){return t=n(t[0]*Ha,t[1]*Ha),t[0]*=Pa,t[1]*=Pa,t}return n=te(n[0]%360*Ha,n[1]*Ha,n.length>2?n[2]*Ha:0),t.invert=function(t){return t=n.invert(t[0]*Ha,t[1]*Ha),t[0]*=Pa,t[1]*=Pa,t},t},oa.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=te(-n[0]*Ha,-n[1]*Ha,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=Pa,n[1]*=Pa}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ie((t=+r)*Ha,u*Ha),n):t},n.precision=function(r){return arguments.length?(e=ie(t*Ha,(u=+r)*Ha),n):u},n.angle(90)},oa.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Ha,u=n[1]*Ha,i=t[1]*Ha,a=Math.sin(r),o=Math.cos(r),c=Math.sin(u),l=Math.cos(u),f=Math.sin(i),s=Math.cos(i);return Math.atan2(Math.sqrt((e=s*a)*e+(e=l*f-c*s*o)*e),c*f+l*s*o)},oa.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return oa.range(Math.ceil(i/m)*m,u,m).map(h).concat(oa.range(Math.ceil(l/v)*v,c,v).map(g)).concat(oa.range(Math.ceil(r/p)*p,e,p).filter(function(n){return Math.abs(n%m)>Fa}).map(f)).concat(oa.range(Math.ceil(o/d)*d,a,d).filter(function(n){return Math.abs(n%v)>Fa}).map(s))}var e,r,u,i,a,o,c,l,f,s,h,g,p=10,d=p,m=90,v=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(l).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],l=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),l>c&&(t=l,l=c,c=t),n.precision(y)):[[i,l],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],o=+t[0][1],a=+t[1][1],r>e&&(t=r,r=e,e=t),o>a&&(t=o,o=a,a=t),n.precision(y)):[[r,o],[e,a]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(m=+t[0],v=+t[1],n):[m,v]},n.minorStep=function(t){return arguments.length?(p=+t[0],d=+t[1],n):[p,d]},n.precision=function(t){return arguments.length?(y=+t,f=oe(o,a,90),s=ce(r,e,y),h=oe(l,c,90),g=ce(i,u,y),n):y},n.majorExtent([[-180,-90+Fa],[180,90-Fa]]).minorExtent([[-180,-80-Fa],[180,80+Fa]])},oa.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=le,u=fe;return n.distance=function(){return oa.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},oa.geo.interpolate=function(n,t){return se(n[0]*Ha,n[1]*Ha,t[0]*Ha,t[1]*Ha)},oa.geo.length=function(n){return _o=0,oa.geo.stream(n,wo),_o};var _o,wo={sphere:N,point:N,lineStart:he,lineEnd:N,polygonStart:N,polygonEnd:N};(oa.geo.conicEqualArea=function(){return ge(pe)}).raw=pe,oa.geo.albersUsa=function(){function n(n){return t(n)(n)}function t(n){var t=n[0],e=n[1];return e>50?a:-140>t?o:21>e?c:i}var e,r,u,i=oa.geo.conicEqualArea().rotate([98,0]).center([0,38]).parallels([29.5,45.5]),a=oa.geo.conicEqualArea().rotate([160,0]).center([0,60]).parallels([55,65]),o=oa.geo.conicEqualArea().rotate([160,0]).center([0,20]).parallels([8,18]),c=oa.geo.conicEqualArea().rotate([60,0]).center([0,10]).parallels([8,18]);return n.invert=function(n){return e(n)||r(n)||u(n)||i.invert(n)},n.scale=function(t){return arguments.length?(i.scale(t),a.scale(.6*t),o.scale(t),c.scale(1.5*t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var l=i.scale(),f=t[0],s=t[1];return i.translate(t),a.translate([f-.4*l,s+.17*l]),o.translate([f-.19*l,s+.2*l]),c.translate([f+.58*l,s+.43*l]),e=de(a,[[-180,50],[-130,72]]),r=de(o,[[-164,18],[-154,24]]),u=de(c,[[-67.5,17.5],[-65,19]]),n},n.scale(1e3)};var So,Eo,ko={point:N,lineStart:N,lineEnd:N,polygonStart:function(){Eo=0,ko.lineStart=me},polygonEnd:function(){ko.lineStart=ko.lineEnd=ko.point=N,So+=Math.abs(Eo/2)}},Ao={point:ye,lineStart:Me,lineEnd:xe,polygonStart:function(){Ao.lineStart=be},polygonEnd:function(){Ao.point=ye,Ao.lineStart=Me,Ao.lineEnd=xe}};oa.geo.path=function(){function n(n){return n&&oa.geo.stream(n,r(u.pointRadius("function"==typeof i?+i.apply(this,arguments):i))),u.result()}var t,e,r,u,i=4.5;return n.area=function(n){return So=0,oa.geo.stream(n,r(ko)),So},n.centroid=function(n){return go=mo=vo=yo=0,oa.geo.stream(n,r(Ao)),yo?[mo/yo,vo/yo]:void 0},n.bounds=function(n){return _t(r)(n)},n.projection=function(e){return arguments.length?(r=(t=e)?e.stream||Se(e):ft,n):t},n.context=function(t){return arguments.length?(u=(e=t)==null?new ve:new _e(t),n):e},n.pointRadius=function(t){return arguments.length?(i="function"==typeof t?t:+t,n):i},n.projection(oa.geo.albersUsa()).context(null)},oa.geo.albers=function(){return oa.geo.conicEqualArea().parallels([29.5,45.5]).rotate([98,0]).center([0,38]).scale(1e3)};var qo=Ee(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(oa.geo.azimuthalEqualArea=function(){return Kt(qo)}).raw=qo;var No=Ee(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},ft);(oa.geo.azimuthalEquidistant=function(){return Kt(No)}).raw=No,(oa.geo.conicConformal=function(){return ge(ke)}).raw=ke,(oa.geo.conicEquidistant=function(){return ge(Ae)}).raw=Ae;var To=Ee(function(n){return 1/n},Math.atan);(oa.geo.gnomonic=function(){return Kt(To)}).raw=To,qe.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-La/2]},(oa.geo.mercator=function(){return Ne(qe)}).raw=qe;var Co=Ee(function(){return 1},Math.asin);(oa.geo.orthographic=function(){return Kt(Co)}).raw=Co;var zo=Ee(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(oa.geo.stereographic=function(){return Kt(zo)}).raw=zo,Te.invert=function(n,t){return[Math.atan2(U(n),Math.cos(t)),Y(Math.sin(t)/I(n))]},(oa.geo.transverseMercator=function(){return Ne(Te)}).raw=Te,oa.geom={},oa.svg={},oa.svg.line=function(){return Ce(ft)};var Do=oa.map({linear:je,"linear-closed":Le,"step-before":Fe,"step-after":He,basis:Ie,"basis-open":Ve,"basis-closed":Xe,bundle:Ze,cardinal:Oe,"cardinal-open":Pe,"cardinal-closed":Re,monotone:We});Do.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var jo=[0,2/3,1/3,0],Lo=[0,1/3,2/3,0],Fo=[0,1/6,2/3,1/6];oa.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u,i,a,o,c,l,f,s,h,g,p,d=lt(e),m=lt(r),v=n.length,y=v-1,M=[],x=[],b=0;if(d===ze&&r===De)t=n;else for(i=0,t=[];v>i;++i)t.push([+d.call(this,u=n[i],i),+m.call(this,u,i)]);for(i=1;v>i;++i)t[i][1]<t[b][1]?b=i:t[i][1]==t[b][1]&&(b=t[i][0]<t[b][0]?i:b);for(i=0;v>i;++i)i!==b&&(c=t[i][1]-t[b][1],o=t[i][0]-t[b][0],M.push({angle:Math.atan2(c,o),index:i}));for(M.sort(function(n,t){return n.angle-t.angle}),g=M[0].angle,h=M[0].index,s=0,i=1;y>i;++i)a=M[i].index,g==M[i].angle?(o=t[h][0]-t[b][0],c=t[h][1]-t[b][1],l=t[a][0]-t[b][0],f=t[a][1]-t[b][1],o*o+c*c>=l*l+f*f?M[i].index=-1:(M[s].index=-1,g=M[i].angle,s=i,h=a)):(g=M[i].angle,s=i,h=a);for(x.push(b),i=0,a=0;2>i;++a)M[a].index!==-1&&(x.push(M[a].index),i++);for(p=x.length;y>a;++a)if(M[a].index!==-1){for(;!Qe(x[p-2],x[p-1],M[a].index,t);)--p;x[p++]=M[a].index}var _=[];for(i=0;p>i;++i)_.push(n[x[i]]);return _}var e=ze,r=De;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},oa.geom.polygon=function(n){return n.area=function(){for(var t=0,e=n.length,r=n[e-1][1]*n[0][0]-n[e-1][0]*n[0][1];++t<e;)r+=n[t-1][1]*n[t][0]-n[t-1][0]*n[t][1];return.5*r},n.centroid=function(t){var e,r,u=-1,i=n.length,a=0,o=0,c=n[i-1];for(arguments.length||(t=-1/(6*n.area()));++u<i;)e=c,c=n[u],r=e[0]*c[1]-c[0]*e[1],a+=(e[0]+c[0])*r,o+=(e[1]+c[1])*r;return[a*t,o*t]},n.clip=function(t){for(var e,r,u,i,a,o,c=-1,l=n.length,f=n[l-1];++c<l;){for(e=t.slice(),t.length=0,i=n[c],a=e[(u=e.length)-1],r=-1;++r<u;)o=e[r],nr(o,f,i)?(nr(a,f,i)||t.push(tr(a,o,f,i)),t.push(o)):nr(a,f,i)&&t.push(tr(a,o,f,i)),a=o;f=i}return t},n},oa.geom.delaunay=function(n){var t=n.map(function(){return[]}),e=[];return er(n,function(e){t[e.region.l.index].push(n[e.region.r.index])}),t.forEach(function(t,r){var u=n[r],i=u[0],a=u[1];t.forEach(function(n){n.angle=Math.atan2(n[0]-i,n[1]-a)}),t.sort(function(n,t){return n.angle-t.angle});for(var o=0,c=t.length-1;c>o;o++)e.push([u,t[o],t[o+1]])}),e},oa.geom.voronoi=function(n){function t(n){var t,r,a,o=n.map(function(){return[]}),c=lt(u),l=lt(i),f=n.length,s=1e6;if(c===ze&&l===De)t=n;else for(t=[],a=0;f>a;++a)t.push([+c.call(this,r=n[a],a),+l.call(this,r,a)]);if(er(t,function(n){var t,e,r,u,i,a;n.a===1&&n.b>=0?(t=n.ep.r,e=n.ep.l):(t=n.ep.l,e=n.ep.r),n.a===1?(i=t?t.y:-s,r=n.c-n.b*i,a=e?e.y:s,u=n.c-n.b*a):(r=t?t.x:-s,i=n.c-n.a*r,u=e?e.x:s,a=n.c-n.a*u);var c=[r,i],l=[u,a];o[n.region.l.index].push(c,l),o[n.region.r.index].push(c,l)}),o=o.map(function(n,e){var r=t[e][0],u=t[e][1],i=n.map(function(n){return Math.atan2(n[0]-r,n[1]-u)}),a=oa.range(n.length).sort(function(n,t){return i[n]-i[t]});return a.filter(function(n,t){return!t||i[n]-i[a[t-1]]>Fa}).map(function(t){return n[t]})}),o.forEach(function(n,e){var r=n.length;if(!r)return n.push([-s,-s],[-s,s],[s,s],[s,-s]);if(!(r>2)){var u=t[e],i=n[0],a=n[1],o=u[0],c=u[1],l=i[0],f=i[1],h=a[0],g=a[1],p=Math.abs(h-l),d=g-f;if(Math.abs(d)<Fa){var m=f>c?-s:s;n.push([-s,m],[s,m])}else if(Fa>p){var v=l>o?-s:s;n.push([v,-s],[v,s])}else{var m=(l-o)*(g-f)>(h-l)*(f-c)?s:-s,y=Math.abs(d)-p;Math.abs(y)<Fa?n.push([0>d?m:-m,m]):(y>0&&(m*=-1),n.push([-s,m],[s,m]))}}}),e)for(a=0;f>a;++a)e(o[a]);for(a=0;f>a;++a)o[a].point=n[a];return o}var e,r=null,u=ze,i=De;return arguments.length?t(n):(t.x=function(n){return arguments.length?(u=n,t):u},t.y=function(n){return arguments.length?(i=n,t):i},t.size=function(n){return arguments.length?(null==n?e=null:(r=[+n[0],+n[1]],e=oa.geom.polygon([[0,0],[0,r[1]],r,[r[0],0]]).clip),t):r},t.links=function(n){var t,e,r,a=n.map(function(){return[]}),o=[],c=lt(u),l=lt(i),f=n.length;if(c===ze&&l===De)t=n;else for(r=0;f>r;++r)t.push([+c.call(this,e=n[r],r),+l.call(this,e,r)]);return er(t,function(t){var e=t.region.l.index,r=t.region.r.index;a[e][r]||(a[e][r]=a[r][e]=!0,o.push({source:n[e],target:n[r]}))}),o},t.triangles=function(n){if(u===ze&&i===De)return oa.geom.delaunay(n);var t,e,r,a,o,c=lt(u),l=lt(i);for(a=0,t=[],o=n.length;o>a;++a)e=[+c.call(this,r=n[a],a),+l.call(this,r,a)],e.data=r,t.push(e);return oa.geom.delaunay(t).map(function(n){return n.map(function(n){return n.data})})},t)};var Ho={l:"r",r:"l"};oa.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,a,o){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,f=n.y;
if(null!=c)if(Math.abs(c-e)+Math.abs(f-r)<.01)l(n,t,e,r,u,i,a,o);else{var s=n.point;n.x=n.y=n.point=null,l(n,s,c,f,u,i,a,o),l(n,t,e,r,u,i,a,o)}else n.x=e,n.y=r,n.point=t}else l(n,t,e,r,u,i,a,o)}function l(n,t,e,r,u,a,o,c){var l=.5*(u+o),f=.5*(a+c),s=e>=l,h=r>=f,g=(h<<1)+s;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=ir()),s?u=l:o=l,h?a=f:c=f,i(n,t,e,r,u,a,o,c)}var f,s,h,g,p,d,m,v,y,M=lt(o),x=lt(c);if(null!=t)d=t,m=e,v=r,y=u;else if(v=y=-(d=m=1/0),s=[],h=[],p=n.length,a)for(g=0;p>g;++g)f=n[g],f.x<d&&(d=f.x),f.y<m&&(m=f.y),f.x>v&&(v=f.x),f.y>y&&(y=f.y),s.push(f.x),h.push(f.y);else for(g=0;p>g;++g){var b=+M(f=n[g],g),_=+x(f,g);d>b&&(d=b),m>_&&(m=_),b>v&&(v=b),_>y&&(y=_),s.push(b),h.push(_)}var w=v-d,S=y-m;w>S?y=m+w:v=d+S;var E=ir();if(E.add=function(n){i(E,n,+M(n,++g),+x(n,g),d,m,v,y)},E.visit=function(n){ar(n,E,d,m,v,y)},g=-1,null==t){for(;++g<p;)i(E,n[g],s[g],h[g],d,m,v,y);--g}else n.forEach(E.add);return s=h=n=f=null,E}var a,o=ze,c=De;return(a=arguments.length)?(o=rr,c=ur,3===a&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(o=n,i):o},i.y=function(n){return arguments.length?(c=n,i):c},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r,u]},i)},oa.interpolateRgb=or,oa.transform=function(n){var t=ca.createElementNS(oa.ns.prefix.svg,"g");return(oa.transform=function(n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate();return new cr(e?e.matrix:Po)})(n)},cr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var Po={a:1,b:0,c:0,d:1,e:0,f:0};oa.interpolateNumber=hr,oa.interpolateTransform=gr,oa.interpolateObject=pr,oa.interpolateString=dr;var Ro=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;oa.interpolate=mr,oa.interpolators=[pr,function(n,t){return Array.isArray(t)&&yr(n,t)},function(n,t){return("string"==typeof n||"string"==typeof t)&&dr(n+"",t+"")},function(n,t){return("string"==typeof t?Za.has(t)||/^(#|rgb\(|hsl\()/.test(t):t instanceof L)&&or(n,t)},function(n,t){return!isNaN(n=+n)&&!isNaN(t=+t)&&hr(n,t)}],oa.interpolateArray=yr;var Oo=function(){return ft},Yo=oa.map({linear:Oo,poly:Er,quad:function(){return _r},cubic:function(){return wr},sin:function(){return kr},exp:function(){return Ar},circle:function(){return qr},elastic:Nr,back:Tr,bounce:function(){return Cr}}),Uo=oa.map({"in":ft,out:xr,"in-out":br,"out-in":function(n){return br(xr(n))}});oa.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.substring(0,t):n,r=t>=0?n.substring(t+1):"in";return e=Yo.get(e)||Oo,r=Uo.get(r)||ft,Mr(r(e.apply(null,Array.prototype.slice.call(arguments,1))))},oa.interpolateHcl=zr,oa.interpolateHsl=Dr,oa.interpolateLab=jr,oa.interpolateRound=Lr,oa.layout={},oa.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Pr(n[e]));return t}},oa.layout.chord=function(){function n(){var n,l,s,h,g,p={},d=[],m=oa.range(i),v=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(l=0,g=-1;++g<i;)l+=u[h][g];d.push(l),v.push(oa.range(i)),n+=l}for(a&&m.sort(function(n,t){return a(d[n],d[t])}),o&&v.forEach(function(n,t){n.sort(function(n,e){return o(u[t][n],u[t][e])})}),n=(2*La-f*i)/n,l=0,h=-1;++h<i;){for(s=l,g=-1;++g<i;){var y=m[h],M=v[y][g],x=u[y][M],b=l,_=l+=x*n;p[y+"-"+M]={index:y,subindex:M,startAngle:b,endAngle:_,value:x}}r[y]={index:y,startAngle:s,endAngle:l,value:(l-s)/n},l+=f}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,a,o,c,l={},f=0;return l.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,l):u},l.padding=function(n){return arguments.length?(f=n,e=r=null,l):f},l.sortGroups=function(n){return arguments.length?(a=n,e=r=null,l):a},l.sortSubgroups=function(n){return arguments.length?(o=n,e=null,l):o},l.sortChords=function(n){return arguments.length?(c=n,e&&t(),l):c},l.chords=function(){return e||n(),e},l.groups=function(){return r||n(),r},l},oa.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,a=t.cy-n.y,o=1/Math.sqrt(i*i+a*a);if(d>(u-e)*o){var c=t.charge*o*o;return n.px-=i*c,n.py-=a*c,!0}if(t.point&&isFinite(o)){var c=t.pointCharge*o*o;n.px-=i*c,n.py-=a*c}}return!t.charge}}function t(n){n.px=oa.event.x,n.py=oa.event.y,o.resume()}var e,r,u,i,a,o={},c=oa.dispatch("start","tick","end"),l=[1,1],f=.9,s=Io,h=Vo,g=-30,p=.1,d=.8,m=[],v=[];return o.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,o,s,h,d,y,M,x,b=m.length,_=v.length;for(e=0;_>e;++e)o=v[e],s=o.source,h=o.target,M=h.x-s.x,x=h.y-s.y,(d=M*M+x*x)&&(d=r*i[e]*((d=Math.sqrt(d))-u[e])/d,M*=d,x*=d,h.x-=M*(y=s.weight/(h.weight+s.weight)),h.y-=x*y,s.x+=M*(y=1-y),s.y+=x*y);if((y=r*p)&&(M=l[0]/2,x=l[1]/2,e=-1,y))for(;++e<b;)o=m[e],o.x+=(M-o.x)*y,o.y+=(x-o.y)*y;if(g)for(Xr(t=oa.geom.quadtree(m),r,a),e=-1;++e<b;)(o=m[e]).fixed||t.visit(n(o));for(e=-1;++e<b;)o=m[e],o.fixed?(o.x=o.px,o.y=o.py):(o.x-=(o.px-(o.px=o.x))*f,o.y-=(o.py-(o.py=o.y))*f);c.tick({type:"tick",alpha:r})},o.nodes=function(n){return arguments.length?(m=n,o):m},o.links=function(n){return arguments.length?(v=n,o):v},o.size=function(n){return arguments.length?(l=n,o):l},o.linkDistance=function(n){return arguments.length?(s="function"==typeof n?n:+n,o):s},o.distance=o.linkDistance,o.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,o):h},o.friction=function(n){return arguments.length?(f=+n,o):f},o.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,o):g},o.gravity=function(n){return arguments.length?(p=+n,o):p},o.theta=function(n){return arguments.length?(d=+n,o):d},o.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),oa.timer(o.tick)),o):r},o.start=function(){function n(n,r){for(var u,i=t(e),a=-1,o=i.length;++a<o;)if(!isNaN(u=i[a][n]))return u;return Math.random()*r}function t(){if(!c){for(c=[],r=0;p>r;++r)c[r]=[];for(r=0;d>r;++r){var n=v[r];c[n.source.index].push(n.target),c[n.target.index].push(n.source)}}return c[e]}var e,r,c,f,p=m.length,d=v.length,y=l[0],M=l[1];for(e=0;p>e;++e)(f=m[e]).index=e,f.weight=0;for(e=0;d>e;++e)f=v[e],typeof f.source=="number"&&(f.source=m[f.source]),typeof f.target=="number"&&(f.target=m[f.target]),++f.source.weight,++f.target.weight;for(e=0;p>e;++e)f=m[e],isNaN(f.x)&&(f.x=n("x",y)),isNaN(f.y)&&(f.y=n("y",M)),isNaN(f.px)&&(f.px=f.x),isNaN(f.py)&&(f.py=f.y);if(u=[],"function"==typeof s)for(e=0;d>e;++e)u[e]=+s.call(this,v[e],e);else for(e=0;d>e;++e)u[e]=s;if(i=[],"function"==typeof h)for(e=0;d>e;++e)i[e]=+h.call(this,v[e],e);else for(e=0;d>e;++e)i[e]=h;if(a=[],"function"==typeof g)for(e=0;p>e;++e)a[e]=+g.call(this,m[e],e);else for(e=0;p>e;++e)a[e]=g;return o.resume()},o.resume=function(){return o.alpha(.1)},o.stop=function(){return o.alpha(0)},o.drag=function(){return e||(e=oa.behavior.drag().origin(ft).on("dragstart.force",Yr).on("drag.force",t).on("dragend.force",Ur)),arguments.length?(this.on("mouseover.force",Ir).on("mouseout.force",Vr).call(e),void 0):e},oa.rebind(o,c,"on")};var Io=20,Vo=1;oa.layout.hierarchy=function(){function n(t,a,o){var c=u.call(e,t,a);if(t.depth=a,o.push(t),c&&(l=c.length)){for(var l,f,s=-1,h=t.children=[],g=0,p=a+1;++s<l;)f=n(c[s],p,o),f.parent=t,h.push(f),g+=f.value;r&&h.sort(r),i&&(t.value=g)}else i&&(t.value=+i.call(e,t,a)||0);return t}function t(n,r){var u=n.children,a=0;if(u&&(o=u.length))for(var o,c=-1,l=r+1;++c<o;)a+=t(u[c],l);else i&&(a=+i.call(e,n,r)||0);return i&&(n.value=a),a}function e(t){var e=[];return n(t,0,e),e}var r=Jr,u=Br,i=$r;return e.sort=function(n){return arguments.length?(r=n,e):r},e.children=function(n){return arguments.length?(u=n,e):u},e.value=function(n){return arguments.length?(i=n,e):i},e.revalue=function(n){return t(n,0),n},e},oa.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(a=i.length)){var a,o,c,l=-1;for(r=t.value?r/t.value:0;++l<a;)n(o=i[l],e,c=o.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var a=r.call(this,e,i);return n(a[0],0,u[0],u[1]/t(a[0])),a}var r=oa.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Zr(e,r)},oa.layout.pie=function(){function n(i){var a=i.map(function(e,r){return+t.call(n,e,r)}),o=+("function"==typeof r?r.apply(this,arguments):r),c=(("function"==typeof u?u.apply(this,arguments):u)-o)/oa.sum(a),l=oa.range(i.length);null!=e&&l.sort(e===Xo?function(n,t){return a[t]-a[n]}:function(n,t){return e(i[n],i[t])});var f=[];return l.forEach(function(n){var t;f[n]={data:i[n],value:t=a[n],startAngle:o,endAngle:o+=t*c}}),f}var t=Number,e=Xo,r=0,u=2*La;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n};var Xo={};oa.layout.stack=function(){function n(o,c){var l=o.map(function(e,r){return t.call(n,e,r)}),f=l.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),a.call(n,t,e)]})}),s=e.call(n,f,c);l=oa.permute(l,s),f=oa.permute(f,s);var h,g,p,d=r.call(n,f,c),m=l.length,v=l[0].length;for(g=0;v>g;++g)for(u.call(n,l[0][g],p=d[g],f[0][g][1]),h=1;m>h;++h)u.call(n,l[h][g],p+=f[h-1][g][1],f[h][g][1]);return o}var t=ft,e=nu,r=tu,u=Qr,i=Kr,a=Wr;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:Zo.get(t)||nu,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:Bo.get(t)||tu,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(a=t,n):a},n.out=function(t){return arguments.length?(u=t,n):u},n};var Zo=oa.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(eu),i=n.map(ru),a=oa.range(r).sort(function(n,t){return u[n]-u[t]}),o=0,c=0,l=[],f=[];for(t=0;r>t;++t)e=a[t],c>o?(o+=i[e],l.push(e)):(c+=i[e],f.push(e));return f.reverse().concat(l)},reverse:function(n){return oa.range(n.length).reverse()},"default":nu}),Bo=oa.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,a=[],o=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>o&&(o=r),a.push(r)}for(e=0;i>e;++e)c[e]=(o-a[e])/2;return c},wiggle:function(n){var t,e,r,u,i,a,o,c,l,f=n.length,s=n[0],h=s.length,g=[];for(g[0]=c=l=0,e=1;h>e;++e){for(t=0,u=0;f>t;++t)u+=n[t][e][1];for(t=0,i=0,o=s[e][0]-s[e-1][0];f>t;++t){for(r=0,a=(n[t][e][1]-n[t][e-1][1])/(2*o);t>r;++r)a+=(n[r][e][1]-n[r][e-1][1])/o;i+=a*n[t][e][1]}g[e]=c-=u?i/u*o:0,l>c&&(l=c)}for(e=0;h>e;++e)g[e]-=l;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,a=1/u,o=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=a}for(e=0;i>e;++e)o[e]=0;return o},zero:tu});oa.layout.histogram=function(){function n(n,i){for(var a,o,c=[],l=n.map(e,this),f=r.call(this,l,i),s=u.call(this,f,l,i),i=-1,h=l.length,g=s.length-1,p=t?1:1/h;++i<g;)a=c[i]=[],a.dx=s[i+1]-(a.x=s[i]),a.y=0;if(g>0)for(i=-1;++i<h;)o=l[i],o>=f[0]&&o<=f[1]&&(a=c[oa.bisect(s,o,1,g)-1],a.y+=p,a.push(n[i]));return c}var t=!0,e=Number,r=ou,u=iu;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=lt(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return au(n,t)}:lt(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},oa.layout.tree=function(){function n(n,u){function i(n,t){var r=n.children,u=n._tree;if(r&&(a=r.length)){for(var a,c,l,f=r[0],s=f,h=-1;++h<a;)l=r[h],i(l,c),s=o(l,c,s),c=l;mu(n);var g=.5*(f._tree.prelim+l._tree.prelim);t?(u.prelim=t._tree.prelim+e(n,t),u.mod=u.prelim-g):u.prelim=g}else t&&(u.prelim=t._tree.prelim+e(n,t))}function a(n,t){n.x=n._tree.prelim+t;var e=n.children;if(e&&(r=e.length)){var r,u=-1;for(t+=n._tree.mod;++u<r;)a(e[u],t)}}function o(n,t,r){if(t){for(var u,i=n,a=n,o=t,c=n.parent.children[0],l=i._tree.mod,f=a._tree.mod,s=o._tree.mod,h=c._tree.mod;o=fu(o),i=lu(i),o&&i;)c=lu(c),a=fu(a),a._tree.ancestor=n,u=o._tree.prelim+s-i._tree.prelim-l+e(o,i),u>0&&(vu(yu(o,n,r),n,u),l+=u,f+=u),s+=o._tree.mod,l+=i._tree.mod,h+=c._tree.mod,f+=a._tree.mod;o&&!fu(a)&&(a._tree.thread=o,a._tree.mod+=s-f),i&&!lu(c)&&(c._tree.thread=i,c._tree.mod+=l-h,r=n)}return r}var c=t.call(this,n,u),l=c[0];du(l,function(n,t){n._tree={ancestor:n,prelim:0,mod:0,change:0,shift:0,number:t?t._tree.number+1:0}}),i(l),a(l,-l._tree.prelim);var f=su(l,gu),s=su(l,hu),h=su(l,pu),g=f.x-e(f,s)/2,p=s.x+e(s,f)/2,d=h.depth||1;return du(l,function(n){n.x=(n.x-g)/(p-g)*r[0],n.y=n.depth/d*r[1],delete n._tree}),c}var t=oa.layout.hierarchy().sort(null).value(null),e=cu,r=[1,1];return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(r=t,n):r},Zr(n,t)},oa.layout.pack=function(){function n(n,u){var i=t.call(this,n,u),a=i[0];a.x=0,a.y=0,du(a,function(n){n.r=Math.sqrt(n.value)}),du(a,wu);var o=r[0],c=r[1],l=Math.max(2*a.r/o,2*a.r/c);if(e>0){var f=e*l/2;du(a,function(n){n.r+=f}),du(a,wu),du(a,function(n){n.r-=f}),l=Math.max(2*a.r/o,2*a.r/c)}return ku(a,o/2,c/2,1/l),i}var t=oa.layout.hierarchy().sort(Mu),e=0,r=[1,1];return n.size=function(t){return arguments.length?(r=t,n):r},n.padding=function(t){return arguments.length?(e=+t,n):e},Zr(n,t)},oa.layout.cluster=function(){function n(n,u){var i,a=t.call(this,n,u),o=a[0],c=0;du(o,function(n){var t=n.children;t&&t.length?(n.x=Nu(t),n.y=qu(t)):(n.x=i?c+=e(n,i):0,n.y=0,i=n)});var l=Tu(o),f=Cu(o),s=l.x-e(l,f)/2,h=f.x+e(f,l)/2;return du(o,function(n){n.x=(n.x-s)/(h-s)*r[0],n.y=(1-(o.y?n.y/o.y:1))*r[1]}),a}var t=oa.layout.hierarchy().sort(null).value(null),e=cu,r=[1,1];return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(r=t,n):r},Zr(n,t)},oa.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var a,o,c,l=s(e),f=[],h=i.slice(),p=1/0,d="slice"===g?l.dx:"dice"===g?l.dy:"slice-dice"===g?e.depth&1?l.dy:l.dx:Math.min(l.dx,l.dy);for(n(h,l.dx*l.dy/e.value),f.area=0;(c=h.length)>0;)f.push(a=h[c-1]),f.area+=a.area,"squarify"!==g||(o=r(f,d))<=p?(h.pop(),p=o):(f.area-=f.pop().area,u(f,d,l,!1),d=Math.min(l.dx,l.dy),f.length=f.area=0,p=1/0);f.length&&(u(f,d,l,!0),f.length=f.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,a=s(t),o=r.slice(),c=[];for(n(o,a.dx*a.dy/t.value),c.area=0;i=o.pop();)c.push(i),c.area+=i.area,i.z!=null&&(u(c,i.z?a.dx:a.dy,a,!o.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,a=-1,o=n.length;++a<o;)(e=n[a].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,a=n.length,o=e.x,l=e.y,f=t?c(n.area/t):0;if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++i<a;)u=n[i],u.x=o,u.y=l,u.dy=f,o+=u.dx=Math.min(e.x+e.dx-o,f?c(u.area/f):0);u.z=!0,u.dx+=e.x+e.dx-o,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++i<a;)u=n[i],u.x=o,u.y=l,u.dx=f,l+=u.dy=Math.min(e.y+e.dy-l,f?c(u.area/f):0);u.z=!1,u.dy+=e.y+e.dy-l,e.x+=f,e.dx-=f}}function i(r){var u=a||o(r),i=u[0];return i.x=0,i.y=0,i.dx=l[0],i.dy=l[1],a&&o.revalue(i),n([i],i.dx*i.dy/i.value),(a?e:t)(i),h&&(a=u),u}var a,o=oa.layout.hierarchy(),c=Math.round,l=[1,1],f=null,s=zu,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));return i.size=function(n){return arguments.length?(l=n,i):l},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?zu(t):Du(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Du(t,n)}if(!arguments.length)return f;var r;return s=(f=n)==null?zu:(r=typeof n)=="function"?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,a=null,i):h},i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Zr(i,o)},oa.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=Math.random()*2-1,r=Math.random()*2-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=oa.random.normal.apply(oa,arguments);return function(){return Math.exp(n())}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t/n}}},oa.scale={},oa.scale.linear=function(){return Ru([0,1],[0,1],mr,!1)},oa.scale.log=function(){return Xu(oa.scale.linear().domain([0,Math.LN10]),10,Zu,Bu)};var $o=oa.format(".0e");oa.scale.pow=function(){return Ku(oa.scale.linear(),1)},oa.scale.sqrt=function(){return oa.scale.pow().exponent(.5)},oa.scale.ordinal=function(){return Qu([],{t:"range",a:[[]]})},oa.scale.category10=function(){return oa.scale.ordinal().range(Jo)},oa.scale.category20=function(){return oa.scale.ordinal().range(Go)},oa.scale.category20b=function(){return oa.scale.ordinal().range(Ko)},oa.scale.category20c=function(){return oa.scale.ordinal().range(Wo)};var Jo=["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],Go=["#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf","#9edae5"],Ko=["#393b79","#5254a3","#6b6ecf","#9c9ede","#637939","#8ca252","#b5cf6b","#cedb9c","#8c6d31","#bd9e39","#e7ba52","#e7cb94","#843c39","#ad494a","#d6616b","#e7969c","#7b4173","#a55194","#ce6dbd","#de9ed6"],Wo=["#3182bd","#6baed6","#9ecae1","#c6dbef","#e6550d","#fd8d3c","#fdae6b","#fdd0a2","#31a354","#74c476","#a1d99b","#c7e9c0","#756bb1","#9e9ac8","#bcbddc","#dadaeb","#636363","#969696","#bdbdbd","#d9d9d9"];oa.scale.quantile=function(){return ni([],[])},oa.scale.quantize=function(){return ti(0,1,[0,1])},oa.scale.threshold=function(){return ei([.5],[0,1])},oa.scale.identity=function(){return ri([0,1])},oa.svg.arc=function(){function n(){var n=t.apply(this,arguments),i=e.apply(this,arguments),a=r.apply(this,arguments)+Qo,o=u.apply(this,arguments)+Qo,c=(a>o&&(c=a,a=o,o=c),o-a),l=La>c?"0":"1",f=Math.cos(a),s=Math.sin(a),h=Math.cos(o),g=Math.sin(o);return c>=nc?n?"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"M0,"+n+"A"+n+","+n+" 0 1,0 0,"+-n+"A"+n+","+n+" 0 1,0 0,"+n+"Z":"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"Z":n?"M"+i*f+","+i*s+"A"+i+","+i+" 0 "+l+",1 "+i*h+","+i*g+"L"+n*h+","+n*g+"A"+n+","+n+" 0 "+l+",0 "+n*f+","+n*s+"Z":"M"+i*f+","+i*s+"A"+i+","+i+" 0 "+l+",1 "+i*h+","+i*g+"L0,0"+"Z"}var t=ui,e=ii,r=ai,u=oi;return n.innerRadius=function(e){return arguments.length?(t=lt(e),n):t},n.outerRadius=function(t){return arguments.length?(e=lt(t),n):e},n.startAngle=function(t){return arguments.length?(r=lt(t),n):r},n.endAngle=function(t){return arguments.length?(u=lt(t),n):u},n.centroid=function(){var n=(t.apply(this,arguments)+e.apply(this,arguments))/2,i=(r.apply(this,arguments)+u.apply(this,arguments))/2+Qo;return[Math.cos(i)*n,Math.sin(i)*n]},n};var Qo=-La/2,nc=2*La-1e-6;oa.svg.line.radial=function(){var n=Ce(ci);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},Fe.reverse=He,He.reverse=Fe,oa.svg.area=function(){return li(ft)},oa.svg.area.radial=function(){var n=li(ci);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},oa.svg.chord=function(){function n(n,o){var c=t(this,i,n,o),l=t(this,a,n,o);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,l)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,l.r,l.p0)+r(l.r,l.p1,l.a1-l.a0)+u(l.r,l.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=o.call(n,u,r),a=c.call(n,u,r)+Qo,f=l.call(n,u,r)+Qo;return{r:i,a0:a,a1:f,p0:[i*Math.cos(a),i*Math.sin(a)],p1:[i*Math.cos(f),i*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>La)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=le,a=fe,o=fi,c=ai,l=oi;return n.radius=function(t){return arguments.length?(o=lt(t),n):o},n.source=function(t){return arguments.length?(i=lt(t),n):i},n.target=function(t){return arguments.length?(a=lt(t),n):a},n.startAngle=function(t){return arguments.length?(c=lt(t),n):c},n.endAngle=function(t){return arguments.length?(l=lt(t),n):l},n},oa.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),a=e.call(this,n,u),o=(i.y+a.y)/2,c=[i,{x:i.x,y:o},{x:a.x,y:o},a];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=le,e=fe,r=si;return n.source=function(e){return arguments.length?(t=lt(e),n):t},n.target=function(t){return arguments.length?(e=lt(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},oa.svg.diagonal.radial=function(){var n=oa.svg.diagonal(),t=si,e=n.projection;return n.projection=function(n){return arguments.length?e(hi(t=n)):t},n},oa.svg.symbol=function(){function n(n,r){return(tc.get(t.call(this,n,r))||di)(e.call(this,n,r))}var t=pi,e=gi;return n.type=function(e){return arguments.length?(t=lt(e),n):t},n.size=function(t){return arguments.length?(e=lt(t),n):e},n};var tc=oa.map({circle:di,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*uc)),e=t*uc;return"M0,"+-t+"L"+e+",0"+" 0,"+t+" "+-e+",0"+"Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/rc),e=t*rc/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/rc),e=t*rc/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});oa.svg.symbolTypes=tc.keys();var ec,rc=Math.sqrt(3),uc=Math.tan(30*Ha),ic=[],ac=0,oc={ease:Sr,delay:0,duration:250};ic.call=Ea.call,ic.empty=Ea.empty,ic.node=Ea.node,oa.transition=function(n){return arguments.length?ec?n.transition():n:Ta.transition()},oa.transition.prototype=ic,ic.select=function(n){var t,e,r,u=this.id,i=[];"function"!=typeof n&&(n=m(n));for(var a=-1,o=this.length;++a<o;){i.push(t=[]);for(var c=this[a],l=-1,f=c.length;++l<f;)(r=c[l])&&(e=n.call(r,r.__data__,l))?("__data__"in r&&(e.__data__=r.__data__),Mi(e,l,u,r.__transition__[u]),t.push(e)):t.push(null)}return mi(i,u)},ic.selectAll=function(n){var t,e,r,u,i,a=this.id,o=[];"function"!=typeof n&&(n=v(n));for(var c=-1,l=this.length;++c<l;)for(var f=this[c],s=-1,h=f.length;++s<h;)if(r=f[s]){i=r.__transition__[a],e=n.call(r,r.__data__,s),o.push(t=[]);for(var g=-1,p=e.length;++g<p;)Mi(u=e[g],g,a,i),t.push(u)}return mi(o,a)},ic.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=A(n));for(var i=0,a=this.length;a>i;i++){u.push(t=[]);for(var e=this[i],o=0,c=e.length;c>o;o++)(r=e[o])&&n.call(r,r.__data__,o)&&t.push(r)}return mi(u,this.id,this.time).ease(this.ease())},ic.tween=function(n,t){var e=this.id;return arguments.length<2?this.node().__transition__[e].tween.get(n):D(this,null==t?function(t){t.__transition__[e].tween.remove(n)}:function(r){r.__transition__[e].tween.set(n,t)})},ic.attr=function(n,t){function e(){this.removeAttribute(i)}function r(){this.removeAttributeNS(i.space,i.local)}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var u=vr(n),i=oa.ns.qualify(n);return vi(this,"attr."+n,t,function(n){function t(){var t,e=this.getAttribute(i);return e!==n&&(t=u(e,n),function(n){this.setAttribute(i,t(n))})}function a(){var t,e=this.getAttributeNS(i.space,i.local);return e!==n&&(t=u(e,n),function(n){this.setAttributeNS(i.space,i.local,t(n))})}return null==n?i.local?r:e:(n+="",i.local?a:t)})},ic.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=oa.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},ic.style=function(n,t,e){function r(){this.style.removeProperty(n)}var u=arguments.length;if(3>u){if("string"!=typeof n){2>u&&(t="");for(e in n)this.style(e,n[e],t);return this}e=""}var i=vr(n);return vi(this,"style."+n,t,function(t){function u(){var r,u=la.getComputedStyle(this,null).getPropertyValue(n);return u!==t&&(r=i(u,t),function(t){this.style.setProperty(n,r(t),e)})}return null==t?r:(t+="",u)})},ic.styleTween=function(n,t,e){return arguments.length<3&&(e=""),this.tween("style."+n,function(r,u){var i=t.call(this,r,u,la.getComputedStyle(this,null).getPropertyValue(n));return i&&function(t){this.style.setProperty(n,i(t),e)}})},ic.text=function(n){return vi(this,"text",n,yi)},ic.remove=function(){return this.each("end.transition",function(){var n;!this.__transition__&&(n=this.parentNode)&&n.removeChild(this)})},ic.ease=function(n){var t=this.id;return arguments.length<1?this.node().__transition__[t].ease:("function"!=typeof n&&(n=oa.ease.apply(oa,arguments)),D(this,function(e){e.__transition__[t].ease=n}))},ic.delay=function(n){var t=this.id;return D(this,"function"==typeof n?function(e,r,u){e.__transition__[t].delay=n.call(e,e.__data__,r,u)|0}:(n|=0,function(e){e.__transition__[t].delay=n}))},ic.duration=function(n){var t=this.id;return D(this,"function"==typeof n?function(e,r,u){e.__transition__[t].duration=Math.max(1,n.call(e,e.__data__,r,u)|0)}:(n=Math.max(1,0|n),function(e){e.__transition__[t].duration=n}))},ic.each=function(n,t){var e=this.id;if(arguments.length<2){var r=oc,u=ec;ec=e,D(this,function(t,r,u){oc=t.__transition__[e],n.call(t,t.__data__,r,u)}),oc=r,ec=u}else D(this,function(r){r.__transition__[e].event.on(n,t)});return this},ic.transition=function(){for(var n,t,e,r,u=this.id,i=++ac,a=[],o=0,c=this.length;c>o;o++){a.push(n=[]);for(var t=this[o],l=0,f=t.length;f>l;l++)(e=t[l])&&(r=Object.create(e.__transition__[u]),r.delay+=r.duration,Mi(e,l,i,r)),n.push(e)}return mi(a,i)},oa.svg.axis=function(){function n(n){n.each(function(){var n,s=oa.select(this),h=null==l?e.ticks?e.ticks.apply(e,c):e.domain():l,g=null==t?e.tickFormat?e.tickFormat.apply(e,c):String:t,p=_i(e,h,f),d=s.selectAll(".tick.minor").data(p,String),m=d.enter().insert("line",".tick").attr("class","tick minor").style("opacity",1e-6),v=oa.transition(d.exit()).style("opacity",1e-6).remove(),y=oa.transition(d).style("opacity",1),M=s.selectAll(".tick.major").data(h,String),x=M.enter().insert("g","path").attr("class","tick major").style("opacity",1e-6),b=oa.transition(M.exit()).style("opacity",1e-6).remove(),_=oa.transition(M).style("opacity",1),w=Lu(e),S=s.selectAll(".domain").data([0]),E=(S.enter().append("path").attr("class","domain"),oa.transition(S)),k=e.copy(),A=this.__chart__||k;this.__chart__=k,x.append("line"),x.append("text");var q=x.select("line"),N=_.select("line"),T=M.select("text").text(g),C=x.select("text"),z=_.select("text");switch(r){case"bottom":n=xi,m.attr("y2",i),y.attr("x2",0).attr("y2",i),q.attr("y2",u),C.attr("y",Math.max(u,0)+o),N.attr("x2",0).attr("y2",u),z.attr("x",0).attr("y",Math.max(u,0)+o),T.attr("dy",".71em").style("text-anchor","middle"),E.attr("d","M"+w[0]+","+a+"V0H"+w[1]+"V"+a);break;case"top":n=xi,m.attr("y2",-i),y.attr("x2",0).attr("y2",-i),q.attr("y2",-u),C.attr("y",-(Math.max(u,0)+o)),N.attr("x2",0).attr("y2",-u),z.attr("x",0).attr("y",-(Math.max(u,0)+o)),T.attr("dy","0em").style("text-anchor","middle"),E.attr("d","M"+w[0]+","+-a+"V0H"+w[1]+"V"+-a);break;case"left":n=bi,m.attr("x2",-i),y.attr("x2",-i).attr("y2",0),q.attr("x2",-u),C.attr("x",-(Math.max(u,0)+o)),N.attr("x2",-u).attr("y2",0),z.attr("x",-(Math.max(u,0)+o)).attr("y",0),T.attr("dy",".32em").style("text-anchor","end"),E.attr("d","M"+-a+","+w[0]+"H0V"+w[1]+"H"+-a);break;case"right":n=bi,m.attr("x2",i),y.attr("x2",i).attr("y2",0),q.attr("x2",u),C.attr("x",Math.max(u,0)+o),N.attr("x2",u).attr("y2",0),z.attr("x",Math.max(u,0)+o).attr("y",0),T.attr("dy",".32em").style("text-anchor","start"),E.attr("d","M"+a+","+w[0]+"H0V"+w[1]+"H"+a)}if(e.ticks)x.call(n,A),_.call(n,k),b.call(n,k),m.call(n,A),y.call(n,k),v.call(n,k);else{var D=k.rangeBand()/2,j=function(n){return k(n)+D};x.call(n,j),_.call(n,j)}})}var t,e=oa.scale.linear(),r=cc,u=6,i=6,a=6,o=3,c=[10],l=null,f=0;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in lc?t+"":cc,n):r},n.ticks=function(){return arguments.length?(c=arguments,n):c},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t,e){if(!arguments.length)return u;var r=arguments.length-1;return u=+t,i=r>1?+e:u,a=r>0?+arguments[r]:u,n},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(t){return arguments.length?(f=+t,n):f},n};var cc="bottom",lc={top:1,right:1,bottom:1,left:1};oa.svg.brush=function(){function n(i){i.each(function(){var i,a=oa.select(this),l=a.selectAll(".background").data([0]),s=a.selectAll(".extent").data([0]),h=a.selectAll(".resize").data(f,String);a.style("pointer-events","all").on("mousedown.brush",u).on("touchstart.brush",u),l.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),s.enter().append("rect").attr("class","extent").style("cursor","move"),h.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return fc[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),h.style("display",n.empty()?"none":null),h.exit().remove(),o&&(i=Lu(o),l.attr("x",i[0]).attr("width",i[1]-i[0]),e(a)),c&&(i=Lu(c),l.attr("y",i[0]).attr("height",i[1]-i[0]),r(a)),t(a)})}function t(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+h[+/e$/.test(n)][0]+","+h[+/^s/.test(n)][1]+")"})}function e(n){n.select(".extent").attr("x",h[0][0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",h[1][0]-h[0][0])}function r(n){n.select(".extent").attr("y",h[0][1]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1][1]-h[0][1])}function u(){function u(){var n=oa.event.changedTouches;return n?oa.touches(y,n)[0]:oa.mouse(y)}function f(){oa.event.keyCode==32&&(E||(m=null,k[0]-=h[1][0],k[1]-=h[1][1],E=2),l())}function s(){oa.event.keyCode==32&&2==E&&(k[0]+=h[1][0],k[1]+=h[1][1],E=0,l())}function g(){var n=u(),i=!1;v&&(n[0]+=v[0],n[1]+=v[1]),E||(oa.event.altKey?(m||(m=[(h[0][0]+h[1][0])/2,(h[0][1]+h[1][1])/2]),k[0]=h[+(n[0]<m[0])][0],k[1]=h[+(n[1]<m[1])][1]):m=null),w&&p(n,o,0)&&(e(b),i=!0),S&&p(n,c,1)&&(r(b),i=!0),i&&(t(b),x({type:"brush",mode:E?"move":"resize"}))}function p(n,t,e){var r,u,a=Lu(t),o=a[0],c=a[1],l=k[e],f=h[1][e]-h[0][e];return E&&(o-=l,c-=f+l),r=Math.max(o,Math.min(c,n[e])),E?u=(r+=l)+f:(m&&(l=Math.max(o,Math.min(c,2*m[e]-r))),r>l?(u=r,r=l):u=l),h[0][e]!==r||h[1][e]!==u?(i=null,h[0][e]=r,h[1][e]=u,!0):void 0}function d(){g(),b.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),oa.select("body").style("cursor",null),A.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),x({type:"brushend"}),l()}var m,v,y=this,M=oa.select(oa.event.target),x=a.of(y,arguments),b=oa.select(y),_=M.datum(),w=!/^(n|s)$/.test(_)&&o,S=!/^(e|w)$/.test(_)&&c,E=M.classed("extent"),k=u(),A=oa.select(la).on("mousemove.brush",g).on("mouseup.brush",d).on("touchmove.brush",g).on("touchend.brush",d).on("keydown.brush",f).on("keyup.brush",s);if(E)k[0]=h[0][0]-k[0],k[1]=h[0][1]-k[1];else if(_){var q=+/w$/.test(_),N=+/^n/.test(_);v=[h[1-q][0]-k[0],h[1-N][1]-k[1]],k[0]=h[q][0],k[1]=h[N][1]}else oa.event.altKey&&(m=k.slice());b.style("pointer-events","none").selectAll(".resize").style("display",null),oa.select("body").style("cursor",M.style("cursor")),x({type:"brushstart"}),g(),l()
}var i,a=s(n,"brushstart","brush","brushend"),o=null,c=null,f=sc[0],h=[[0,0],[0,0]];return n.x=function(t){return arguments.length?(o=t,f=sc[!o<<1|!c],n):o},n.y=function(t){return arguments.length?(c=t,f=sc[!o<<1|!c],n):c},n.extent=function(t){var e,r,u,a,l;return arguments.length?(i=[[0,0],[0,0]],o&&(e=t[0],r=t[1],c&&(e=e[0],r=r[0]),i[0][0]=e,i[1][0]=r,o.invert&&(e=o(e),r=o(r)),e>r&&(l=e,e=r,r=l),h[0][0]=0|e,h[1][0]=0|r),c&&(u=t[0],a=t[1],o&&(u=u[1],a=a[1]),i[0][1]=u,i[1][1]=a,c.invert&&(u=c(u),a=c(a)),u>a&&(l=u,u=a,a=l),h[0][1]=0|u,h[1][1]=0|a),n):(t=i||h,o&&(e=t[0][0],r=t[1][0],i||(e=h[0][0],r=h[1][0],o.invert&&(e=o.invert(e),r=o.invert(r)),e>r&&(l=e,e=r,r=l))),c&&(u=t[0][1],a=t[1][1],i||(u=h[0][1],a=h[1][1],c.invert&&(u=c.invert(u),a=c.invert(a)),u>a&&(l=u,u=a,a=l))),o&&c?[[e,u],[r,a]]:o?[e,r]:c&&[u,a])},n.clear=function(){return i=null,h[0][0]=h[0][1]=h[1][0]=h[1][1]=0,n},n.empty=function(){return o&&h[0][0]===h[1][0]||c&&h[0][1]===h[1][1]},oa.rebind(n,a,"on")};var fc={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},sc=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]];oa.time={};var hc=Date,gc=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];wi.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){pc.setUTCDate.apply(this._,arguments)},setDay:function(){pc.setUTCDay.apply(this._,arguments)},setFullYear:function(){pc.setUTCFullYear.apply(this._,arguments)},setHours:function(){pc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){pc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){pc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){pc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){pc.setUTCSeconds.apply(this._,arguments)},setTime:function(){pc.setTime.apply(this._,arguments)}};var pc=Date.prototype,dc="%a %b %e %X %Y",mc="%m/%d/%Y",vc="%H:%M:%S",yc=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],Mc=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],xc=["January","February","March","April","May","June","July","August","September","October","November","December"],bc=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];oa.time.year=Si(function(n){return n=oa.time.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),oa.time.years=oa.time.year.range,oa.time.years.utc=oa.time.year.utc.range,oa.time.day=Si(function(n){var t=new hc(1970,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),oa.time.days=oa.time.day.range,oa.time.days.utc=oa.time.day.utc.range,oa.time.dayOfYear=function(n){var t=oa.time.year(n);return Math.floor((n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*6e4)/864e5)},gc.forEach(function(n,t){n=n.toLowerCase(),t=7-t;var e=oa.time[n]=Si(function(n){return(n=oa.time.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+Math.floor(t)*7)},function(n){var e=oa.time.year(n).getDay();return Math.floor((oa.time.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});oa.time[n+"s"]=e.range,oa.time[n+"s"].utc=e.utc.range,oa.time[n+"OfYear"]=function(n){var e=oa.time.year(n).getDay();return Math.floor((oa.time.dayOfYear(n)+(e+t)%7)/7)}}),oa.time.week=oa.time.sunday,oa.time.weeks=oa.time.sunday.range,oa.time.weeks.utc=oa.time.sunday.utc.range,oa.time.weekOfYear=oa.time.sundayOfYear,oa.time.format=function(n){function t(t){for(var r,u,i,a=[],o=-1,c=0;++o<e;)n.charCodeAt(o)===37&&(a.push(n.substring(c,o)),(u=qc[r=n.charAt(++o)])!=null&&(r=n.charAt(++o)),(i=Nc[r])&&(r=i(t,null==u?"e"===r?" ":"0":u)),a.push(r),c=o+1);return a.push(n.substring(c,o)),a.join("")}var e=n.length;return t.parse=function(t){var e={y:1900,m:0,d:1,H:0,M:0,S:0,L:0},r=ki(e,n,t,0);if(r!=t.length)return null;"p"in e&&(e.H=e.H%12+e.p*12);var u=new hc;return u.setFullYear(e.y,e.m,e.d),u.setHours(e.H,e.M,e.S,e.L),u},t.toString=function(){return n},t};var _c=Ai(yc),wc=Ai(Mc),Sc=Ai(xc),Ec=qi(xc),kc=Ai(bc),Ac=qi(bc),qc={"-":"",_:" ",0:"0"},Nc={a:function(n){return Mc[n.getDay()]},A:function(n){return yc[n.getDay()]},b:function(n){return bc[n.getMonth()]},B:function(n){return xc[n.getMonth()]},c:oa.time.format(dc),d:function(n,t){return Ni(n.getDate(),t,2)},e:function(n,t){return Ni(n.getDate(),t,2)},H:function(n,t){return Ni(n.getHours(),t,2)},I:function(n,t){return Ni(n.getHours()%12||12,t,2)},j:function(n,t){return Ni(1+oa.time.dayOfYear(n),t,3)},L:function(n,t){return Ni(n.getMilliseconds(),t,3)},m:function(n,t){return Ni(n.getMonth()+1,t,2)},M:function(n,t){return Ni(n.getMinutes(),t,2)},p:function(n){return n.getHours()>=12?"PM":"AM"},S:function(n,t){return Ni(n.getSeconds(),t,2)},U:function(n,t){return Ni(oa.time.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Ni(oa.time.mondayOfYear(n),t,2)},x:oa.time.format(mc),X:oa.time.format(vc),y:function(n,t){return Ni(n.getFullYear()%100,t,2)},Y:function(n,t){return Ni(n.getFullYear()%1e4,t,4)},Z:Bi,"%":function(){return"%"}},Tc={a:Ti,A:Ci,b:zi,B:Di,c:ji,d:Yi,e:Yi,H:Ui,I:Ui,L:Xi,m:Oi,M:Ii,p:Zi,S:Vi,x:Li,X:Fi,y:Pi,Y:Hi},Cc=/^\s*\d+/,zc=oa.map({am:0,pm:1});oa.time.format.utc=function(n){function t(n){try{hc=wi;var t=new hc;return t._=n,e(t)}finally{hc=Date}}var e=oa.time.format(n);return t.parse=function(n){try{hc=wi;var t=e.parse(n);return t&&t._}finally{hc=Date}},t.toString=e.toString,t};var Dc=oa.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");oa.time.format.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?$i:Dc,$i.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},$i.toString=Dc.toString,oa.time.second=Si(function(n){return new hc(Math.floor(n/1e3)*1e3)},function(n,t){n.setTime(n.getTime()+Math.floor(t)*1e3)},function(n){return n.getSeconds()}),oa.time.seconds=oa.time.second.range,oa.time.seconds.utc=oa.time.second.utc.range,oa.time.minute=Si(function(n){return new hc(Math.floor(n/6e4)*6e4)},function(n,t){n.setTime(n.getTime()+Math.floor(t)*6e4)},function(n){return n.getMinutes()}),oa.time.minutes=oa.time.minute.range,oa.time.minutes.utc=oa.time.minute.utc.range,oa.time.hour=Si(function(n){var t=n.getTimezoneOffset()/60;return new hc((Math.floor(n/36e5-t)+t)*36e5)},function(n,t){n.setTime(n.getTime()+Math.floor(t)*36e5)},function(n){return n.getHours()}),oa.time.hours=oa.time.hour.range,oa.time.hours.utc=oa.time.hour.utc.range,oa.time.month=Si(function(n){return n=oa.time.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),oa.time.months=oa.time.month.range,oa.time.months.utc=oa.time.month.utc.range;var jc=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Lc=[[oa.time.second,1],[oa.time.second,5],[oa.time.second,15],[oa.time.second,30],[oa.time.minute,1],[oa.time.minute,5],[oa.time.minute,15],[oa.time.minute,30],[oa.time.hour,1],[oa.time.hour,3],[oa.time.hour,6],[oa.time.hour,12],[oa.time.day,1],[oa.time.day,2],[oa.time.week,1],[oa.time.month,1],[oa.time.month,3],[oa.time.year,1]],Fc=[[oa.time.format("%Y"),Dt],[oa.time.format("%B"),function(n){return n.getMonth()}],[oa.time.format("%b %d"),function(n){return n.getDate()!=1}],[oa.time.format("%a %d"),function(n){return n.getDay()&&n.getDate()!=1}],[oa.time.format("%I %p"),function(n){return n.getHours()}],[oa.time.format("%I:%M"),function(n){return n.getMinutes()}],[oa.time.format(":%S"),function(n){return n.getSeconds()}],[oa.time.format(".%L"),function(n){return n.getMilliseconds()}]],Hc=oa.scale.linear(),Pc=Wi(Fc);Lc.year=function(n,t){return Hc.domain(n.map(na)).ticks(t).map(Qi)},oa.time.scale=function(){return Ji(oa.scale.linear(),Lc,Pc)};var Rc=Lc.map(function(n){return[n[0].utc,n[1]]}),Oc=[[oa.time.format.utc("%Y"),Dt],[oa.time.format.utc("%B"),function(n){return n.getUTCMonth()}],[oa.time.format.utc("%b %d"),function(n){return n.getUTCDate()!=1}],[oa.time.format.utc("%a %d"),function(n){return n.getUTCDay()&&n.getUTCDate()!=1}],[oa.time.format.utc("%I %p"),function(n){return n.getUTCHours()}],[oa.time.format.utc("%I:%M"),function(n){return n.getUTCMinutes()}],[oa.time.format.utc(":%S"),function(n){return n.getUTCSeconds()}],[oa.time.format.utc(".%L"),function(n){return n.getUTCMilliseconds()}]],Yc=Wi(Oc);return Rc.year=function(n,t){return Hc.domain(n.map(ea)).ticks(t).map(ta)},oa.time.scale.utc=function(){return Ji(oa.scale.linear(),Rc,Yc)},oa.text=function(){return oa.xhr.apply(oa,arguments).response(ra)},oa.json=function(n,t){return oa.xhr(n,"application/json",t).response(ua)},oa.html=function(n,t){return oa.xhr(n,"text/html",t).response(ia)},oa.xml=function(){return oa.xhr.apply(oa,arguments).response(aa)},oa}();
(function (requirejs, require, define) {

define(
'video/00_video_storage.js',
[],
function() {
    "use strict";
/**
 * Provides convenient way to store key value pairs.
 *
 * @param {string} namespace Namespace that is used to store data.
 * @return {object} VideoStorage API.
 */
    var VideoStorage = function (namespace, id) {
        /**
        * Adds new value to the storage or rewrites existent.
        *
        * @param {string} name Identifier of the data.
        * @param {any} value Data to store.
        * @param {boolean} instanceSpecific Data with this flag will be added
        *     to instance specific storage.
        */
        var setItem = function (name, value, instanceSpecific) {
            if (name) {
                if (instanceSpecific) {
                    window[namespace][id][name] = value;
                } else {
                    window[namespace][name] = value;
                }
            }
        };

        /**
        * Returns the current value associated with the given name.
        *
        * @param {string} name Identifier of the data.
        * @param {boolean} instanceSpecific Data with this flag will be added
        *     to instance specific storage.
        * @return {any} The current value associated with the given name.
        *     If the given key does not exist in the list
        *     associated with the object then this method must return null.
        */
        var getItem = function (name, instanceSpecific) {
            if (instanceSpecific) {
                return window[namespace][id][name];
            } else {
                return window[namespace][name];
            }
        };

        /**
        * Removes the current value associated with the given name.
        *
        * @param {string} name Identifier of the data.
        * @param {boolean} instanceSpecific Data with this flag will be added
        *     to instance specific storage.
        */
        var removeItem = function (name, instanceSpecific) {
            if (instanceSpecific) {
                delete window[namespace][id][name];
            } else {
                delete window[namespace][name];
            }
        };

        /**
        * Empties the storage.
        *
        */
        var clear = function () {
            window[namespace] = {};
            window[namespace][id] = {};
        };

        /**
        * Initializes the module: creates a storage with proper namespace.
        *
        * @private
        */
        (function initialize() {
            if (!namespace) {
                namespace = 'VideoStorage';
            }
            if (!id) {
                // Generate random alpha-numeric string.
                id = Math.random().toString(36).slice(2);
            }

            window[namespace] = window[namespace] || {};
            window[namespace][id] = window[namespace][id] || {};
        }());

        return {
            clear: clear,
            getItem: getItem,
            removeItem: removeItem,
            setItem: setItem
        };
    };

    return VideoStorage;
});
}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Generated by CoffeeScript 1.6.3
(function() {
  this.HTMLModule = (function() {
    function HTMLModule(element) {
      this.element = element;
      this.el = $(this.element);
      JavascriptLoader.executeModuleScripts(this.el);
      Collapsible.setCollapsibles(this.el);
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, this.el[0]]);
      }
    }

    HTMLModule.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    return HTMLModule;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.PeerGradingProblemBackend = (function() {
    function PeerGradingProblemBackend(ajax_url, mock_backend) {
      this.mock_backend = mock_backend;
      this.ajax_url = ajax_url;
      this.mock_cnt = 0;
    }

    PeerGradingProblemBackend.prototype.post = function(cmd, data, callback) {
      var _this = this;
      if (this.mock_backend) {
        return callback(this.mock(cmd, data));
      } else {
        return $.post(this.ajax_url + cmd, data, callback).error(function() {
          return callback({
            success: false,
            error: "Error occurred while performing this operation"
          });
        });
      }
    };

    PeerGradingProblemBackend.prototype.mock = function(cmd, data) {
      var response;
      if (cmd === 'is_student_calibrated') {
        response = {
          success: true,
          calibrated: this.mock_cnt >= 2
        };
      } else if (cmd === 'show_calibration_essay') {
        this.mock_cnt++;
        response = {
          success: true,
          submission_id: 1,
          submission_key: 'abcd',
          student_response: 'Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of "de Finibus Bonorum et Malorum" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, "Lorem ipsum dolor sit amet..", comes from a line in section 1.10.32.\n\nThe standard chunk of Lorem Ipsum used since the 1500s is reproduced below for those interested. Sections 1.10.32 and 1.10.33 from "de Finibus Bonorum et Malorum" by Cicero are also reproduced in their exact original form, accompanied by English versions from the 1914 translation by H. Rackham.',
          prompt: '<h2>S11E3: Metal Bands</h2>\n<p>Shown below are schematic band diagrams for two different metals. Both diagrams appear different, yet both of the elements are undisputably metallic in nature.</p>\n<p>* Why is it that both sodium and magnesium behave as metals, even though the s-band of magnesium is filled? </p>\n<p>This is a self-assessed open response question. Please use as much space as you need in the box below to answer the question.</p>',
          rubric: '<table class="rubric"><tbody><tr><th>Purpose</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-0" value="0"><label for="score-0-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-1" value="1"><label for="score-0-1">Unclear purpose or main idea</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-2" value="2"><label for="score-0-2">Communicates an identifiable purpose and/or main idea for an audience</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-3" value="3"><label for="score-0-3">Achieves a clear and distinct purpose for a targeted audience and communicates main ideas with effectively used techniques to introduce and represent ideas and insights</label>\n</td>\n</tr><tr><th>Organization</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-0" value="0"><label for="score-1-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-1" value="1"><label for="score-1-1">Organization is unclear; introduction, body, and/or conclusion are underdeveloped, missing or confusing.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-2" value="2"><label for="score-1-2">Organization is occasionally unclear; introduction, body or conclusion may be underdeveloped.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-3" value="3"><label for="score-1-3">Organization is clear and easy to follow; introduction, body and conclusion are defined and aligned with purpose.</label>\n</td>\n</tr></tbody></table>',
          max_score: 4
        };
      } else if (cmd === 'get_next_submission') {
        response = {
          success: true,
          submission_id: 1,
          submission_key: 'abcd',
          student_response: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec tristique ante. Proin at mauris sapien, quis varius leo. Morbi laoreet leo nisi. Morbi aliquam lacus ante. Cras iaculis velit sed diam mattis a fermentum urna luctus. Duis consectetur nunc vitae felis facilisis eget vulputate risus viverra. Cras consectetur ullamcorper lobortis. Nam eu gravida lorem. Nulla facilisi. Nullam quis felis enim. Mauris orci lectus, dictum id cursus in, vulputate in massa.\n\nPhasellus non varius sem. Nullam commodo lacinia odio sit amet egestas. Donec ullamcorper sapien sagittis arcu volutpat placerat. Phasellus ut pretium ante. Nam dictum pulvinar nibh dapibus tristique. Sed at tellus mi, fringilla convallis justo. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus tristique rutrum nulla sed eleifend. Praesent at nunc arcu. Mauris condimentum faucibus nibh, eget commodo quam viverra sed. Morbi in tincidunt dolor. Morbi sed augue et augue interdum fermentum.\n\nCurabitur tristique purus ac arcu consequat cursus. Cras diam felis, dignissim quis placerat at, aliquet ac metus. Mauris vulputate est eu nibh imperdiet varius. Cras aliquet rhoncus elit a laoreet. Mauris consectetur erat et erat scelerisque eu faucibus dolor consequat. Nam adipiscing sagittis nisl, eu mollis massa tempor ac. Nulla scelerisque tempus blandit. Phasellus ac ipsum eros, id posuere arcu. Nullam non sapien arcu. Vivamus sit amet lorem justo, ac tempus turpis. Suspendisse pharetra gravida imperdiet. Pellentesque lacinia mi eu elit luctus pellentesque. Sed accumsan libero a magna elementum varius. Nunc eget pellentesque metus. ',
          prompt: '<h2>S11E3: Metal Bands</h2>\n<p>Shown below are schematic band diagrams for two different metals. Both diagrams appear different, yet both of the elements are undisputably metallic in nature.</p>\n<p>* Why is it that both sodium and magnesium behave as metals, even though the s-band of magnesium is filled? </p>\n<p>This is a self-assessed open response question. Please use as much space as you need in the box below to answer the question.</p>',
          rubric: '<table class="rubric"><tbody><tr><th>Purpose</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-0" value="0"><label for="score-0-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-1" value="1"><label for="score-0-1">Unclear purpose or main idea</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-2" value="2"><label for="score-0-2">Communicates an identifiable purpose and/or main idea for an audience</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-3" value="3"><label for="score-0-3">Achieves a clear and distinct purpose for a targeted audience and communicates main ideas with effectively used techniques to introduce and represent ideas and insights</label>\n</td>\n</tr><tr><th>Organization</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-0" value="0"><label for="score-1-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-1" value="1"><label for="score-1-1">Organization is unclear; introduction, body, and/or conclusion are underdeveloped, missing or confusing.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-2" value="2"><label for="score-1-2">Organization is occasionally unclear; introduction, body or conclusion may be underdeveloped.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-3" value="3"><label for="score-1-3">Organization is clear and easy to follow; introduction, body and conclusion are defined and aligned with purpose.</label>\n</td>\n</tr></tbody></table>',
          max_score: 4
        };
      } else if (cmd === 'save_calibration_essay') {
        response = {
          success: true,
          actual_score: 2
        };
      } else if (cmd === 'save_grade') {
        response = {
          success: true
        };
      }
      return response;
    };

    return PeerGradingProblemBackend;

  })();

  this.PeerGradingProblem = (function() {
    PeerGradingProblem.prototype.prompt_wrapper_sel = '.prompt-wrapper';

    PeerGradingProblem.prototype.peer_grading_container_sel = '.peer-grading-container';

    PeerGradingProblem.prototype.submission_container_sel = '.submission-container';

    PeerGradingProblem.prototype.prompt_container_sel = '.prompt-container';

    PeerGradingProblem.prototype.rubric_container_sel = '.rubric-container';

    PeerGradingProblem.prototype.flag_student_container_sel = '.flag-student-container';

    PeerGradingProblem.prototype.calibration_panel_sel = '.calibration-panel';

    PeerGradingProblem.prototype.grading_panel_sel = '.grading-panel';

    PeerGradingProblem.prototype.content_panel_sel = '.content-panel';

    PeerGradingProblem.prototype.grading_message_sel = '.grading-message';

    PeerGradingProblem.prototype.question_header_sel = '.question-header';

    PeerGradingProblem.prototype.flag_submission_confirmation_sel = '.flag-submission-confirmation';

    PeerGradingProblem.prototype.flag_submission_confirmation_button_sel = '.flag-submission-confirmation-button';

    PeerGradingProblem.prototype.flag_submission_removal_button_sel = '.flag-submission-removal-button';

    PeerGradingProblem.prototype.grading_wrapper_sel = '.grading-wrapper';

    PeerGradingProblem.prototype.calibration_feedback_sel = '.calibration-feedback';

    PeerGradingProblem.prototype.interstitial_page_sel = '.interstitial-page';

    PeerGradingProblem.prototype.calibration_interstitial_page_sel = '.calibration-interstitial-page';

    PeerGradingProblem.prototype.error_container_sel = '.error-container';

    PeerGradingProblem.prototype.peer_grading_instructions_sel = '.peer-grading-instructions';

    PeerGradingProblem.prototype.feedback_area_sel = '.feedback-area';

    PeerGradingProblem.prototype.ice_legend_sel = '.ice-legend';

    PeerGradingProblem.prototype.score_selection_container_sel = '.score-selection-container';

    PeerGradingProblem.prototype.rubric_selection_container_sel = '.rubric-selection-container';

    PeerGradingProblem.prototype.submit_button_sel = '.submit-button';

    PeerGradingProblem.prototype.action_button_sel = '.action-button';

    PeerGradingProblem.prototype.calibration_feedback_button_sel = '.calibration-feedback-button';

    PeerGradingProblem.prototype.interstitial_page_button_sel = '.interstitial-page-button';

    PeerGradingProblem.prototype.calibration_interstitial_page_button_sel = '.calibration-interstitial-page-button';

    PeerGradingProblem.prototype.flag_checkbox_sel = '.flag-checkbox';

    PeerGradingProblem.prototype.calibration_text_sel = '.calibration-text';

    PeerGradingProblem.prototype.grading_text_sel = '.grading-text';

    PeerGradingProblem.prototype.calibration_feedback_wrapper_sel = '.calibration-feedback-wrapper';

    function PeerGradingProblem(backend, el) {
      this.scroll_to_top = __bind(this.scroll_to_top, this);
      this.collapse_question = __bind(this.collapse_question, this);
      this.gentle_alert = __bind(this.gentle_alert, this);
      this.setup_score_selection = __bind(this.setup_score_selection, this);
      this.show_submit_button = __bind(this.show_submit_button, this);
      this.render_error = __bind(this.render_error, this);
      this.render_calibration_interstitial_page = __bind(this.render_calibration_interstitial_page, this);
      this.render_interstitial_page = __bind(this.render_interstitial_page, this);
      this.render_calibration_feedback = __bind(this.render_calibration_feedback, this);
      this.render_submission_data = __bind(this.render_submission_data, this);
      this.render_submission = __bind(this.render_submission, this);
      this.tracking_changes = __bind(this.tracking_changes, this);
      this.render_calibration = __bind(this.render_calibration, this);
      this.keyup_handler = __bind(this.keyup_handler, this);
      this.keydown_handler = __bind(this.keydown_handler, this);
      this.graded_callback = __bind(this.graded_callback, this);
      this.submission_callback = __bind(this.submission_callback, this);
      this.calibration_callback = __bind(this.calibration_callback, this);
      this.calibration_check_callback = __bind(this.calibration_check_callback, this);
      this.flag_box_checked = __bind(this.flag_box_checked, this);
      this.close_dialog_box = __bind(this.close_dialog_box, this);
      this.remove_flag = __bind(this.remove_flag, this);
      this.submit_grade = __bind(this.submit_grade, this);
      this.submit_calibration_essay = __bind(this.submit_calibration_essay, this);
      this.fetch_submission_essay = __bind(this.fetch_submission_essay, this);
      this.fetch_calibration_essay = __bind(this.fetch_calibration_essay, this);
      this.is_calibrated_check = __bind(this.is_calibrated_check, this);
      var _this = this;
      this.el = el;
      this.prompt_wrapper = $(this.prompt_wrapper_sel);
      this.backend = backend;
      this.is_ctrl = false;
      this.el = $(this.peer_grading_container_sel);
      this.location = $('.peer-grading').data('location');
      if (!this.location) {
        return;
      }
      this.submission_container = this.$(this.submission_container_sel);
      this.prompt_container = this.$(this.prompt_container_sel);
      this.rubric_container = this.$(this.rubric_container_sel);
      this.flag_student_container = this.$(this.flag_student_container_sel);
      this.calibration_panel = this.$(this.calibration_panel_sel);
      this.grading_panel = this.$(this.grading_panel_sel);
      this.content_panel = this.$(this.content_panel_sel);
      this.grading_message = this.$(this.grading_message_sel);
      this.grading_message.hide();
      this.question_header = this.$(this.question_header_sel);
      this.question_header.click(this.collapse_question);
      this.flag_submission_confirmation = this.$(this.flag_submission_confirmation_sel);
      this.flag_submission_confirmation_button = this.$(this.flag_submission_confirmation_button_sel);
      this.flag_submission_removal_button = this.$(this.flag_submission_removal_button_sel);
      this.flag_submission_confirmation_button.click(this.close_dialog_box);
      this.flag_submission_removal_button.click(this.remove_flag);
      this.grading_wrapper = this.$(this.grading_wrapper_sel);
      this.calibration_feedback_panel = this.$(this.calibration_feedback_sel);
      this.interstitial_page = this.$(this.interstitial_page_sel);
      this.interstitial_page.hide();
      this.calibration_interstitial_page = this.$(this.calibration_interstitial_page_sel);
      this.calibration_interstitial_page.hide();
      this.error_container = this.$(this.error_container_sel);
      this.submission_key_input = $("input[name='submission-key']");
      this.essay_id_input = this.$("input[name='essay-id']");
      this.peer_grading_instructions = this.$(this.peer_grading_instructions_sel);
      this.feedback_area = this.$(this.feedback_area_sel);
      this.ice_legend = this.$(this.ice_legend_sel);
      this.score_selection_container = this.$(this.score_selection_container_sel);
      this.rubric_selection_container = this.$(this.rubric_selection_container_sel);
      this.grade = null;
      this.calibration = null;
      this.submit_button = this.$(this.submit_button_sel);
      this.action_button = this.$(this.action_button_sel);
      this.calibration_feedback_button = this.$(this.calibration_feedback_button_sel);
      this.interstitial_page_button = this.$(this.interstitial_page_button_sel);
      this.calibration_interstitial_page_button = this.$(this.calibration_interstitial_page_button_sel);
      this.flag_student_checkbox = this.$(this.flag_checkbox_sel);
      $(window).keydown(this.keydown_handler);
      $(window).keyup(this.keyup_handler);
      Collapsible.setCollapsibles(this.content_panel);
      this.action_button.click(function() {
        return history.back();
      });
      this.calibration_feedback_button.click(function() {
        _this.calibration_feedback_panel.hide();
        _this.grading_wrapper.show();
        _this.gentle_alert("Calibration essay saved.  Fetching the next essay.");
        return _this.is_calibrated_check();
      });
      this.interstitial_page_button.click(function() {
        _this.interstitial_page.hide();
        return _this.is_calibrated_check();
      });
      this.calibration_interstitial_page_button.click(function() {
        _this.calibration_interstitial_page.hide();
        return _this.is_calibrated_check();
      });
      this.flag_student_checkbox.click(function() {
        return _this.flag_box_checked();
      });
      this.calibration_feedback_button.hide();
      this.calibration_feedback_panel.hide();
      this.error_container.hide();
      this.flag_submission_confirmation.hide();
      if (this.tracking_changes()) {
        this.change_tracker = new TrackChanges(this.el);
      }
      this.is_calibrated_check();
    }

    PeerGradingProblem.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    PeerGradingProblem.prototype.is_calibrated_check = function() {
      return this.backend.post('is_student_calibrated', {
        location: this.location
      }, this.calibration_check_callback);
    };

    PeerGradingProblem.prototype.fetch_calibration_essay = function() {
      return this.backend.post('show_calibration_essay', {
        location: this.location
      }, this.render_calibration);
    };

    PeerGradingProblem.prototype.fetch_submission_essay = function() {
      return this.backend.post('get_next_submission', {
        location: this.location
      }, this.render_submission);
    };

    PeerGradingProblem.prototype.construct_data = function() {
      var data, feedback_content;
      if (this.tracking_changes()) {
        feedback_content = this.feedback_area.html();
      } else {
        feedback_content = this.feedback_area.val();
      }
      data = {
        rubric_scores: this.rub.get_score_list(),
        score: this.rub.get_total_score(),
        location: this.location,
        submission_id: this.essay_id_input.val(),
        submission_key: this.submission_key_input.val(),
        feedback: feedback_content,
        submission_flagged: this.flag_student_checkbox.is(':checked'),
        answer_unknown: false
      };
      return data;
    };

    PeerGradingProblem.prototype.submit_calibration_essay = function() {
      var data;
      data = this.construct_data();
      this.submit_button.hide();
      return this.backend.post('save_calibration_essay', data, this.calibration_callback);
    };

    PeerGradingProblem.prototype.submit_grade = function() {
      var data;
      data = this.construct_data();
      this.submit_button.hide();
      return this.backend.post('save_grade', data, this.submission_callback);
    };

    PeerGradingProblem.prototype.remove_flag = function() {
      this.flag_student_checkbox.removeAttr("checked");
      this.close_dialog_box();
      return this.submit_button.attr('disabled', true);
    };

    PeerGradingProblem.prototype.close_dialog_box = function() {
      return $(this.flag_submission_confirmation_sel).dialog('close');
    };

    PeerGradingProblem.prototype.flag_box_checked = function() {
      if (this.flag_student_checkbox.is(':checked')) {
        this.$(this.flag_submission_confirmation_sel).dialog({
          height: 400,
          width: 400
        });
        return this.submit_button.attr('disabled', false);
      }
    };

    PeerGradingProblem.prototype.calibration_check_callback = function(response) {
      if (response.success) {
        if (response.calibrated && (this.calibration === null || this.calibration === false)) {
          this.calibration = false;
          return this.fetch_submission_essay();
        } else if (response.calibrated && this.calibration === true) {
          this.calibration = false;
          return this.render_interstitial_page();
        } else if (!response.calibrated && this.calibration === null) {
          this.calibration = true;
          return this.render_calibration_interstitial_page();
        } else {
          this.calibration = true;
          return this.fetch_calibration_essay();
        }
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("Error contacting the grading service");
      }
    };

    PeerGradingProblem.prototype.calibration_callback = function(response) {
      if (response.success) {
        return this.render_calibration_feedback(response);
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("Error saving calibration score");
      }
    };

    PeerGradingProblem.prototype.submission_callback = function(response) {
      var message;
      if (response.success) {
        this.is_calibrated_check();
        this.grading_message.fadeIn();
        message = "<p>Successfully saved your feedback. Fetching the next essay.";
        if (response.required_done) {
          message = message + " You have done the required number of peer assessments but may continue grading if you like.";
        }
        message = message + "</p>";
        return this.grading_message.html(message);
      } else {
        if (response.error) {
          return this.render_error(response.error);
        } else {
          return this.render_error("Error occurred while submitting grade");
        }
      }
    };

    PeerGradingProblem.prototype.graded_callback = function(event) {
      var ev, ul;
      ev = this.$(event.target).parent().parent();
      ul = ev.parent().parent();
      ul.find(".rubric-label-selected").removeClass('rubric-label-selected');
      ev.addClass('rubric-label-selected');
      if (this.rub.check_complete()) {
        this.grading_message.hide();
        this.show_submit_button();
        return this.grade = this.rub.get_total_score();
      }
    };

    PeerGradingProblem.prototype.keydown_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === false) {
        return this.is_ctrl = true;
      } else if (event.which === 13 && this.submit_button.is(':visible') && this.is_ctrl === true) {
        if (this.calibration) {
          return this.submit_calibration_essay();
        } else {
          return this.submit_grade();
        }
      }
    };

    PeerGradingProblem.prototype.keyup_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === true) {
        return this.is_ctrl = false;
      }
    };

    PeerGradingProblem.prototype.render_calibration = function(response) {
      var feedback_text;
      if (response.success) {
        this.submission_container.html("");
        this.render_submission_data(response);
        this.calibration_panel.addClass('current-state');
        this.grading_panel.removeClass('current-state');
        this.calibration_panel.find(this.calibration_text_sel).show();
        this.grading_panel.find(this.calibration_text_sel).show();
        this.calibration_panel.find(this.grading_text_sel).hide();
        this.grading_panel.find(this.grading_text_sel).hide();
        this.flag_student_container.hide();
        this.peer_grading_instructions.hide();
        this.feedback_area.attr('disabled', true);
        feedback_text = "Once you are done learning to grade, and are grading your peers' work, you will be asked to share written feedback with them in addition to scoring them.";
        if (this.tracking_changes()) {
          this.ice_legend.hide();
          this.feedback_area.attr('contenteditable', false);
          this.feedback_area.text(feedback_text);
        } else {
          this.feedback_area.val(feedback_text);
        }
        this.submit_button.show();
        this.submit_button.unbind('click');
        this.submit_button.click(this.submit_calibration_essay);
        this.submit_button.attr('disabled', true);
        return this.scroll_to_top();
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("An error occurred while retrieving the next calibration essay");
      }
    };

    PeerGradingProblem.prototype.tracking_changes = function() {
      return this.grading_wrapper.data('track-changes') === true;
    };

    PeerGradingProblem.prototype.render_submission = function(response) {
      if (response.success) {
        this.submit_button.hide();
        this.submission_container.html("");
        this.render_submission_data(response);
        this.calibration_panel.removeClass('current-state');
        this.grading_panel.addClass('current-state');
        this.calibration_panel.find(this.calibration_text_sel).hide();
        this.grading_panel.find(this.calibration_text_sel).hide();
        this.calibration_panel.find(this.grading_text_sel).show();
        this.grading_panel.find(this.grading_text_sel).show();
        this.flag_student_container.show();
        this.peer_grading_instructions.show();
        if (this.tracking_changes()) {
          this.ice_legend.show();
          this.feedback_area.html(this.make_paragraphs(response.student_response));
          this.change_tracker.rebindTracker();
        } else {
          this.feedback_area.val("");
        }
        this.feedback_area.attr('disabled', false);
        this.flag_student_checkbox.removeAttr("checked");
        this.submit_button.show();
        this.submit_button.unbind('click');
        this.submit_button.click(this.submit_grade);
        this.submit_button.attr('disabled', true);
        return this.scroll_to_top();
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("An error occurred when retrieving the next submission.");
      }
    };

    PeerGradingProblem.prototype.make_paragraphs = function(text) {
      var new_text, paragraph, paragraph_split, _i, _len;
      paragraph_split = text.split(/\n\s*\n/);
      new_text = '';
      for (_i = 0, _len = paragraph_split.length; _i < _len; _i++) {
        paragraph = paragraph_split[_i];
        new_text += "<p>" + paragraph + "</p>";
      }
      return new_text;
    };

    PeerGradingProblem.prototype.render_submission_data = function(response) {
      this.content_panel.show();
      this.error_container.hide();
      this.submission_container.append(this.make_paragraphs(response.student_response));
      this.prompt_container.html(response.prompt);
      this.rubric_selection_container.html(response.rubric);
      this.submission_key_input.val(response.submission_key);
      this.essay_id_input.val(response.submission_id);
      this.setup_score_selection(response.max_score);
      this.submit_button.hide();
      this.action_button.hide();
      this.calibration_feedback_panel.hide();
      this.rub = new Rubric(this.el);
      return this.rub.initialize(this.location);
    };

    PeerGradingProblem.prototype.render_calibration_feedback = function(response) {
      var actual_score, calibration_wrapper, score;
      this.calibration_feedback_panel.slideDown();
      calibration_wrapper = this.$(this.calibration_feedback_wrapper_sel);
      calibration_wrapper.html("<p>The score you gave was: " + this.grade + ". The instructor score is: " + response.actual_score + "</p>");
      score = parseInt(this.grade);
      actual_score = parseInt(response.actual_score);
      if (score === actual_score) {
        calibration_wrapper.append("<p>Your score matches the instructor score!</p>");
      } else {
        calibration_wrapper.append("<p>You may want to review the rubric again.</p>");
      }
      if (response.actual_rubric !== void 0) {
        calibration_wrapper.append("<div>Instructor Scored Rubric: " + response.actual_rubric + "</div>");
      }
      if (response.actual_feedback.feedback !== void 0) {
        calibration_wrapper.append("<div>Instructor Feedback: " + response.actual_feedback + "</div>");
      }
      this.$("input[name='score-selection']").attr('disabled', true);
      this.submit_button.hide();
      return this.calibration_feedback_button.show();
    };

    PeerGradingProblem.prototype.render_interstitial_page = function() {
      this.content_panel.hide();
      this.grading_message.hide();
      return this.interstitial_page.show();
    };

    PeerGradingProblem.prototype.render_calibration_interstitial_page = function() {
      this.content_panel.hide();
      this.action_button.hide();
      return this.calibration_interstitial_page.show();
    };

    PeerGradingProblem.prototype.render_error = function(error_message) {
      this.error_container.show();
      this.calibration_feedback_panel.hide();
      this.error_container.html(error_message);
      this.content_panel.hide();
      return this.action_button.show();
    };

    PeerGradingProblem.prototype.show_submit_button = function() {
      this.submit_button.attr('disabled', false);
      return this.submit_button.show();
    };

    PeerGradingProblem.prototype.setup_score_selection = function(max_score) {
      return this.$("input[class='score-selection']").change(this.graded_callback);
    };

    PeerGradingProblem.prototype.gentle_alert = function(msg) {
      this.grading_message.fadeIn();
      return this.grading_message.html("<p>" + msg + "</p>");
    };

    PeerGradingProblem.prototype.collapse_question = function(event) {
      var new_text;
      this.prompt_container.slideToggle();
      this.prompt_container.toggleClass('open');
      if (this.question_header.text() === "Hide Question") {
        new_text = "Show Question";
        Logger.log('oe_hide_question', {
          location: this.location
        });
      } else {
        Logger.log('oe_show_question', {
          location: this.location
        });
        new_text = "Hide Question";
      }
      this.question_header.text(new_text);
      return false;
    };

    PeerGradingProblem.prototype.scroll_to_top = function() {
      return $('html, body').animate({
        scrollTop: $(".peer-grading").offset().top
      }, 200);
    };

    return PeerGradingProblem;

  })();

}).call(this);

(function (undefined) {
    'use strict';

    // [module Collapsible]
    //
    // [description]
    //     Set of library functions that provide a simple way to add
    //     collapsible functionality to elements.
    this.Collapsible = {
        setCollapsibles: setCollapsibles,
        toggleFull: toggleFull,
        toggleHint: toggleHint
    };

    return;

    // [function setCollapsibles]
    //
    // [description]
    //     Scan element's content for generic collapsible containers.
    //
    // [params]
    //     el: container
    function setCollapsibles(el) {
        var linkBottom, linkTop, short_custom;

        linkTop = '<a href="#" class="full full-top">查看全部输出内容</a>';
        linkBottom = '<a href="#" class="full full-bottom">查看全部输出内容</a>';

        // Standard longform + shortfom pattern.
        el.find('.longform').hide();
        el.find('.shortform').append(linkTop, linkBottom);

        // Custom longform + shortform text pattern.
        short_custom = el.find('.shortform-custom');

        // Set up each one individually.
        short_custom.each(function (index, elt) {
            var close_text, open_text;

            open_text = $(elt).data('open-text');
            close_text = $(elt).data('close-text');
            $(elt).append("<a href='#' class='full-custom'>" + open_text + "</a>");

            $(elt).find('.full-custom').click(function (event) {
                Collapsible.toggleFull(event, open_text, close_text);
            });
        });

        // Collapsible pattern.
        el.find('.collapsible header + section').hide();

        // Set up triggers.
        el.find('.full').click(function (event) {
            Collapsible.toggleFull(event, "查看全部输出内容", "隐藏输出内容");
        });
        el.find('.collapsible header a').click(Collapsible.toggleHint);
    }

    // [function toggleFull]
    //
    // [description]
    //     Toggle the display of full text for a collapsible element.
    //
    // [params]
    //     event: jQuery event object associated with the event that
    //         triggered this callback function.
    //     open_text: text that should be displayed when the collapsible
    //         is open.
    //     close_text: text that should be displayed when the collapsible
    //         is closed.
    function toggleFull(event, open_text, close_text) {
        var el, new_text, parent;

        event.preventDefault();

        parent = $(event.target).parent();
        parent.siblings().slideToggle();
        parent.parent().toggleClass('open');

        if ($(event.target).text() === open_text) {
            new_text = close_text;
        } else {
            new_text = open_text;
        }

        if ($(event.target).hasClass('full')) {
            el = parent.find('.full');
        } else {
            el = $(event.target);
        }

        el.text(new_text);
    }

    // [function toggleHint]
    //
    // [description]
    //     Toggle the collapsible open to show the hint.
    //
    // [params]
    //     event: jQuery event object associated with the event that
    //         triggered this callback function.
    function toggleHint(event) {
        event.preventDefault();

        $(event.target).parent().siblings().slideToggle();
        $(event.target).parent().parent().toggleClass('open');
    }
}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Annotatable = (function() {
    Annotatable.prototype._debug = false;

    Annotatable.prototype.wrapperSelector = '.annotatable-wrapper';

    Annotatable.prototype.toggleAnnotationsSelector = '.annotatable-toggle-annotations';

    Annotatable.prototype.toggleInstructionsSelector = '.annotatable-toggle-instructions';

    Annotatable.prototype.instructionsSelector = '.annotatable-instructions';

    Annotatable.prototype.sectionSelector = '.annotatable-section';

    Annotatable.prototype.spanSelector = '.annotatable-span';

    Annotatable.prototype.replySelector = '.annotatable-reply';

    Annotatable.prototype.problemXModuleSelector = '.xmodule_CapaModule';

    Annotatable.prototype.problemSelector = 'div.problem';

    Annotatable.prototype.problemInputSelector = 'div.problem .annotation-input';

    Annotatable.prototype.problemReturnSelector = 'div.problem .annotation-return';

    function Annotatable(el) {
      this.onMoveTip = __bind(this.onMoveTip, this);
      this.onShowTip = __bind(this.onShowTip, this);
      this.onClickReturn = __bind(this.onClickReturn, this);
      this.onClickReply = __bind(this.onClickReply, this);
      this.onClickToggleInstructions = __bind(this.onClickToggleInstructions, this);
      this.onClickToggleAnnotations = __bind(this.onClickToggleAnnotations, this);
      if (this._debug) {
        console.log('loaded Annotatable');
      }
      this.el = el;
      this.$el = $(el);
      this.init();
    }

    Annotatable.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Annotatable.prototype.init = function() {
      this.initEvents();
      return this.initTips();
    };

    Annotatable.prototype.initEvents = function() {
      var _ref;
      _ref = [false, false], this.annotationsHidden = _ref[0], this.instructionsHidden = _ref[1];
      this.$(this.toggleAnnotationsSelector).bind('click', this.onClickToggleAnnotations);
      this.$(this.toggleInstructionsSelector).bind('click', this.onClickToggleInstructions);
      this.$el.delegate(this.replySelector, 'click', this.onClickReply);
      return $('body').delegate(this.problemReturnSelector, 'click', this.onClickReturn);
    };

    Annotatable.prototype.initTips = function() {
      var _this = this;
      return this.$(this.spanSelector).each(function(index, el) {
        return $(el).qtip(_this.getSpanTipOptions(el));
      });
    };

    Annotatable.prototype.getSpanTipOptions = function(el) {
      return {
        content: {
          title: {
            text: this.makeTipTitle(el)
          },
          text: this.makeTipContent(el)
        },
        position: {
          my: 'bottom center',
          at: 'top center',
          target: $(el),
          container: this.$(this.wrapperSelector),
          adjust: {
            y: -5
          }
        },
        show: {
          event: 'click mouseenter',
          solo: true
        },
        hide: {
          event: 'click mouseleave',
          delay: 500,
          fixed: true
        },
        style: {
          classes: 'ui-tooltip-annotatable'
        },
        events: {
          show: this.onShowTip,
          move: this.onMoveTip
        }
      };
    };

    Annotatable.prototype.onClickToggleAnnotations = function(e) {
      return this.toggleAnnotations();
    };

    Annotatable.prototype.onClickToggleInstructions = function(e) {
      return this.toggleInstructions();
    };

    Annotatable.prototype.onClickReply = function(e) {
      return this.replyTo(e.currentTarget);
    };

    Annotatable.prototype.onClickReturn = function(e) {
      return this.returnFrom(e.currentTarget);
    };

    Annotatable.prototype.onShowTip = function(event, api) {
      if (this.annotationsHidden) {
        return event.preventDefault();
      }
    };

    Annotatable.prototype.onMoveTip = function(event, api, position) {
      /*
      This method handles an edge case in which a tooltip is displayed above
      a non-overlapping span like this:
      
                           (( TOOLTIP ))
                                \/
      text text text ... text text text ...... <span span span>
      <span span span>
      
      The problem is that the tooltip looks disconnected from both spans, so
      we should re-position the tooltip to appear above the span.
      */

      var adjust_y, container, container_offset, focus_rect, is_non_overlapping, offset_left, offset_top, rect_center, rect_top, rects, target, tip, tip_height, tip_left, tip_top, tip_width, win_width, _ref, _ref1, _ref2;
      tip = api.elements.tooltip;
      adjust_y = ((_ref = api.options.position) != null ? (_ref1 = _ref.adjust) != null ? _ref1.y : void 0 : void 0) || 0;
      container = ((_ref2 = api.options.position) != null ? _ref2.container : void 0) || $('body');
      target = api.elements.target;
      rects = $(target).get(0).getClientRects();
      is_non_overlapping = (rects != null ? rects.length : void 0) === 2 && rects[0].left > rects[1].right;
      if (is_non_overlapping) {
        focus_rect = (rects[0].width > rects[1].width ? rects[0] : rects[1]);
        rect_center = focus_rect.left + (focus_rect.width / 2);
        rect_top = focus_rect.top;
        tip_width = $(tip).width();
        tip_height = $(tip).height();
        container_offset = $(container).offset();
        offset_left = -container_offset.left;
        offset_top = $(document).scrollTop() - container_offset.top;
        tip_left = offset_left + rect_center - (tip_width / 2);
        tip_top = offset_top + rect_top - tip_height + adjust_y;
        win_width = $(window).width();
        if (tip_left < offset_left) {
          tip_left = offset_left;
        } else if (tip_left + tip_width > win_width + offset_left) {
          tip_left = win_width + offset_left - tip_width;
        }
        return $.extend(position, {
          'left': tip_left,
          'top': tip_top
        });
      }
    };

    Annotatable.prototype.getSpanForProblemReturn = function(el) {
      var problem_id;
      problem_id = $(this.problemReturnSelector).index(el);
      return this.$(this.spanSelector).filter("[data-problem-id='" + problem_id + "']");
    };

    Annotatable.prototype.getProblem = function(el) {
      var problem_id;
      problem_id = this.getProblemId(el);
      return $(this.problemSelector).has(this.problemInputSelector).eq(problem_id);
    };

    Annotatable.prototype.getProblemId = function(el) {
      return $(el).data('problem-id');
    };

    Annotatable.prototype.toggleAnnotations = function() {
      var hide;
      hide = (this.annotationsHidden = !this.annotationsHidden);
      this.toggleAnnotationButtonText(hide);
      this.toggleSpans(hide);
      return this.toggleTips(hide);
    };

    Annotatable.prototype.toggleTips = function(hide) {
      var visible;
      visible = this.findVisibleTips();
      return this.hideTips(visible);
    };

    Annotatable.prototype.toggleAnnotationButtonText = function(hide) {
      var buttonText;
      if (hide) {
        buttonText = gettext('Show Annotations');
      } else {
        buttonText = gettext('Hide Annotations');
      }
      return this.$(this.toggleAnnotationsSelector).text(buttonText);
    };

    Annotatable.prototype.toggleInstructions = function() {
      var hide;
      hide = (this.instructionsHidden = !this.instructionsHidden);
      this.toggleInstructionsButton(hide);
      return this.toggleInstructionsText(hide);
    };

    Annotatable.prototype.toggleInstructionsButton = function(hide) {
      var cls, txt;
      if (hide) {
        txt = gettext('Expand Instructions');
      } else {
        txt = gettext('Collapse Instructions');
      }
      cls = (hide ? ['expanded', 'collapsed'] : ['collapsed', 'expanded']);
      return this.$(this.toggleInstructionsSelector).text(txt).removeClass(cls[0]).addClass(cls[1]);
    };

    Annotatable.prototype.toggleInstructionsText = function(hide) {
      var slideMethod;
      slideMethod = (hide ? 'slideUp' : 'slideDown');
      return this.$(this.instructionsSelector)[slideMethod]();
    };

    Annotatable.prototype.toggleSpans = function(hide) {
      return this.$(this.spanSelector).toggleClass('hide', hide, 250);
    };

    Annotatable.prototype.replyTo = function(buttonEl) {
      var el, offset;
      offset = -20;
      el = this.getProblem(buttonEl);
      if (el.length > 0) {
        return this.scrollTo(el, this.afterScrollToProblem, offset);
      } else {
        if (this._debug) {
          return console.log('problem not found. event: ', e);
        }
      }
    };

    Annotatable.prototype.returnFrom = function(buttonEl) {
      var el, offset;
      offset = -200;
      el = this.getSpanForProblemReturn(buttonEl);
      if (el.length > 0) {
        return this.scrollTo(el, this.afterScrollToSpan, offset);
      } else {
        if (this._debug) {
          return console.log('span not found. event:', e);
        }
      }
    };

    Annotatable.prototype.scrollTo = function(el, after, offset) {
      var _this = this;
      if (offset == null) {
        offset = -20;
      }
      if ($(el).length > 0) {
        return $('html,body').scrollTo(el, {
          duration: 500,
          onAfter: this._once(function() {
            return after != null ? after.call(_this, el) : void 0;
          }),
          offset: offset
        });
      }
    };

    Annotatable.prototype.afterScrollToProblem = function(problem_el) {
      return problem_el.effect('highlight', {}, 500);
    };

    Annotatable.prototype.afterScrollToSpan = function(span_el) {
      return span_el.addClass('selected', 400, 'swing', function() {
        return span_el.removeClass('selected', 400, 'swing');
      });
    };

    Annotatable.prototype.makeTipContent = function(el) {
      var _this = this;
      return function(api) {
        var comment, problem_id, reply, text;
        text = $(el).data('comment-body');
        comment = _this.createComment(text);
        problem_id = _this.getProblemId(el);
        reply = _this.createReplyLink(problem_id);
        return $(comment).add(reply);
      };
    };

    Annotatable.prototype.makeTipTitle = function(el) {
      var _this = this;
      return function(api) {
        var title;
        title = $(el).data('comment-title');
        if (title) {
          return title;
        } else {
          return gettext('Commentary');
        }
      };
    };

    Annotatable.prototype.createComment = function(text) {
      return $("<div class=\"annotatable-comment\">" + text + "</div>");
    };

    Annotatable.prototype.createReplyLink = function(problem_id) {
      var linktxt;
      linktxt = gettext('Reply to Annotation');
      return $("<a class=\"annotatable-reply\" href=\"javascript:void(0);\" data-problem-id=\"" + problem_id + "\">" + linktxt + "</a>");
    };

    Annotatable.prototype.findVisibleTips = function() {
      var visible;
      visible = [];
      this.$(this.spanSelector).each(function(index, el) {
        var api, tip;
        api = $(el).qtip('api');
        tip = $(api != null ? api.elements.tooltip : void 0);
        if (tip.is(':visible')) {
          return visible.push(el);
        }
      });
      return visible;
    };

    Annotatable.prototype.hideTips = function(elements) {
      return $(elements).qtip('hide');
    };

    Annotatable.prototype._once = function(fn) {
      var done,
        _this = this;
      done = false;
      return function() {
        if (!done) {
          fn.call(_this);
        }
        return done = true;
      };
    };

    return Annotatable;

  })();

}).call(this);

(function (requirejs, require, define) {

define(
'video/00_resizer.js',
[],
function () {

    var Resizer = function (params) {
        var defaults = {
                container: window,
                element: null,
                containerRatio: null,
                elementRatio: null
            },
            callbacksList = [],
            delta = {
                height: 0,
                width: 0
            },
            module = {},
            mode = null,
            config;

        var initialize = function (params) {
            if (!config) {
                config = defaults;
            }

            config = $.extend(true, {}, config, params);

            if (!config.element) {
                console.log(
                    'Required parameter `element` is not passed.'
                );
            }

            return module;
        };

        var getData = function () {
            var container = $(config.container),
                containerWidth = container.width() + delta.width,
                containerHeight = container.height() + delta.height,
                containerRatio = config.containerRatio,

                element = $(config.element),
                elementRatio = config.elementRatio;

            if (!containerRatio) {
                containerRatio = containerWidth/containerHeight;
            }

            if (!elementRatio) {
                elementRatio = element.width()/element.height();
            }

            return {
                containerWidth: containerWidth,
                containerHeight: containerHeight,
                containerRatio: containerRatio,
                element: element,
                elementRatio: elementRatio
            };
        };

        var align = function () {
            var data = getData();

            switch (mode) {
                case 'height':
                    alignByHeightOnly();
                    break;

                case 'width':
                    alignByWidthOnly();
                    break;

                default:
                    if (data.containerRatio >= data.elementRatio) {
                        alignByHeightOnly();
                    } else {
                        alignByWidthOnly();
                    }
                    break;
            }

            fireCallbacks();

            return module;
        };

        var alignByWidthOnly = function () {
            var data = getData(),
                height = data.containerWidth/data.elementRatio;

            data.element.css({
                'height': height,
                'width': data.containerWidth,
                'top': 0.5*(data.containerHeight - height),
                'left': 0
            });

            return module;
        };

        var alignByHeightOnly = function () {
            var data = getData(),
                width = data.containerHeight*data.elementRatio;

            data.element.css({
                'height': data.containerHeight,
                'width': data.containerHeight*data.elementRatio,
                'top': 0,
                'left': 0
            });

            return module;
        };

        var setMode = function (param) {
            if (_.isString(param)) {
                mode = param;
                align();
            }

            return module;
        };

        var setElement = function (element) {
            config.element = element;

            return module;
        };

        var addCallback = function (func) {
            if ($.isFunction(func)) {
                callbacksList.push(func);
            } else {
                console.error('[Video info]: TypeError: Argument is not a function.');
            }

            return module;
        };

        var addOnceCallback = function (func) {
            if ($.isFunction(func)) {
                var decorator = function () {
                    func();
                    removeCallback(func);
                };

                addCallback(decorator);
            } else {
                console.error('TypeError: Argument is not a function.');
            }

            return module;
        };

        var fireCallbacks = function () {
            $.each(callbacksList, function(index, callback) {
                 callback();
            });
        };

        var removeCallbacks = function () {
            callbacksList.length = 0;

            return module;
        };

        var removeCallback = function (func) {
            var index = $.inArray(func, callbacksList);

            if (index !== -1) {
                return callbacksList.splice(index, 1);
            }
        };

        var cleanDelta = function () {
            delta['height'] = 0;
            delta['width'] = 0;

            return module;
        };

        var addDelta = function (value, side) {
            if (_.isNumber(value) && _.isNumber(delta[side])) {
                delta[side] += value;
            }

            return module;
        };

        var substractDelta = function (value, side) {
            if (_.isNumber(value) && _.isNumber(delta[side])) {
                delta[side] -= value;
            }

            return module;
        };

        initialize.apply(module, arguments);

        return $.extend(true, module, {
            align: align,
            alignByWidthOnly: alignByWidthOnly,
            alignByHeightOnly: alignByHeightOnly,
            setParams: initialize,
            setMode: setMode,
            setElement: setElement,
            callbacks: {
                add: addCallback,
                once: addOnceCallback,
                remove: removeCallback,
                removeAll: removeCallbacks
            },
            delta: {
                add: addDelta,
                substract: substractDelta,
                reset: cleanDelta
            }
        });
    };

    return Resizer;
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Generated by CoffeeScript 1.6.3
(function() {
  this.JavascriptLoader = (function() {
    function JavascriptLoader() {}

    JavascriptLoader.executeModuleScripts = function(el, callback) {
      var callbackCalled, completed, completionHandlerGenerator, completionHandlerGeneratorIE, i, loaded, placeholders,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      placeholders = el.find(".script_placeholder");
      if (placeholders.length === 0) {
        if (callback != null) {
          callback();
        }
        return;
      }
      completed = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = placeholders.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(false);
        }
        return _results;
      })();
      callbackCalled = false;
      completionHandlerGeneratorIE = function(index) {
        return function() {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            return completionHandlerGenerator(index)();
          }
        };
      };
      completionHandlerGenerator = function(index) {
        return function() {
          var allComplete, flag, _i, _len;
          allComplete = true;
          completed[index] = true;
          for (_i = 0, _len = completed.length; _i < _len; _i++) {
            flag = completed[_i];
            if (!flag) {
              allComplete = false;
              break;
            }
          }
          if (allComplete && !callbackCalled) {
            callbackCalled = true;
            if (callback != null) {
              return callback();
            }
          }
        };
      };
      loaded = {};
      return placeholders.each(function(index, placeholder) {
        var s, src;
        src = $(placeholder).attr("data-src");
        if (!(src in loaded)) {
          loaded[src] = true;
          s = document.createElement('script');
          s.setAttribute('src', src);
          s.setAttribute('type', "text/javascript");
          s.onload = completionHandlerGenerator(index);
          s.onreadystatechange = completionHandlerGeneratorIE(index);
          $('head')[0].appendChild(s);
        } else {
          completionHandlerGenerator(index)();
        }
        return $(placeholder).remove();
      });
    };

    return JavascriptLoader;

  })();

}).call(this);

(function (requirejs, require, define) {
define('PollMain', [], function () {

PollMain.prototype = {

'showAnswerGraph': function (poll_answers, total) {
    var _this, totalValue;

    totalValue = parseFloat(total);
    if (isFinite(totalValue) === false) {
        return;
    }

    _this = this;

    $.each(poll_answers, function (index, value) {
        var numValue, percentValue;

        numValue = parseFloat(value);
        if (isFinite(numValue) === false) {
            return;
        }

        percentValue = (numValue / totalValue) * 100.0;

        _this.answersObj[index].statsEl.show();
        _this.answersObj[index].numberEl.html('' + value + ' (' + percentValue.toFixed(1) + '%)');
        _this.answersObj[index].percentEl.css({
            'width': '' + percentValue.toFixed(1) + '%'
        });
    });
},

'submitAnswer': function (answer, answerObj) {
    var _this;

    // Make sure that the user can answer a question only once.
    if (this.questionAnswered === true) {
        return;
    }
    this.questionAnswered = true;

    _this = this;

    console.log('submit answer');

    answerObj.buttonEl.addClass('answered');

    // Send the data to the server as an AJAX request. Attach a callback that will
    // be fired on server's response.
    $.postWithPrefix(
        _this.ajax_url + '/' + answer,  {},
        function (response) {
            console.log('success! response = ');
            console.log(response);

            _this.showAnswerGraph(response.poll_answers, response.total);

            if (_this.canReset === true) {
                _this.resetButton.show();
            }

            // Initialize Conditional constructors.
            if (_this.wrapperSectionEl !== null) {
                $(_this.wrapperSectionEl).find('.xmodule_ConditionalModule').each(function (index, value) {
                    new window.Conditional(value, _this.id.replace(/^poll_/, ''));
                });
            }
        }
    );

}, // End-of: 'submitAnswer': function (answer, answerEl) {


'submitReset': function () {
    var _this;

    _this = this;

    console.log('submit reset');

    // Send the data to the server as an AJAX request. Attach a callback that will
    // be fired on server's response.
    $.postWithPrefix(
        this.ajax_url + '/' + 'reset_poll',
        {},
        function (response) {
            console.log('success! response = ');
            console.log(response);

            if (
                (response.hasOwnProperty('status') !== true) ||
                (typeof response.status !== 'string') ||
                (response.status.toLowerCase() !== 'success')) {
                return;
            }

            _this.questionAnswered = false;
            _this.questionEl.find('.button.answered').removeClass('answered');
            _this.questionEl.find('.stats').hide();
            _this.resetButton.hide();

            // Initialize Conditional constructors. We will specify the third parameter as 'true'
            // notifying the constructor that this is a reset operation.
            if (_this.wrapperSectionEl !== null) {
                $(_this.wrapperSectionEl).find('.xmodule_ConditionalModule').each(function (index, value) {
                    new window.Conditional(value, _this.id.replace(/^poll_/, ''));
                });
            }
        }
    );
}, // End-of: 'submitAnswer': function (answer, answerEl) {

'postInit': function () {
    var _this;

    // Access this object inside inner functions.
    _this = this;

    if (
        (this.jsonConfig.poll_answer.length > 0) &&
        (this.jsonConfig.answers.hasOwnProperty(this.jsonConfig.poll_answer) === false)
    ) {
        this.questionEl.append(
            '<h3>Error!</h3>' +
            '<p>XML data format changed. List of answers was modified, but poll data was not updated.</p>'
        );

        return;
    }

    // Get the DOM id of the question.
    this.id = this.questionEl.attr('id');

    // Get the URL to which we will post the users answer to the question.
    this.ajax_url = this.questionEl.data('ajax-url');

    this.questionHtmlMarkup = $('<div />').html(this.jsonConfig.question).text();
    this.questionEl.append(this.questionHtmlMarkup);

    // When the user selects and answer, we will set this flag to true.
    this.questionAnswered = false;

    this.answersObj = {};
    this.shortVersion = true;

    $.each(this.jsonConfig.answers, function (index, value) {
        if (value.length >= 18) {
            _this.shortVersion = false;
        }
    });

    $.each(this.jsonConfig.answers, function (index, value) {
        var answer;

        answer = {};

        _this.answersObj[index] = answer;

        answer.el = $('<div class="poll_answer"></div>');

        answer.questionEl = $('<div class="question"></div>');
        answer.buttonEl = $('<div class="button"></div>');
        answer.textEl = $('<div class="text"></div>');
        answer.questionEl.append(answer.buttonEl);
        answer.questionEl.append(answer.textEl);

        answer.el.append(answer.questionEl);

        answer.statsEl = $('<div class="stats"></div>');
        answer.barEl = $('<div class="bar"></div>');
        answer.percentEl = $('<div class="percent"></div>');
        answer.barEl.append(answer.percentEl);
        answer.numberEl = $('<div class="number"></div>');
        answer.statsEl.append(answer.barEl);
        answer.statsEl.append(answer.numberEl);

        answer.statsEl.hide();

        answer.el.append(answer.statsEl);

        answer.textEl.html(value);

        if (_this.shortVersion === true) {
            $.each(answer, function (index, value) {
                if (value instanceof jQuery) {
                    value.addClass('short');
                }
            });
        }

        answer.el.appendTo(_this.questionEl);

        answer.textEl.on('click', function () {
            _this.submitAnswer(index, answer);
        });

        answer.buttonEl.on('click', function () {
            _this.submitAnswer(index, answer);
        });

        if (index === _this.jsonConfig.poll_answer) {
            answer.buttonEl.addClass('answered');
            _this.questionAnswered = true;
        }
    });

    console.log(this.jsonConfig.reset);

    if ((typeof this.jsonConfig.reset === 'string') && (this.jsonConfig.reset.toLowerCase() === 'true')) {
        this.canReset = true;

        this.resetButton = $('<div class="button reset-button">Change your vote</div>');

        if (this.questionAnswered === false) {
            this.resetButton.hide();
        }

        this.resetButton.appendTo(this.questionEl);

        this.resetButton.on('click', function () {
            _this.submitReset();
        });
    } else {
        this.canReset = false;
    }

    // If it turns out that the user already answered the question, show the answers graph.
    if (this.questionAnswered === true) {
        this.showAnswerGraph(this.jsonConfig.poll_answers, this.jsonConfig.total);
    }
} // End-of: 'postInit': function () {
}; // End-of: PollMain.prototype = {

return PollMain;

function PollMain(el) {
    var _this;

    this.questionEl = $(el).find('.poll_question');
    if (this.questionEl.length !== 1) {
        // We require one question DOM element.
        console.log('ERROR: PollMain constructor requires one question DOM element.');

        return;
    }

    // Just a safety precussion. If we run this code more than once, multiple 'click' callback handlers will be
    // attached to the same DOM elements. We don't want this to happen.
    if (this.questionEl.attr('poll_main_processed') === 'true') {
        console.log(
            'ERROR: PolMain JS constructor was called on a DOM element that has already been processed once.'
        );

        return;
    }

    // This element was not processed earlier.
    // Make sure that next time we will not process this element a second time.
    this.questionEl.attr('poll_main_processed', 'true');

    // Access this object inside inner functions.
    _this = this;

    // DOM element which contains the current poll along with any conditionals. By default we assume that such
    // element is not present. We will try to find it.
    this.wrapperSectionEl = null;

    (function (tempEl, c1) {
        while (tempEl.tagName.toLowerCase() !== 'body') {
            tempEl = $(tempEl).parent()[0];
            c1 += 1;

            if (
                (tempEl.tagName.toLowerCase() === 'div') &&
                ($(tempEl).hasClass('xmodule_WrapperModule') === true)
            ) {
                _this.wrapperSectionEl = tempEl;

                break;
            } else if (c1 > 50) {
                // In case something breaks, and we enter an endless loop, a sane
                // limit for loop iterations.

                break;
            }
        }
    }($(el)[0], 0));

    try {
        this.jsonConfig = JSON.parse(this.questionEl.children('.poll_question_div').html());

        $.postWithPrefix(
            '' + this.questionEl.data('ajax-url') + '/' + 'get_state',  {},
            function (response) {
                _this.jsonConfig.poll_answer = response.poll_answer;
                _this.jsonConfig.total = response.total;

                $.each(response.poll_answers, function (index, value) {
                    _this.jsonConfig.poll_answers[index] = value;
                });

                _this.questionEl.children('.poll_question_div').html(JSON.stringify(_this.jsonConfig));

                _this.postInit();
            }
        );

        return;
    } catch (err) {
        console.log(
            'ERROR: Invalid JSON config for poll ID "' + this.id + '".',
            'Error messsage: "' + err.message + '".'
        );

        return;
    }
} // End-of: function PollMain(el) {

}); // End-of: define('PollMain', [], function () {

// End-of: (function (requirejs, require, define) {
}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

$(function() {
  
  // Set up on page load
  $("a.modal-content").each(function() {
    var smallImageObject = $(this).children();
    var largeImageSRC = $(this).attr('href');
    
    // if contents of zoomable link is image and large image link exists: setup modal
    if (smallImageObject.is('img') && largeImageSRC) {
      var data = {
        "smallHTML": $(this).html(),
        "largeALT": smallImageObject.attr('alt'),
        "largeSRC": largeImageSRC
      };
      var html = _.template($("#image-modal-tpl").text(), data);
      $(this).replaceWith(html);
    }
  });
  $('.wrapper-modal-image .image-wrapper img').each(function() {
    var draggie = new Draggabilly(this, {containment: true});
    draggie.disable();
    $(this).closest('.image-modal').data("draggie", draggie);
  });

  // Opening and closing image modal on clicks
  $(".wrapper-modal-image .image-link").click(function() {
    $(this).siblings(".image-modal").addClass('image-is-fit-to-screen');
    $('body').css('overflow', 'hidden');
  });
  
  // variable to detect when modal is being "hovered".
  // Done this way as jquery doesn't support the :hover psudo-selector as expected.
  var imageModalImageHover = false;
  $(".wrapper-modal-image .image-content img, .wrapper-modal-image .image-content .image-controls").hover(function() {
    imageModalImageHover = true;
  }, function() {
    imageModalImageHover = false;
  });
  
  // prevent image control button links from scrolling
  $(".modal-ui-icon").click(function(event) {
    event.preventDefault();
  });
  
  //Define function to close modal
  function closeModal(imageModal) {
    imageModal.removeClass('image-is-fit-to-screen').removeClass('image-is-zoomed');
    $(".wrapper-modal-image .image-content .image-controls .modal-ui-icon.action-zoom-in").removeClass('is-disabled');
    $(".wrapper-modal-image .image-content .image-controls .modal-ui-icon.action-zoom-out").addClass('is-disabled');
    var currentDraggie = imageModal.data("draggie");
    currentDraggie.disable();
    $('body').css('overflow', 'auto');
  }
  
  // Click outside of modal to close it.
  $(".wrapper-modal-image .image-modal").click(function() {
    if (!imageModalImageHover){
      closeModal($(this));
    }
  });
  
  // Click close icon to close modal.
  $(".wrapper-modal-image .image-content .action-remove").click(function() {
    closeModal($(this).closest(".image-modal"));
  });

  // zooming image in modal and allow it to be dragged
  // Make sure it always starts zero position for below calcs to work
  $(".wrapper-modal-image .image-content .image-controls .modal-ui-icon").click(function() {
    if (!$(this).hasClass('is-disabled')) {
      var mask = $(this).closest(".image-content");
      
      var imageModal = $(this).closest(".image-modal");
      var img = imageModal.find("img");
      var currentDraggie = imageModal.data("draggie");
      
      if ($(this).hasClass('action-zoom-in')) {
        imageModal.removeClass('image-is-fit-to-screen').addClass('image-is-zoomed');
        
        var imgWidth   = img.width();
        var imgHeight  = img.height();
        
        var imgContainerOffsetLeft = imgWidth - mask.width();
        var imgContainerOffsetTop = imgHeight - mask.height();
        var imgContainerWidth = imgWidth + imgContainerOffsetLeft;
        var imgContainerHeight = imgHeight + imgContainerOffsetTop;
        
        // Set the width and height of the image's container so that the dimensions are equal to the image dimensions + view area dimensions to limit dragging
        // Set image container top and left to center image at load.
        img.parent().css({
          left: -imgContainerOffsetLeft,
          top: -imgContainerOffsetTop,
          width: imgContainerWidth,
          height: imgContainerHeight
        });
        img.css({top: imgContainerOffsetTop / 2, left: imgContainerOffsetLeft / 2});
        
        currentDraggie.enable();
        
      } else if ($(this).hasClass('action-zoom-out')) {
        imageModal.removeClass('image-is-zoomed').addClass('image-is-fit-to-screen');
        
        currentDraggie.disable();
      }
      
      $(".wrapper-modal-image .image-content .image-controls .modal-ui-icon").toggleClass('is-disabled');
    }
  });
});
/*
 * Word cloud layout by Jason Davies
 * https://github.com/jasondavies/d3-cloud
 * 
 *
 * Copyright (c) 2012, Jason Davies.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *   * The name Jason Davies may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
(function(exports) {
  function cloud() {
    var size = [256, 256],
        text = cloudText,
        font = cloudFont,
        fontSize = cloudFontSize,
        fontStyle = cloudFontNormal,
        fontWeight = cloudFontNormal,
        rotate = cloudRotate,
        padding = cloudPadding,
        spiral = archimedeanSpiral,
        words = [],
        timeInterval = Infinity,
        event = d3.dispatch("word", "end"),
        timer = null,
        cloud = {};

    cloud.start = function() {
      var board = zeroArray((size[0] >> 5) * size[1]),
          bounds = null,
          n = words.length,
          i = -1,
          tags = [],
          data = words.map(function(d, i) {
            d.text = text.call(this, d, i);
            d.font = font.call(this, d, i);
            d.style = fontStyle.call(this, d, i);
            d.weight = fontWeight.call(this, d, i);
            d.rotate = rotate.call(this, d, i);
            d.size = ~~fontSize.call(this, d, i);
            d.padding = cloudPadding.call(this, d, i);
            return d;
          }).sort(function(a, b) { return b.size - a.size; });

      if (timer) clearInterval(timer);
      timer = setInterval(step, 0);
      step();

      return cloud;

      function step() {
        var start = +new Date,
            d;
        while (+new Date - start < timeInterval && ++i < n && timer) {
          d = data[i];
          d.x = (size[0] * (Math.random() + .5)) >> 1;
          d.y = (size[1] * (Math.random() + .5)) >> 1;
          cloudSprite(d, data, i);
          if (place(board, d, bounds)) {
            tags.push(d);
            event.word(d);
            if (bounds) cloudBounds(bounds, d);
            else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];
            // Temporary hack
            d.x -= size[0] >> 1;
            d.y -= size[1] >> 1;
          }
        }
        if (i >= n) {
          cloud.stop();
          event.end(tags, bounds);
        }
      }
    }

    cloud.stop = function() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      return cloud;
    };

    cloud.timeInterval = function(x) {
      if (!arguments.length) return timeInterval;
      timeInterval = x == null ? Infinity : x;
      return cloud;
    };

    function place(board, tag, bounds) {
      var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
          startX = tag.x,
          startY = tag.y,
          maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
          s = spiral(size),
          dt = Math.random() < .5 ? 1 : -1,
          t = -dt,
          dxdy,
          dx,
          dy;

      while (dxdy = s(t += dt)) {
        dx = ~~dxdy[0];
        dy = ~~dxdy[1];

        if (Math.min(dx, dy) > maxDelta) break;

        tag.x = startX + dx;
        tag.y = startY + dy;

        if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
            tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
        // TODO only check for collisions within current bounds.
        if (!bounds || !cloudCollide(tag, board, size[0])) {
          if (!bounds || collideRects(tag, bounds)) {
            var sprite = tag.sprite,
                w = tag.width >> 5,
                sw = size[0] >> 5,
                lx = tag.x - (w << 4),
                sx = lx & 0x7f,
                msx = 32 - sx,
                h = tag.y1 - tag.y0,
                x = (tag.y + tag.y0) * sw + (lx >> 5),
                last;
            for (var j = 0; j < h; j++) {
              last = 0;
              for (var i = 0; i <= w; i++) {
                board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
              }
              x += sw;
            }
            delete tag.sprite;
            return true;
          }
        }
      }
      return false;
    }

    cloud.words = function(x) {
      if (!arguments.length) return words;
      words = x;
      return cloud;
    };

    cloud.size = function(x) {
      if (!arguments.length) return size;
      size = [+x[0], +x[1]];
      return cloud;
    };

    cloud.font = function(x) {
      if (!arguments.length) return font;
      font = d3.functor(x);
      return cloud;
    };

    cloud.fontStyle = function(x) {
      if (!arguments.length) return fontStyle;
      fontStyle = d3.functor(x);
      return cloud;
    };

    cloud.fontWeight = function(x) {
      if (!arguments.length) return fontWeight;
      fontWeight = d3.functor(x);
      return cloud;
    };

    cloud.rotate = function(x) {
      if (!arguments.length) return rotate;
      rotate = d3.functor(x);
      return cloud;
    };

    cloud.text = function(x) {
      if (!arguments.length) return text;
      text = d3.functor(x);
      return cloud;
    };

    cloud.spiral = function(x) {
      if (!arguments.length) return spiral;
      spiral = spirals[x + ""] || x;
      return cloud;
    };

    cloud.fontSize = function(x) {
      if (!arguments.length) return fontSize;
      fontSize = d3.functor(x);
      return cloud;
    };

    cloud.padding = function(x) {
      if (!arguments.length) return padding;
      padding = d3.functor(x);
      return cloud;
    };

    return d3.rebind(cloud, event, "on");
  }

  function cloudText(d) {
    return d.text;
  }

  function cloudFont() {
    return "serif";
  }

  function cloudFontNormal() {
    return "normal";
  }

  function cloudFontSize(d) {
    return Math.sqrt(d.value);
  }

  function cloudRotate() {
    return (~~(Math.random() * 6) - 3) * 30;
  }

  function cloudPadding() {
    return 1;
  }

  // Fetches a monochrome sprite bitmap for the specified text.
  // Load in batches for speed.
  function cloudSprite(d, data, di) {
    if (d.sprite) return;
    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
    var x = 0,
        y = 0,
        maxh = 0,
        n = data.length;
    di--;
    while (++di < n) {
      d = data[di];
      c.save();
      c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
      var w = c.measureText(d.text + "m").width * ratio,
          h = d.size << 1;
      if (d.rotate) {
        var sr = Math.sin(d.rotate * cloudRadians),
            cr = Math.cos(d.rotate * cloudRadians),
            wcr = w * cr,
            wsr = w * sr,
            hcr = h * cr,
            hsr = h * sr;
        w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
        h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
      } else {
        w = (w + 0x1f) >> 5 << 5;
      }
      if (h > maxh) maxh = h;
      if (x + w >= (cw << 5)) {
        x = 0;
        y += maxh;
        maxh = 0;
      }
      if (y + h >= ch) break;
      c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
      if (d.rotate) c.rotate(d.rotate * cloudRadians);
      c.fillText(d.text, 0, 0);
      c.restore();
      d.width = w;
      d.height = h;
      d.xoff = x;
      d.yoff = y;
      d.x1 = w >> 1;
      d.y1 = h >> 1;
      d.x0 = -d.x1;
      d.y0 = -d.y1;
      x += w;
    }
    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
        sprite = [];
    while (--di >= 0) {
      d = data[di];
      var w = d.width,
          w32 = w >> 5,
          h = d.y1 - d.y0,
          p = d.padding;
      // Zero the buffer
      for (var i = 0; i < h * w32; i++) sprite[i] = 0;
      x = d.xoff;
      if (x == null) return;
      y = d.yoff;
      var seen = 0,
          seenRow = -1;
      for (var j = 0; j < h; j++) {
        for (var i = 0; i < w; i++) {
          var k = w32 * j + (i >> 5),
              m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
          if (p) {
            if (j) sprite[k - w32] |= m;
            if (j < w - 1) sprite[k + w32] |= m;
            m |= (m << 1) | (m >> 1);
          }
          sprite[k] |= m;
          seen |= m;
        }
        if (seen) seenRow = j;
        else {
          d.y0++;
          h--;
          j--;
          y++;
        }
      }
      d.y1 = d.y0 + seenRow;
      d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
    }
  }

  // Use mask-based collision detection.
  function cloudCollide(tag, board, sw) {
    sw >>= 5;
    var sprite = tag.sprite,
        w = tag.width >> 5,
        lx = tag.x - (w << 4),
        sx = lx & 0x7f,
        msx = 32 - sx,
        h = tag.y1 - tag.y0,
        x = (tag.y + tag.y0) * sw + (lx >> 5),
        last;
    for (var j = 0; j < h; j++) {
      last = 0;
      for (var i = 0; i <= w; i++) {
        if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
            & board[x + i]) return true;
      }
      x += sw;
    }
    return false;
  }

  function cloudBounds(bounds, d) {
    var b0 = bounds[0],
        b1 = bounds[1];
    if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
    if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
    if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
    if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
  }

  function collideRects(a, b) {
    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
  }

  function archimedeanSpiral(size) {
    var e = size[0] / size[1];
    return function(t) {
      return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
    };
  }

  function rectangularSpiral(size) {
    var dy = 4,
        dx = dy * size[0] / size[1],
        x = 0,
        y = 0;
    return function(t) {
      var sign = t < 0 ? -1 : 1;
      // See triangular numbers: T_n = n * (n + 1) / 2.
      switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
        case 0:  x += dx; break;
        case 1:  y += dy; break;
        case 2:  x -= dx; break;
        default: y -= dy; break;
      }
      return [x, y];
    };
  }

  // TODO reuse arrays?
  function zeroArray(n) {
    var a = [],
        i = -1;
    while (++i < n) a[i] = 0;
    return a;
  }

  var cloudRadians = Math.PI / 180,
      cw = 1 << 11 >> 5,
      ch = 1 << 11,
      canvas,
      ratio = 1;

  if (typeof document !== "undefined") {
    canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
  } else {
    // node-canvas support
    var Canvas = require("canvas");
    canvas = new Canvas(cw << 5, ch);
  }

  var c = canvas.getContext("2d"),
      spirals = {
        archimedean: archimedeanSpiral,
        rectangular: rectangularSpiral
      };
  c.fillStyle = "red";
  c.textAlign = "center";

  exports.cloud = cloud;
})(typeof exports === "undefined" ? d3.layout || (d3.layout = {}) : exports);

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('State', [], function () {
    var stateInst;

    // Since there will be (can be) multiple GST on a page, and each will have
    // a separate state, we will create a factory constructor function. The
    // constructor will expect the ID of the DIV with the GST contents, and the
    // configuration object (parsed from a JSON string). It will return an
    // object containing methods to set and get the private state properties.

    stateInst = 0;

    // This module defines and returns a factory constructor.
    return State;

    function State(gstId, config) {
        var parameters, allParameterNames, allParameterValues,
            plotDiv, dynamicEl, dynamicElByElId;

        dynamicEl = [];
        dynamicElByElId = {};

        stateInst += 1;
        // console.log('MESSAGE: Creating state instance # ' + stateInst + '.');

        // Initially, there are no parameters to track. So, we will instantiate
        // an empty object.
        //
        // As we parse the JSON config object, we will add parameters as
        // named properties. For example
        //
        //     parameters.a = {...};
        //
        // will be created for the parameter 'a'.
        parameters = {};

        // Check that the required parameters config object is available.
        if ($.isPlainObject(config.parameters) === false) {
            console.log('ERROR: Expected config.parameters to be an object. It is not.');
            console.log('config.parameters = ', config.parameters);

            return;
        }

        // If config.parameters.param is an array, pass it to the processor
        // element by element.
        if ($.isArray(config.parameters.param) === true) {
            (function (c1) {
                while (c1 < config.parameters.param.length) {
                    processParameter(config.parameters.param[c1]);
                    c1 += 1;
                }
            }(0));
        }

        // If config.parameters.param is an object, pass this object to the
        // processor directly.
        else if ($.isPlainObject(config.parameters.param) === true) {
            processParameter(config.parameters.param);
        }

        // If config.parameters.param is some other type, report an error and
        // do not continue.
        else {
            console.log('ERROR: config.parameters.param is of an unsupported type.');
            console.log('config.parameters.param = ', config.parameters.param);

            return;
        }

        // Instead of building these arrays every time when some component
        // requests them, we will create them in the beginning, and then update
        // each element individually when some parameter's value changes.
        //
        // Then we can just return the required array, instead of iterating
        // over all of the properties of the 'parameters' object, and
        // extracting their names/values one by one.
        allParameterNames = [];
        allParameterValues = [];

        // Populate 'allParameterNames', and 'allParameterValues' with data.
        generateHelperArrays();

        // The constructor will return an object with methods to operate on
        // it's private properties.
        return {
            'getParameterValue': getParameterValue,
            'setParameterValue': setParameterValue,

            'getParamObj': getParamObj,

            'getAllParameterNames': getAllParameterNames,
            'getAllParameterValues': getAllParameterValues,

            'bindUpdatePlotEvent': bindUpdatePlotEvent,
            'addDynamicEl': addDynamicEl,

            // plde is an abbreviation for Plot Label Dynamic Elements.
            plde: []
        };

        function getAllParameterNames() {
            return allParameterNames;
        }

        function getAllParameterValues() {
            return allParameterValues;
        }

        function getParamObj(paramName) {
            if (parameters.hasOwnProperty(paramName) === false) {
                console.log('ERROR: Object parameters does not have a property named "' + paramName + '".');

                return;
            }

            return parameters[paramName];
        }

        function bindUpdatePlotEvent(newPlotDiv, callback) {
            plotDiv = newPlotDiv;

            plotDiv.bind('update_plot', callback);
        }

        function addDynamicEl(el, func, elId, updateOnEvent) {
            var newLength;

            newLength = dynamicEl.push({
                'el': el,
                'func': func,
                'elId': elId,
                'updateOnEvent': updateOnEvent
            });

            if (typeof dynamicElByElId[elId] !== 'undefined') {
                console.log(
                    'ERROR: Duplicate dynamic element ID "' + elId + '" found.'
                );
            } else {
                dynamicElByElId[elId] = dynamicEl[newLength - 1];
            }
        }

        function getParameterValue(paramName) {

            // If the name of the constant is not tracked by state, return an
            // 'undefined' value.
            if (parameters.hasOwnProperty(paramName) === false) {
                console.log('ERROR: Object parameters does not have a property named "' + paramName + '".');

                return;
            }

            return parameters[paramname].value;
        }

        // ####################################################################
        //
        // Function: setParameterValue(paramName, paramValue, element)
        // --------------------------------------------------
        //
        //
        // This function can be called from a callback, registered by a slider
        // or a text input, when specific events ('slide' or 'change') are
        // triggered.
        //
        // The 'paramName' is the name of the parameter in 'parameters' object
        // whose value must be updated to the new value of 'paramValue'.
        //
        // Before we update the value, we must check that:
        //
        //     1.) the parameter named as 'paramName' actually exists in the
        //         'parameters' object;
        //     2.) the value 'paramValue' is a valid floating-point number, and
        //         it lies within the range specified by the 'min' and 'max'
        //         properties of the stored parameter object.
        //
        // If 'paramName' and 'paramValue' turn out to be valid, we will update
        // the stored value in the parameter with the new value, and also
        // update all of the text inputs and the slider that correspond to this
        // parameter (if any), so that they reflect the new parameter's value.
        // Finally, the helper array 'allParameterValues' will also be updated
        // to reflect the change.
        //
        // If something went wrong (for example the new value is outside the
        // allowed range), then we will reset the 'element' to display the
        // original value.
        //
        // ####################################################################
        function setParameterValue(paramName, paramValue, element, slider, updateOnEvent) {
            var paramValueNum, c1;

            // If a parameter with the name specified by the 'paramName'
            // parameter is not tracked by state, do not do anything.
            if (parameters.hasOwnProperty(paramName) === false) {
                console.log('ERROR: Object parameters does not have a property named "' + paramName + '".');

                return;
            }

            // Try to convert the passed value to a valid floating-point
            // number.
            paramValueNum = parseFloat(paramValue);

            // We are interested only in valid float values. NaN, -INF,
            // +INF we will disregard.
            if (isFinite(paramValueNum) === false) {
                console.log('ERROR: New parameter value is not a floating-point number.');
                console.log('paramValue = ', paramValue);

                return;
            }

            if (paramValueNum < parameters[paramName].min) {
                paramValueNum = parameters[paramName].min;
            } else if (paramValueNum > parameters[paramName].max) {
                paramValueNum = parameters[paramName].max;
            }

            parameters[paramName].value = paramValueNum;

            // Update all text inputs with the new parameter's value.
            for (c1 = 0; c1 < parameters[paramName].inputDivs.length; c1 += 1) {
                parameters[paramName].inputDivs[c1].val(paramValueNum);
            }

            // Update the single slider with the new parameter's value.
            if ((slider === false) && (parameters[paramName].sliderDiv !== null)) {
                parameters[paramName].sliderDiv.slider('value', paramValueNum);
            }

            // Update the helper array with the new parameter's value.
            allParameterValues[parameters[paramName].helperArrayIndex] = paramValueNum;

            for (c1 = 0; c1 < dynamicEl.length; c1++) {
                if (
                    ((updateOnEvent !== undefined) && (dynamicEl[c1].updateOnEvent === updateOnEvent)) ||
                    (updateOnEvent === undefined)
                ) {
                    // If we have a DOM element, call the function "paste" the answer into the DIV.
                    if (dynamicEl[c1].el !== null) {
                        dynamicEl[c1].el.html(dynamicEl[c1].func.apply(window, allParameterValues));
                    }
                    // If we DO NOT have an element, simply call the function. The function can then
                    // manipulate all the DOM elements it wants, without the fear of them being overwritten
                    // by us afterwards.
                    else {
                        dynamicEl[c1].func.apply(window, allParameterValues);
                    }
                }
            }

            // If we have a plot DIV to work with, tell to update.
            if (plotDiv !== undefined) {
                plotDiv.trigger('update_plot');
            }

            return true;
        } // End-of: function setParameterValue

        // ####################################################################
        //
        // Function: processParameter(obj)
        // -------------------------------
        //
        //
        // This function will be run once for each instance of a GST when
        // parsing the JSON config object.
        //
        // 'newParamObj' must be empty from the start for each invocation of
        // this function, that's why we will declare it locally.
        //
        // We will parse the passed object 'obj' and populate the 'newParamObj'
        // object with required properties.
        //
        // Since there will be many properties that are of type floating-point
        // number, we will have a separate function for parsing them.
        //
        // processParameter() will fail right away if 'obj' does not have a
        // '@var' property which represents the name of the parameter we want
        // to process.
        //
        // If, after all of the properties have been processed, we reached the
        // end of the function successfully, the 'newParamObj' will be added to
        // the 'parameters' object (that is defined in the scope of State()
        // function) as a property named as the name of the parameter.
        //
        // If at least one of the properties from 'obj' does not get correctly
        // parsed, then the parameter represented by 'obj' will be disregarded.
        // It will not be available to user-defined plotting functions, and
        // things will most likely break. We will notify the user about this.
        //
        // ####################################################################
        function processParameter(obj) {
            var paramName, newParamObj;

            if (typeof obj['@var'] !== 'string') {
                console.log('ERROR: Expected obj["@var"] to be a string. It is not.');
                console.log('obj["@var"] = ', obj['@var']);

                return;
            }

            paramName = obj['@var'];
            newParamObj = {};

            if (
                (processFloat('@min', 'min') === false) ||
                (processFloat('@max', 'max') === false) ||
                (processFloat('@step', 'step') === false) ||
                (processFloat('@initial', 'value') === false)
            ) {
                console.log('ERROR: A required property is missing. Not creating parameter "' + paramName + '"');

                return;
            }

            // Pointers to text input and slider DIV elements that this
            // parameter will be attached to. Initially there are none. When we
            // will create text inputs and sliders, we will update these
            // properties.
            newParamObj.inputDivs = [];
            newParamObj.sliderDiv = null;

            // Everything went well, so save the new parameter object.
            parameters[paramName] = newParamObj;

            return;

            function processFloat(attrName, newAttrName) {
                var attrValue;

                if (typeof obj[attrName] !== 'string') {
                    console.log('ERROR: Expected obj["' + attrName + '"] to be a string. It is not.');
                    console.log('obj["' + attrName + '"] = ', obj[attrName]);

                    return false;
                } else {
                    attrValue = parseFloat(obj[attrName]);

                    if (isFinite(attrValue) === false) {
                        console.log('ERROR: Expected obj["' + attrName + '"] to be a valid floating-point number. It is not.');
                        console.log('obj["' + attrName + '"] = ', obj[attrName]);

                        return false;
                    }
                }

                newParamObj[newAttrName] = attrValue;

                return true;
            } // End-of: function processFloat
        } // End-of: function processParameter

        // ####################################################################
        //
        // Function: generateHelperArrays()
        // -------------------------------
        //
        //
        // Populate 'allParameterNames' and 'allParameterValues' with data.
        // Link each parameter object with the corresponding helper array via
        // an index 'helperArrayIndex'. It will be the same for both of the
        // arrays.
        //
        // NOTE: It is important to remember to update these helper arrays
        // whenever a new parameter is added (or one is removed), or when a
        // parameter's value changes.
        //
        // ####################################################################
        function generateHelperArrays() {
            var paramName, c1;

            c1 = 0;
            for (paramName in parameters) {
                allParameterNames.push(paramName);
                allParameterValues.push(parameters[paramName].value);

                parameters[paramName].helperArrayIndex = c1;

                c1 += 1;
            }
        }
    } // End-of: function State
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

/**
 * Simple image input
 *
 *
 * Click on image. Update the coordinates of a dot on the image.
 * The new coordinates are the location of the click.
 */

/**
 * 'The wise adapt themselves to circumstances, as water molds itself to the
 * pitcher.'
 *
 * ~ Chinese Proverb
 */

window.ImageInput = (function ($, undefined) {
    var ImageInput = ImageInputConstructor;

    ImageInput.prototype = {
        constructor: ImageInputConstructor,
        clickHandler: clickHandler
    };

    return ImageInput;

    function ImageInputConstructor(elementId) {
        this.el = $('#imageinput_' + elementId);
        this.crossEl = $('#cross_' + elementId);
        this.inputEl = $('#input_' + elementId);

        this.el.on('click', this.clickHandler.bind(this));
    }

    function clickHandler(event) {
        var offset = this.el.offset(),
            posX = event.offsetX ?
                event.offsetX : event.pageX - offset.left,
            posY = event.offsetY ?
                event.offsetY : event.pageY - offset.top,

            // To reduce differences between values returned by different kinds
            // of browsers, we round `posX` and `posY`.
            //
            // IE10: `posX` and `posY` - float.
            // Chrome, FF: `posX` and `posY` - integers.
            result = '[' + Math.round(posX) + ',' + Math.round(posY) + ']';

        this.crossEl.css({
            left: posX - 15,
            top: posY - 15,
            visibility: 'visible'
        });

        this.inputEl.val(result);
    }
}).call(this, window.jQuery);

//////////////////////////////////////////////////////////////////////////////
//
//  Circuit simulator
//
//////////////////////////////////////////////////////////////////////////////

// Copyright (C) 2011 Massachusetts Institute of Technology


// create a circuit for simulation using "new cktsim.Circuit()"

// for modified nodal analysis (MNA) stamps see
// http://www.analog-electronics.eu/analog-electronics/modified-nodal-analysis/modified-nodal-analysis.xhtml

cktsim = (function() {
    
	///////////////////////////////////////////////////////////////////////////////
	//
	//  Circuit
	//
	//////////////////////////////////////////////////////////////////////////////

	// types of "nodes" in the linear system
	T_VOLTAGE = 0;
	T_CURRENT = 1;

        v_newt_lim = 0.3;   // Voltage limited Newton great for Mos/diodes
	v_abstol = 1e-6;	// Absolute voltage error tolerance
	i_abstol = 1e-12;	// Absolute current error tolerance
        eps = 1.0e-12;           // A very small number compared to one.
	dc_max_iters = 1000;	// max iterations before giving pu
	max_tran_iters = 20;	// max iterations before giving up
	time_step_increase_factor = 2.0;  // How much can lte let timestep grow.
	lte_step_decrease_factor = 8;    // Limit lte one-iter timestep shrink.
	nr_step_decrease_factor = 4;     // Newton failure timestep shink.
	reltol = 0.0001;		// Relative tol to max observed value
        lterel = 10;             // LTE/Newton tolerance ratio (> 10!)
        res_check_abs = Math.sqrt(i_abstol); // Loose Newton residue check
        res_check_rel = Math.sqrt(reltol); // Loose Newton residue check

	function Circuit() {
	    this.node_map = new Array();
	    this.ntypes = [];
	    this.initial_conditions = [];  // ic's for each element

	    this.devices = [];  // list of devices
	    this.device_map = new Array();  // map name -> device
	    this.voltage_sources = [];  // list of voltage sources
	    this.current_sources = [];  // list of current sources

	    this.finalized = false;
	    this.diddc = false;
	    this.node_index = -1;

	    this.periods = 1
	}

	// index of ground node
	Circuit.prototype.gnd_node = function() {
	    return -1;
	}

	// allocate a new node index
	Circuit.prototype.node = function(name,ntype,ic) {
	    this.node_index += 1;
	    if (name) this.node_map[name] = this.node_index;
	    this.ntypes.push(ntype);
	    this.initial_conditions.push(ic);
	    return this.node_index;
	}

	// call to finalize the circuit in preparation for simulation
	Circuit.prototype.finalize = function() {
	    if (!this.finalized) {
		this.finalized = true;
		this.N = this.node_index + 1;  // number of nodes

		// give each device a chance to finalize itself
		for (var i = this.devices.length - 1; i >= 0; --i)
		    this.devices[i].finalize(this);

		// set up augmented matrix and various temp vectors
		this.matrix = mat_make(this.N, this.N+1);
		this.Gl = mat_make(this.N, this.N);  // Matrix for linear conductances
		this.G = mat_make(this.N, this.N);  // Complete conductance matrix
		this.C = mat_make(this.N, this.N);  // Matrix for linear L's and C's

		this.soln_max = new Array(this.N);   // max abs value seen for each unknown
		this.abstol = new Array(this.N);
		this.solution = new Array(this.N);
		this.rhs = new Array(this.N);
		for (var i = this.N - 1; i >= 0; --i) {	    
		    this.soln_max[i] = 0.0;
		    this.abstol[i] = this.ntypes[i] == T_VOLTAGE ? v_abstol : i_abstol;
		    this.solution[i] = 0.0;
		    this.rhs[i] = 0.0;
		}

		// Load up the linear elements once and for all
		for (var i = this.devices.length - 1; i >= 0; --i) {
		    this.devices[i].load_linear(this)
		}

		// Check for voltage source loops. 
		n_vsrc = this.voltage_sources.length;
		if (n_vsrc > 0) { // At least one voltage source
		    var GV = mat_make(n_vsrc, this.N);  // Loop check
		    for (var i = n_vsrc - 1; i >= 0; --i) {
			var branch = this.voltage_sources[i].branch;
			for (var j = this.N - 1; j >= 0; j--)
			    GV[i][j] = this.Gl[branch][j];
		    }
		    var rGV = mat_rank(GV);
		    if (rGV < n_vsrc) {
			alert('Warning!!! Circuit has a voltage source loop or a source or current probe shorted by a wire, please remove the source or the wire causing the short.');
			alert('Warning!!! Simulator might produce meaningless results or no result with illegal circuits.');
			return false;		
		    }
		}
	    }
	    return true;		
	}

	// load circuit from JSON netlist (see schematic.js)
	Circuit.prototype.load_netlist = function(netlist) {
	    // set up mapping for all ground connections
	    for (var i = netlist.length - 1; i >= 0; --i) {
		var component = netlist[i];
		var type = component[0];
		if (type == 'g') {
		    var connections = component[3];
		    this.node_map[connections[0]] = this.gnd_node();
		}
	    }

	    // process each component in the JSON netlist (see schematic.js for format)
	    var found_ground = false;
	    for (var i = netlist.length - 1; i >= 0; --i) {
		var component = netlist[i];
		var type = component[0];

		// ignore wires, ground connections, scope probes and view info
		if (type == 'view' || type == 'w' || type == 'g' || type == 's' || type == 'L') {
		    continue;
		}

		var properties = component[2];
		var name = properties['name'];
		if (name==undefined || name=='')
		    name = '_' + properties['_json_'].toString();

		// convert node names to circuit indicies
		var connections = component[3];
		for (var j = connections.length - 1; j >= 0; --j) {
		    var node = connections[j];
		    var index = this.node_map[node];
		    if (index == undefined) index = this.node(node,T_VOLTAGE);
		    else if (index == this.gnd_node()) found_ground = true;
		    connections[j] = index;
		}

		// process the component
		if (type == 'r')	// resistor
		    this.r(connections[0],connections[1],properties['r'],name);
		else if (type == 'd')	// diode
		    this.d(connections[0],connections[1],properties['area'],properties['type'],name);
		else if (type == 'c')   // capacitor
		    this.c(connections[0],connections[1],properties['c'],name);
		else if (type == 'l')	// inductor
		    this.l(connections[0],connections[1],properties['l'],name);
		else if (type == 'v') 	// voltage source
		    this.v(connections[0],connections[1],properties['value'],name);
		else if (type == 'i') 	// current source
		    this.i(connections[0],connections[1],properties['value'],name);
		else if (type == 'o') 	// op amp
		    this.opamp(connections[0],connections[1],connections[2],connections[3],properties['A'],name);
		else if (type == 'n') 	// n fet
		    this.n(connections[0],connections[1],connections[2],properties['W/L'],name);
		else if (type == 'p') 	// p fet
		    this.p(connections[0],connections[1],connections[2],properties['W/L'],name);
		else if (type == 'a') 	// current probe == 0-volt voltage source
		    this.v(connections[0],connections[1],'0',name);
	    }

	    if (!found_ground) { // No ground on schematic
		alert('Please make at least one connection to ground  (inverted T symbol)');
		return false;
	    }
	    return true;
	    
	}

	// if converges: updates this.solution, this.soln_max, returns iter count
	// otherwise: return undefined and set this.problem_node
	// Load should compute -f and df/dx (note the sign pattern!)
        Circuit.prototype.find_solution = function(load,maxiters) {
	    var soln = this.solution;
	    var rhs = this.rhs;
	    var d_sol = new Array();
	    var abssum_compare;
	    var converged,abssum_old=0, abssum_rhs;
	    var use_limiting = false;
	    var down_count = 0;

	    // iteratively solve until values convere or iteration limit exceeded
	    for (var iter = 0; iter < maxiters; iter++) {
		// set up equations
		load(this,soln,rhs);

		// Compute norm of rhs, assume variables of v type go with eqns of i type
		abssum_rhs = 0;
		for (var i = this.N - 1; i >= 0; --i)
		    if (this.ntypes[i] == T_VOLTAGE)
			abssum_rhs += Math.abs(rhs[i]);

		if ((iter > 0) && (use_limiting == false) && (abssum_old < abssum_rhs)) {  
		    // Old rhsnorm was better, undo last iter and turn on limiting
		    for (var i = this.N - 1; i >= 0; --i)
			soln[i] -= d_sol[i];
		    iter -= 1;
		    use_limiting = true;
		}
	        else {  // Compute the Newton delta
		    //d_sol = mat_solve(this.matrix,rhs);
		    d_sol = mat_solve_rq(this.matrix,rhs);

		    // If norm going down for ten iters, stop limiting
		    if (abssum_rhs < abssum_old)
			down_count += 1;
		    else 
			down_count = 0;
		    if (down_count > 10) {
			use_limiting = false;
			down_count = 0;
		    }

		    // Update norm of rhs
		    abssum_old = abssum_rhs;		    
		}

		// Update the worst case abssum for comparison.
		if ((iter == 0) || (abssum_rhs > abssum_compare))
		    abssum_compare = abssum_rhs;

		// Check residue convergence, but loosely, and give up 
		// on last iteration
		if ( (iter < (maxiters - 1)) &&
		     (abssum_rhs > (res_check_abs+res_check_rel*abssum_compare)))
		    converged = false;
		else converged = true;


		// Update solution and check delta convergence
		for (var i = this.N - 1; i >= 0; --i) {
		    // Simple voltage step limiting to encourage Newton convergence
		    if (use_limiting) {
			if (this.ntypes[i] == T_VOLTAGE) {
			    d_sol[i] = (d_sol[i] > v_newt_lim) ? v_newt_lim : d_sol[i];
			    d_sol[i] = (d_sol[i] < -v_newt_lim) ? -v_newt_lim : d_sol[i];
			}
		    }
		    soln[i] += d_sol[i];
		    thresh = this.abstol[i] + reltol*this.soln_max[i];
		    if (Math.abs(d_sol[i]) > thresh) {
			converged = false;
			this.problem_node = i;
		    }
		}

		//alert(numeric.prettyPrint(this.solution);)
                if (converged == true) {
		    for (var i = this.N - 1; i >= 0; --i) 
			if (Math.abs(soln[i]) > this.soln_max[i])
			    this.soln_max[i] = Math.abs(soln[i]);
		    
		    return iter+1;
		}
	    }
	    return undefined;
	}

	// DC analysis
	Circuit.prototype.dc = function() {

	    // Allocation matrices for linear part, etc.
	    if (this.finalize() == false)
		return undefined;

	    // Define -f and df/dx for Newton solver
	    function load_dc(ckt,soln,rhs) {
		// rhs is initialized to -Gl * soln
		mat_v_mult(ckt.Gl, soln, rhs, -1.0);
		// G matrix is initialized with linear Gl
		mat_copy(ckt.Gl,ckt.G);
		// Now load up the nonlinear parts of rhs and G
		for (var i = ckt.devices.length - 1; i >= 0; --i)
			ckt.devices[i].load_dc(ckt,soln,rhs);
		// G matrix is copied in to the system matrix
		mat_copy(ckt.G,ckt.matrix);
	    }

	    // find the operating point
	    var iterations = this.find_solution(load_dc,dc_max_iters);

	    if (typeof iterations == 'undefined') {
	    // too many iterations
		if (this.current_sources.length > 0) {
		    alert('Newton Method Failed, do your current sources have a conductive path to ground?');
		} else {
		    alert('Newton Method Failed, it may be your circuit or it may be our simulator.');
		}

		return undefined
	    } else {
		// Note that a dc solution was computed
		this.diddc = true;
		// create solution dictionary
		var result = new Array();
		// capture node voltages
		for (var name in this.node_map) {
		    var index = this.node_map[name];
		    result[name] = (index == -1) ? 0 : this.solution[index];
		}
		// capture branch currents from voltage sources
		for (var i = this.voltage_sources.length - 1; i >= 0; --i) {
		    var v = this.voltage_sources[i];
		    result['I('+v.name+')'] = this.solution[v.branch];
		}
		return result;
	    }
	}

	// Transient analysis (needs work!)
        Circuit.prototype.tran = function(ntpts, tstart, tstop, probenames, no_dc) {

	    // Define -f and df/dx for Newton solver
	    function load_tran(ckt,soln,rhs) {
		// Crnt is initialized to -Gl * soln
		mat_v_mult(ckt.Gl, soln, ckt.c,-1.0);
		// G matrix is initialized with linear Gl
		mat_copy(ckt.Gl,ckt.G);
		// Now load up the nonlinear parts of crnt and G
		for (var i = ckt.devices.length - 1; i >= 0; --i)
		    ckt.devices[i].load_tran(ckt,soln,ckt.c,ckt.time);
		// Exploit the fact that storage elements are linear
		mat_v_mult(ckt.C, soln, ckt.q, 1.0);
		// -rhs = c - dqdt
		for (var i = ckt.N-1; i >= 0; --i) {
		    var dqdt = ckt.alpha0*ckt.q[i] + ckt.alpha1*ckt.oldq[i] + 
			ckt.alpha2*ckt.old2q[i];
		    //alert(numeric.prettyPrint(dqdt));
		    rhs[i] = ckt.beta0[i]*ckt.c[i] + ckt.beta1[i]*ckt.oldc[i] - dqdt;
		}
		// matrix = beta0*G + alpha0*C.
		mat_scale_add(ckt.G,ckt.C,ckt.beta0,ckt.alpha0,ckt.matrix);
	    }

	    var p = new Array(3);
	    function interp_coeffs(t, t0, t1, t2) {
		// Poly coefficients
		var dtt0 = (t - t0);
		var dtt1 = (t - t1);
		var dtt2 = (t - t2);
		var dt0dt1 = (t0 - t1);
		var dt0dt2 = (t0 - t2);
		var dt1dt2 = (t1 - t2);
		p[0] = (dtt1*dtt2)/(dt0dt1 * dt0dt2);
		p[1] = (dtt0*dtt2)/(-dt0dt1 * dt1dt2);
		p[2] = (dtt0*dtt1)/(dt0dt2 * dt1dt2);
		return p;
	    }

	    function pick_step(ckt, step_index) {
		var min_shrink_factor = 1.0/lte_step_decrease_factor;
	        var max_growth_factor = time_step_increase_factor;
		var N = ckt.N;
		var p = interp_coeffs(ckt.time, ckt.oldt, ckt.old2t, ckt.old3t);
		var trapcoeff = 0.5*(ckt.time - ckt.oldt)/(ckt.time - ckt.old3t);
		var maxlteratio = 0.0;
		for (var i = ckt.N-1; i >= 0; --i) {
		    if (ckt.ltecheck[i]) { // Check lte on variable
			var pred = p[0]*ckt.oldsol[i] + p[1]*ckt.old2sol[i] + p[2]*ckt.old3sol[i];
			var lte = Math.abs((ckt.solution[i] - pred))*trapcoeff;
			var lteratio = lte/(lterel*(ckt.abstol[i] + reltol*ckt.soln_max[i]));
			maxlteratio = Math.max(maxlteratio, lteratio);
		    }
		}
		var new_step;
		var lte_step_ratio = 1.0/Math.pow(maxlteratio,1/3); // Cube root because trap
		if (lte_step_ratio < 1.0) { // Shrink the timestep to make lte
		    lte_step_ratio = Math.max(lte_step_ratio,min_shrink_factor);
		    new_step = (ckt.time - ckt.oldt)*0.75*lte_step_ratio;
		    new_step = Math.max(new_step, ckt.min_step);
		} else {
		    lte_step_ratio = Math.min(lte_step_ratio, max_growth_factor);
		    if (lte_step_ratio > 1.2)  /* Increase timestep due to lte. */
			new_step = (ckt.time - ckt.oldt) * lte_step_ratio / 1.2;
		    else 
			new_step = (ckt.time - ckt.oldt);
		    new_step = Math.min(new_step, ckt.max_step);
		}
		return new_step;
	    }
	    
	    // Standard to do a dc analysis before transient
	    // Otherwise, do the setup also done in dc.
	    no_dc = false;
	    if ((this.diddc == false) && (no_dc == false)) {
		if (this.dc() == undefined) { // DC failed, realloc mats and vects.
		    alert('DC failed, trying transient analysis from zero.');		    
		    this.finalized = false;  // Reset the finalization.
		    if (this.finalize() == false) 
			return undefined;
		}
	    }
	    else {
		if (this.finalize() == false) // Allocate matrices and vectors.
		    return undefined;
	    }

	    // Tired of typing this, and using "with" generates hate mail.
	    var N = this.N;

	    // build array to hold list of results for each variable
	    // last entry is for timepoints.
	    var response = new Array(N + 1);
	    for (var i = N; i >= 0; --i) response[i] = new Array();

	    // Allocate back vectors for up to a second order method
	    this.old3sol = new Array(this.N);
	    this.old3q = new Array(this.N);
	    this.old2sol = new Array(this.N);
	    this.old2q = new Array(this.N);
	    this.oldsol = new Array(this.N);
	    this.oldq = new Array(this.N);
	    this.q = new Array(this.N);
	    this.oldc = new Array(this.N);
	    this.c = new Array(this.N);
	    this.alpha0 = 1.0;
	    this.alpha1 = 0.0;
	    this.alpha2 = 0.0;
	    this.beta0 = new Array(this.N);
	    this.beta1 = new Array(this.N);

	    // Mark a set of algebraic variable (don't miss hidden ones!).
	    this.ar = this.algebraic(this.C);

	    // Non-algebraic variables and probe variables get lte
	    this.ltecheck = new Array(this.N);
	    for (var i = N; i >= 0; --i) 
		this.ltecheck[i] = (this.ar[i] == 0);

	    for (var name in this.node_map) {
		var index = this.node_map[name];
		for (var i = probenames.length; i >= 0; --i) {
		    if (name == probenames[i]) {
			this.ltecheck[index] = true;
			break;
		    }
		}
	    }

	    // Check for periodic sources
	    var period = tstop - tstart;
	    for (var i = this.voltage_sources.length - 1; i >= 0; --i) {
		var per = this.voltage_sources[i].src.period;
		if (per > 0)
		    period = Math.min(period, per);
	    }
	    for (var i = this.current_sources.length - 1; i >= 0; --i) {
		var per = this.current_sources[i].src.period;
		if (per > 0)
		    period = Math.min(period, per);
	    }
	    this.periods = Math.ceil((tstop - tstart)/period);
	    //alert('number of periods ' + this.periods);

	
	    this.time = tstart;
	    // ntpts adjusted by numbers of periods in input
	    this.max_step = (tstop - tstart)/(this.periods*ntpts);
	    this.min_step = this.max_step/1e8;
	    var new_step = this.max_step/1e6;
	    this.oldt = this.time - new_step;

	    // Initialize old crnts, charges, and solutions.
	    load_tran(this,this.solution,this.rhs)
	    for (var i = N-1; i >= 0; --i) {
		this.old3sol[i] = this.solution[i];
		this.old2sol[i] = this.solution[i];
		this.oldsol[i] = this.solution[i];
		this.old3q[i] = this.q[i]; 
		this.old2q[i] = this.q[i]; 
		this.oldq[i] = this.q[i]; 
		this.oldc[i] = this.c[i]; 
	    }

	    
	    var beta0,beta1;
	    // Start with two pseudo-Euler steps, maximum 50000 steps/period
	    var max_nsteps = this.periods*50000;
	    for(var step_index = -3; step_index < max_nsteps; step_index++) {
		// Save the just computed solution, and move back q and c.
		for (var i = this.N - 1; i >= 0; --i) {
		    if (step_index >= 0)
			response[i].push(this.solution[i]);
		    this.oldc[i] = this.c[i];
		    this.old3sol[i] = this.old2sol[i];
		    this.old2sol[i] = this.oldsol[i];
		    this.oldsol[i] = this.solution[i];
		    this.old3q[i] = this.oldq[i];
		    this.old2q[i] = this.oldq[i];
		    this.oldq[i] = this.q[i];

		}

		if (step_index < 0) {  // Take a prestep using BE
		    this.old3t = this.old2t - (this.oldt-this.old2t)
		    this.old2t = this.oldt - (tstart-this.oldt)
		    this.oldt = tstart - (this.time - this.oldt);
		    this.time = tstart;
		    beta0 = 1.0;  
		    beta1 = 0.0;		
		} else {  // Take a regular step
		    // Save the time, and rotate time wheel
		    response[this.N].push(this.time);
		    this.old3t = this.old2t;
		    this.old2t = this.oldt;
		    this.oldt = this.time;
		    // Make sure we come smoothly in to the interval end.
		    if (this.time >= tstop) break;  // We're done.
		    else if(this.time + new_step > tstop)
			this.time = tstop;
		    else if(this.time + 1.5*new_step > tstop)
			this.time += (2/3)*(tstop - this.time);
		    else
			this.time += new_step;

		    // Use trap (average old and new crnts.
		    beta0 = 0.5;
		    beta1 = 0.5;	
		}

		// For trap rule, turn off current avging for algebraic eqns
		for (var i = this.N - 1; i >= 0; --i) {
		    this.beta0[i] = beta0 + this.ar[i]*beta1;
		    this.beta1[i] = (1.0 - this.ar[i])*beta1;
		}

		// Loop to find NR converging timestep with okay LTE
		while (true) {
		    // Set the timestep coefficients (alpha2 is for bdf2).
		    this.alpha0 = 1.0/(this.time - this.oldt);
		    this.alpha1 = -this.alpha0;
		    this.alpha2 = 0;

		    // If timestep is 1/10,000th of tstop, just use BE.
		    if ((this.time-this.oldt) < 1.0e-4*tstop) {
			for (var i = this.N - 1; i >= 0; --i) {
			    this.beta0[i] = 1.0;
			    this.beta1[i] = 0.0;
			}
		    }  
		    // Use Newton to compute the solution.
		    var iterations = this.find_solution(load_tran,max_tran_iters);

		    // If NR succeeds and stepsize is at min, accept and newstep=maxgrowth*minstep.
		    // Else if Newton Fails, shrink step by a factor and try again
		    // Else LTE picks new step, if bigger accept current step and go on.
		    if ((iterations != undefined) && 
			(step_index <= 0 || (this.time-this.oldt) < (1+reltol)*this.min_step)) {
			if (step_index > 0) new_step = time_step_increase_factor*this.min_step;
			break;
		    } else if (iterations == undefined) {  // NR nonconvergence, shrink by factor
			//alert('timestep nonconvergence ' + this.time + ' ' + step_index);
			this.time = this.oldt + 
			    (this.time - this.oldt)/nr_step_decrease_factor;
		    } else {  // Check the LTE and shrink step if needed.
			new_step = pick_step(this, step_index);
			if (new_step < (1.0 - reltol)*(this.time - this.oldt)) {
			    this.time = this.oldt + new_step;  // Try again   
			}
			else
			    break;  // LTE okay, new_step for next step
		    }
		}
	    }

	    // create solution dictionary
	    var result = new Array();
	    for (var name in this.node_map) {
		var index = this.node_map[name];
		result[name] = (index == -1) ? 0 : response[index];
	    }
	    // capture branch currents from voltage sources
	    for (var i = this.voltage_sources.length - 1; i >= 0; --i) {
		var v = this.voltage_sources[i];
		result['I('+v.name+')'] = response[v.branch];
	    }

	    result['_time_'] = response[this.N];
	    return result;
	}

	// AC analysis: npts/decade for freqs in range [fstart,fstop]
	// result['_frequencies_'] = vector of log10(sample freqs)
	// result['xxx'] = vector of dB(response for node xxx)
        // NOTE: Normalization removed in schematic.js, jkw.
        Circuit.prototype.ac = function(npts,fstart,fstop,source_name) {

	    if (this.dc() == undefined) { // DC failed, realloc mats and vects.
		return undefined;
	    }

	    var N = this.N;
	    var G = this.G;
	    var C = this.C;

	    // Complex numbers, we're going to need a bigger boat
	    var matrixac = mat_make(2*N, (2*N)+1);

            // Get the source used for ac
	    if (this.device_map[source_name] === undefined) {
		alert('AC analysis refers to unknown source ' + source_name);
		return 'AC analysis failed, unknown source';
	    }
	    this.device_map[source_name].load_ac(this,this.rhs);

	    // build array to hold list of magnitude and phases for each node
	    // last entry is for frequency values
	    var response = new Array(2*N + 1);
	    for (var i = 2*N; i >= 0; --i) response[i] = new Array();

	    // multiplicative frequency increase between freq points
	    var delta_f = Math.exp(Math.LN10/npts);

	    var phase_offset = new Array(N);
	    for (var i = N-1; i >= 0; --i) phase_offset[i] = 0;

	    var f = fstart;
	    fstop *= 1.0001;  // capture that last freq point!
	    while (f <= fstop) {
		var omega = 2 * Math.PI * f;
		response[2*N].push(f);   // 2*N for magnitude and phase

		// Find complex x+jy that sats Gx-omega*Cy=rhs; omega*Cx+Gy=0
		// Note: solac[0:N-1]=x, solac[N:2N-1]=y
		for (var i = N-1; i >= 0; --i) {
		    // First the rhs, replicated for real and imaginary
		    matrixac[i][2*N] = this.rhs[i];
		    matrixac[i+N][2*N] = 0;

		    for (var j = N-1; j >= 0; --j) {
			matrixac[i][j] = G[i][j];
			matrixac[i+N][j+N] = G[i][j];
			matrixac[i][j+N] = -omega*C[i][j];
			matrixac[i+N][j] = omega*C[i][j];
		    }
		}

		// Compute the small signal response
		var solac = mat_solve(matrixac);

		// Save magnitude and phase
		for (var i = N - 1; i >= 0; --i) {
		    var mag = Math.sqrt(solac[i]*solac[i] + solac[i+N]*solac[i+N]);
		    response[i].push(mag);

		    // Avoid wrapping phase, add or sub 180 for each jump
		    var phase = 180*(Math.atan2(solac[i+N],solac[i])/Math.PI);
		    var phasei = response[i+N];
		    var L = phasei.length;
		    // Look for a one-step jump greater than 90 degrees
		    if (L > 1) {
			var phase_jump = phase + phase_offset[i] - phasei[L-1];
			if (phase_jump > 90) {
			    phase_offset[i] -= 360;
			} else if (phase_jump < -90) {
			    phase_offset[i] += 360;
			}
		    }
		    response[i+N].push(phase + phase_offset[i]);
		}
		f *= delta_f;    // increment frequency
	    }

	    // create solution dictionary
	    var result = new Array();
	    for (var name in this.node_map) {
		var index = this.node_map[name];
		result[name] = (index == -1) ? 0 : response[index];
		result[name+'_phase'] = (index == -1) ? 0 : response[index+N];
	    }
	    result['_frequencies_'] = response[2*N];
	    return result;
	}


        // Helper for adding devices to a circuit, warns on duplicate device names.
        Circuit.prototype.add_device = function(d,name) {
	    // Add device to list of devices and to device map
	    this.devices.push(d);
	    d.name = name;
	    if (name) {
		if (this.device_map[name] === undefined) 
		    this.device_map[name] = d;
		else {
		    alert('Warning: two circuit elements share the same name ' + name);
		    this.device_map[name] = d;
		}
	    }
	    return d;
	}

	Circuit.prototype.r = function(n1,n2,v,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof v) == 'string') {
		v = parse_number(v,undefined);
		if (v === undefined) return undefined;
	    }

	    if (v != 0) {
		var d = new Resistor(n1,n2,v);
		return this.add_device(d, name);
	    } else return this.v(n1,n2,'0',name);   // zero resistance == 0V voltage source
	}

	Circuit.prototype.d = function(n1,n2,area,type,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof area) == 'string') {
		area = parse_number(area,undefined);
		if (area === undefined) return undefined;
	    }

	    if (area != 0) {
		var d = new Diode(n1,n2,area,type);
		return this.add_device(d, name);
	    } // zero area diodes discarded.
	}


	Circuit.prototype.c = function(n1,n2,v,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof v) == 'string') {
		v = parse_number(v,undefined);
		if (v === undefined) return undefined;
	    }
	    var d = new Capacitor(n1,n2,v);
	    return this.add_device(d, name);
	}

	Circuit.prototype.l = function(n1,n2,v,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof v) == 'string') {
		v = parse_number(v,undefined);
		if (v === undefined) return undefined;
	    }
	    var branch = this.node(undefined,T_CURRENT);
	    var d = new Inductor(n1,n2,branch,v);
	    return this.add_device(d, name);
	}

        Circuit.prototype.v = function(n1,n2,v,name) {
	    var branch = this.node(undefined,T_CURRENT);
	    var d = new VSource(n1,n2,branch,v);
	    this.voltage_sources.push(d);
	    return this.add_device(d, name);
	}

	Circuit.prototype.i = function(n1,n2,v,name) {
	    var d = new ISource(n1,n2,v);
	    this.current_sources.push(d);
	    return this.add_device(d, name);
	}

        Circuit.prototype.opamp = function(np,nn,no,ng,A,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof A) == 'string') {
		ratio = parse_number(A,undefined);
		if (A === undefined) return undefined;
	    }
	    var branch = this.node(undefined,T_CURRENT);
	    var d = new Opamp(np,nn,no,ng,branch,A,name);
	    return this.add_device(d, name);
	}

        Circuit.prototype.n = function(d,g,s, ratio, name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof ratio) == 'string') {
		ratio = parse_number(ratio,undefined);
		if (ratio === undefined) return undefined;
	    }
	    var d = new Fet(d,g,s,ratio,name,'n');
	    return this.add_device(d, name);
	}

        Circuit.prototype.p = function(d,g,s, ratio, name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof ratio) == 'string') {
		ratio = parse_number(ratio,undefined);
		if (ratio === undefined) return undefined;
	    }
	    var d = new Fet(d,g,s,ratio,name,'p');
	    return this.add_device(d, name);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Support for creating conductance and capacitance matrices associated with
        //  modified nodal analysis (unknowns are node voltages and inductor and voltage
        //  source currents). 
        //  The linearized circuit is written as 
        //          C d/dt x = G x + rhs
        //  x - vector of node voltages and element currents
        //  rhs - vector of source values
        //  C - Matrix whose values are capacitances and inductances, has many zero rows.
        //  G - Matrix whose values are conductances and +-1's.
	//
	////////////////////////////////////////////////////////////////////////////////

	// add val component between two nodes to matrix M
	// Index of -1 refers to ground node
        Circuit.prototype.add_two_terminal = function(i,j,g,M) {
	    if (i >= 0) {
		M[i][i] += g;
		if (j >= 0) {
		    M[i][j] -= g;
		    M[j][i] -= g;
		    M[j][j] += g;
		}
	    } else if (j >= 0)
		M[j][j] += g;
	}

	// add val component between two nodes to matrix M
	// Index of -1 refers to ground node
        Circuit.prototype.get_two_terminal = function(i,j,x) {
	    var xi_minus_xj = 0;
	    if (i >= 0) xi_minus_xj = x[i];
	    if (j >= 0) xi_minus_xj -= x[j];
	    return xi_minus_xj
	}

        Circuit.prototype.add_conductance_l = function(i,j,g) {
            this.add_two_terminal(i,j,g, this.Gl)
	}

        Circuit.prototype.add_conductance = function(i,j,g) {
            this.add_two_terminal(i,j,g, this.G)
	}

        Circuit.prototype.add_capacitance = function(i,j,c) {
            this.add_two_terminal(i,j,c,this.C)
	}

	// add individual conductance to Gl matrix
	Circuit.prototype.add_to_Gl = function(i,j,g) {
	    if (i >=0 && j >= 0)
		this.Gl[i][j] += g;
	}

	// add individual conductance to Gl matrix
	Circuit.prototype.add_to_G = function(i,j,g) {
	    if (i >=0 && j >= 0)
		this.G[i][j] += g;
	}

	// add individual capacitance to C matrix
	Circuit.prototype.add_to_C = function(i,j,c) {
	    if (i >=0 && j >= 0)
		this.C[i][j] += c;
	}

	// add source info to rhs
        Circuit.prototype.add_to_rhs = function(i,v,rhs) {
	    if (i >= 0)	rhs[i] += v;
	}


	///////////////////////////////////////////////////////////////////////////////
	//
	//  Generic matrix support - making, copying, factoring, rank, etc
	//  Note, Matrices are stored using nested javascript arrays.
	////////////////////////////////////////////////////////////////////////////////

        // Allocate an NxM matrix
        function mat_make(N,M) {
	    var mat = new Array(N);	
	    for (var i = N - 1; i >= 0; --i) {	    
		mat[i] = new Array(M);
		for (var j = M - 1; j >= 0; --j) {	    
		    mat[i][j] = 0.0;
		}
	    }
	    return mat;
	}

        // Form b = scale*Mx
        function mat_v_mult(M,x,b,scale) {
	    var n = M.length;
	    var m = M[0].length;
	    
	    if (n != b.length || m != x.length)
		throw 'Rows of M mismatched to b or cols mismatch to x.';

	    for (var i = 0; i < n; i++) {
		var temp = 0;
		for (var j = 0; j < m; j++) temp += M[i][j]*x[j];
		b[i] = scale*temp;  // Recall the neg in the name
	    }
	}

        // C = scalea*A + scaleb*B, scalea, scaleb eithers numbers or arrays (row scaling)
        function mat_scale_add(A, B, scalea, scaleb, C) {
	    var n = A.length;
	    var m = A[0].length;
	    
	    if (n > B.length || m > B[0].length)
		throw 'Row or columns of A to large for B';
	    if (n > C.length || m > C[0].length)
		throw 'Row or columns of A to large for C';
	    if ((typeof scalea == 'number') && (typeof scaleb == 'number'))
		for (var i = 0; i < n; i++)
		    for (var j = 0; j < m; j++)
			C[i][j] = scalea*A[i][j] + scaleb*B[i][j];
	    else if ((typeof scaleb == 'number') && (scalea instanceof Array))
		for (var i = 0; i < n; i++)
		    for (var j = 0; j < m; j++)
			C[i][j] = scalea[i]*A[i][j] + scaleb*B[i][j];
	    else if ((typeof scaleb instanceof Array) && (scalea instanceof Array))
		for (var i = 0; i < n; i++)
		    for (var j = 0; j < m; j++)
			C[i][j] = scalea[i]*A[i][j] + scaleb[i]*B[i][j];
	    else
		throw 'scalea and scaleb must be scalars or Arrays';
	}

        // Returns a vector of ones and zeros, ones denote algebraic
        // variables (rows that can be removed without changing rank(M).
        Circuit.prototype.algebraic = function(M) {
	    var Nr = M.length
	    Mc = mat_make(Nr, Nr);
	    mat_copy(M,Mc);
	    var R = mat_rank(Mc);

	    var one_if_alg = new Array(Nr);
	    for (var row = 0; row < Nr; row++) {  // psuedo gnd row small
		for (var col = Nr - 1; col >= 0; --col)
		    Mc[row][col] = 0;
		if (mat_rank(Mc) == R)  // Zeroing row left rank unchanged
		    one_if_alg[row] = 1;
		else { // Zeroing row changed rank, put back
		    for (var col = Nr - 1; col >= 0; --col)
			Mc[row][col] = M[row][col];
		    one_if_alg[row] = 0;
		}
	    }
	    return one_if_alg;
	}

        // Copy A -> using the bounds of A
	function mat_copy(src,dest) {
	    var n = src.length;
	    var m = src[0].length;
	    if (n > dest.length || m >  dest[0].length)
		throw 'Rows or cols > rows or cols of dest';

	    for (var i = 0; i < n; i++)
		for (var j = 0; j < m; j++)
		    dest[i][j] = src[i][j];
	}
	    
        // Copy and transpose A -> using the bounds of A
	function mat_copy_transposed(src,dest) {
	    var n = src.length;
	    var m = src[0].length;
	    if (n > dest[0].length || m >  dest.length)
		throw 'Rows or cols > cols or rows of dest';

	    for (var i = 0; i < n; i++)
		for (var j = 0; j < m; j++)
		    dest[j][i] = src[i][j];
	}


	// Uses GE to determine rank.
        function mat_rank(Mo) {
	    var Nr = Mo.length;  // Number of rows
	    var Nc = Mo[0].length;  // Number of columns
	    var temp,i,j;
	    // Make a copy to avoid overwriting
	    M = mat_make(Nr, Nc);
	    mat_copy(Mo,M);

	    // Find matrix maximum entry
	    var max_abs_entry = 0;
	    for(var row = Nr-1; row >= 0; --row) {
		for(var col = Nr-1; col >= 0; --col) {
		    if (Math.abs(M[row][col]) > max_abs_entry)
			max_abs_entry = Math.abs(M[row][col]);
		}
	    }

	    // Gaussian elimination to find rank
	    var the_rank = 0;
	    var start_col = 0;
	    for (var row = 0; row < Nr; row++) {
		// Search for first nonzero column in the remaining rows.
		for (var col = start_col; col < Nc; col++) {
		    var max_v = Math.abs(M[row][col]);
		    var max_row = row;
		    for (var i = row + 1; i < Nr; i++) {
			temp = Math.abs(M[i][col]);
			if (temp > max_v) { max_v = temp; max_row = i; }
		    }
		    // if max_v non_zero, column is nonzero, eliminate in subsequent rows
		    if (Math.abs(max_v) > eps*max_abs_entry) {
			start_col = col+1;
			the_rank += 1;
		        // Swap rows to get max in M[row][col]
			temp = M[row];
			M[row] = M[max_row];
			M[max_row] = temp;

			// now eliminate this column for all subsequent rows
			for (var i = row + 1; i < Nr; i++) {
			    temp = M[i][col]/M[row][col];   // multiplier for current row
			    if (temp != 0)  // subtract 
			    for (var j = col; j < Nc; j++) M[i][j] -= M[row][j]*temp;
			}
			// Now move on to the next row
			break;
		    }
		}
	    }

	    // return the rank
	    return the_rank;
	}

	// Solve Mx=b and return vector x using R^TQ^T factorization. 
        // Multiplication by R^T implicit, should be null-space free soln.
        // M should have the extra column!
        // Almost everything is in-lined for speed, sigh.
        function mat_solve_rq(M, rhs) {

	    var Nr = M.length;  // Number of rows
	    var Nc = M[0].length;  // Number of columns

	    // Copy the rhs in to the last column of M if one is given.
	    if (rhs != null) {
		for (var row = Nr - 1; row >= 0; --row)
		    M[row][Nc-1] = rhs[row];
	    }

	    var mat_scale = 0; // Sets the scale for comparison to zero.
	    var max_nonzero_row = Nr-1;  // Assumes M nonsingular.
	    for (var row = 0; row < Nr; row++) {  
		// Find largest row with largest 2-norm
		var max_row = row;
		var maxsumsq = 0;
		for (var rowp = row; rowp < Nr; rowp++) {
		    var Mr = M[rowp];
		    var sumsq = 0;
		    for (var col = Nc-2; col >= 0; --col)  // Last col=rhs
			sumsq += Mr[col]*Mr[col];
		    if ((row == rowp) || (sumsq > maxsumsq)) {
			max_row = rowp;
			maxsumsq = sumsq;
		    }
		}
		if (max_row > row) { // Swap rows if not max row
		    var temp = M[row];
		    M[row] = M[max_row];
		    M[max_row] = temp;
		}

		// Calculate row norm, save if this is first (largest)
		row_norm = Math.sqrt(maxsumsq);
		if (row == 0) mat_scale = row_norm;

		// Check for all zero rows
		if (row_norm > mat_scale*eps)
		    scale = 1.0/row_norm;
		else {
		    max_nonzero_row = row - 1;  // Rest will be nullspace of M
		    break;
		}


		// Nonzero row, eliminate from rows below
		var Mr = M[row];
		for (var col =  Nc-1; col >= 0; --col) // Scale rhs also
		    Mr[col] *= scale;
		for (var rowp = row + 1; rowp < Nr; rowp++) { // Update.
		    var Mrp = M[rowp];
		    var inner = 0;
		    for (var col =  Nc-2; col >= 0; --col)  // Project 
			inner += Mr[col]*Mrp[col];
		    for (var col =  Nc-1; col >= 0; --col) // Ortho (rhs also)
			Mrp[col] -= inner *Mr[col];
		}
	    }

	    // Last Column of M has inv(R^T)*rhs.  Scale rows of Q to get x.
	    var x = new Array(Nc-1);
	    for (var col = Nc-2; col >= 0; --col)
		x[col] = 0;
	    for (var row = max_nonzero_row; row >= 0; --row) {
		Mr = M[row];
		for (var col = Nc-2; col >= 0; --col) {
		    x[col] += Mr[col]*Mr[Nc-1];
		}
	    }

	    // Return solution.
	    return x;
	}

	// solve Mx=b and return vector x given augmented matrix M = [A | b]
	// Uses Gaussian elimination with partial pivoting
        function mat_solve(M,rhs) {
	    var N = M.length;      // augmented matrix M has N rows, N+1 columns
	    var temp,i,j;

	    // Copy the rhs in to the last column of M if one is given.
	    if (rhs != null) {
		for (var row = 0; row < N ; row++)
		    M[row][N] = rhs[row];
	    }

	    // gaussian elimination
	    for (var col = 0; col < N ; col++) {
		// find pivot: largest abs(v) in this column of remaining rows
		var max_v = Math.abs(M[col][col]);
		var max_col = col;
		for (i = col + 1; i < N; i++) {
		    temp = Math.abs(M[i][col]);
		    if (temp > max_v) { max_v = temp; max_col = i; }
		}

		// if no value found, generate a small conductance to gnd
		// otherwise swap current row with pivot row
		if (max_v == 0) M[col][col] = eps; 
		else {
		    temp = M[col];
		    M[col] = M[max_col];
		    M[max_col] = temp;
		}

		// now eliminate this column for all subsequent rows
		for (i = col + 1; i < N; i++) {
		    temp = M[i][col]/M[col][col];   // multiplier we'll use for current row
		    if (temp != 0)
			// subtract current row from row we're working on
			// remember to process b too!
			for (j = col; j <= N; j++) M[i][j] -= M[col][j]*temp;
		}
	    }

	    // matrix is now upper triangular, so solve for elements of x starting
	    // with the last row
	    var x = new Array(N);
	    for (i = N-1; i >= 0; --i) {
		temp = M[i][N];   // grab b[i] from augmented matrix as RHS
		// subtract LHS term from RHS using known x values
		for (j = N-1; j > i; --j) temp -= M[i][j]*x[j];
		// now compute new x value
		x[i] = temp/M[i][i];
	    }

	    // return solution
	    return x;
	}

	// test solution code, expect x = [2,3,-1]
	//M = [[2,1,-1,8],[-3,-1,2,-11],[-2,1,2,-3]];
	//x = mat_solve(M);
	//y = 1;  // so we have place to set a breakpoint :)

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Device base class
	//
	////////////////////////////////////////////////////////////////////////////////

	function Device() {
	}

	// complete initial set up of device
	Device.prototype.finalize = function() {
	}

        // Load the linear elements in to Gl and C
        Device.prototype.load_linear = function(ckt) {
	}

	// load linear system equations for dc analysis
	// (inductors shorted and capacitors opened)
        Device.prototype.load_dc = function(ckt,soln,rhs) {
	}

	// load linear system equations for tran analysis
	Device.prototype.load_tran = function(ckt,soln) {
	}

	// load linear system equations for ac analysis:
	// current sources open, voltage sources shorted
	// linear models at operating point for everyone else
	Device.prototype.load_ac = function(ckt,rhs) {
	}

	// return time of next breakpoint for the device
	Device.prototype.breakpoint = function(time) {
	    return undefined;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Parse numbers in engineering notation
	//
	///////////////////////////////////////////////////////////////////////////////

	// convert first character of argument into an integer
	function ord(ch) {
	    return ch.charCodeAt(0);
	}

	// convert string argument to a number, accepting usual notations
	// (hex, octal, binary, decimal, floating point) plus engineering
	// scale factors (eg, 1k = 1000.0 = 1e3).
	// return default if argument couldn't be interpreted as a number
	function parse_number(s,default_v) {
	    var slen = s.length;
	    var multiplier = 1;
	    var result = 0;
	    var index = 0;

	    // skip leading whitespace
	    while (index < slen && s.charAt(index) <= ' ') index += 1;
	    if (index == slen) return default_v;

	    // check for leading sign
	    if (s.charAt(index) == '-') {
		multiplier = -1;
		index += 1;
	    } else if (s.charAt(index) == '+')
		index += 1;
	    var start = index;   // remember where digits start

	    // if leading digit is 0, check for hex, octal or binary notation
	    if (index >= slen) return default_v;
	    else if (s.charAt(index) == '0') {
		index += 1;
		if (index >= slen) return 0;
		if (s.charAt(index) == 'x' || s.charAt(index) == 'X') { // hex
		    while (true) {
			index += 1;
			if (index >= slen) break;
			if (s.charAt(index) >= '0' && s.charAt(index) <= '9')
			    result = result*16 + ord(s.charAt(index)) - ord('0');
			else if (s.charAt(index) >= 'A' && s.charAt(index) <= 'F')
			    result = result*16 + ord(s.charAt(index)) - ord('A') + 10;
			else if (s.charAt(index) >= 'a' && s.charAt(index) <= 'f')
			    result = result*16 + ord(s.charAt(index)) - ord('a') + 10;
			else break;
		    }
		    return result*multiplier;
		} else if (s.charAt(index) == 'b' || s.charAt(index) == 'B') {  // binary
		    while (true) {
			index += 1;
			if (index >= slen) break;
			if (s.charAt(index) >= '0' && s.charAt(index) <= '1')
			    result = result*2 + ord(s.charAt(index)) - ord('0');
			else break;
		    }
		    return result*multiplier;
		} else if (s.charAt(index) != '.') { // octal
		    while (true) {
			if (s.charAt(index) >= '0' && s.charAt(index) <= '7')
			    result = result*8 + ord(s.charAt(index)) - ord('0');
			else break;
			index += 1;
			if (index >= slen) break;
		    }
		    return result*multiplier;
		}
	    }
    
	    // read decimal integer or floating-point number
	    while (true) {
		if (s.charAt(index) >= '0' && s.charAt(index) <= '9')
		    result = result*10 + ord(s.charAt(index)) - ord('0');
		else break;
		index += 1;
		if (index >= slen) break;
	    }

	    // fractional part?
	    if (index < slen && s.charAt(index) == '.') {
		while (true) {
		    index += 1;
		    if (index >= slen) break;
		    if (s.charAt(index) >= '0' && s.charAt(index) <= '9') {
			result = result*10 + ord(s.charAt(index)) - ord('0');
			multiplier *= 0.1;
		    } else break;
		}
	    }

	    // if we haven't seen any digits yet, don't check
	    // for exponents or scale factors
	    if (index == start) return default_v;

	    // type of multiplier determines type of result:
	    // multiplier is a float if we've seen digits past
	    // a decimal point, otherwise it's an int or long.
	    // Up to this point result is an int or long.
	    result *= multiplier;

	    // now check for exponent or engineering scale factor.  If there
	    // is one, result will be a float.
	    if (index < slen) {
		var scale = s.charAt(index);
		index += 1;
		if (scale == 'e' || scale == 'E') {
		    var exponent = 0;
		    multiplier = 10.0;
		    if (index < slen) {
			if (s.charAt(index) == '+') index += 1;
			else if (s.charAt(index) == '-') {
			    index += 1;
			    multiplier = 0.1;
			}
		    }
		    while (index < slen) {
			if (s.charAt(index) >= '0' && s.charAt(index) <= '9') {
			    exponent = exponent*10 + ord(s.charAt(index)) - ord('0');
			    index += 1;
			} else break;
		    }
		    while (exponent > 0) {
			exponent -= 1;
			result *= multiplier;
		    }
		} else if (scale == 't' || scale == 'T') result *= 1e12;
		else if (scale == 'g' || scale == 'G') result *= 1e9;
		else if (scale == 'M') result *= 1e6;
		else if (scale == 'k' || scale == 'K') result *= 1e3;
		else if (scale == 'm') result *= 1e-3;
		else if (scale == 'u' || scale == 'U') result *= 1e-6;
		else if (scale == 'n' || scale == 'N') result *= 1e-9;
		else if (scale == 'p' || scale == 'P') result *= 1e-12;
		else if (scale == 'f' || scale == 'F') result *= 1e-15;
	    }
	    // ignore any remaining chars, eg, 1kohms returns 1000
	    return result;
	}

	Circuit.prototype.parse_number = parse_number;  // make it easy to call from outside

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Sources
	//
	///////////////////////////////////////////////////////////////////////////////

	// argument is a string describing the source's value (see comments for details)
	// source types: dc,step,square,triangle,sin,pulse,pwl,pwl_repeating

	// returns an object with the following attributes:
	//   fun -- name of source function
	//   args -- list of argument values
	//   value(t) -- compute source value at time t
	//   inflection_point(t) -- compute time after t when a time point is needed
	//   dc -- value at time 0
	//   period -- repeat period for periodic sources (0 if not periodic)
	
	function parse_source(v) {
	    // generic parser: parse v as either <value> or <fun>(<value>,...)
	    var src = new Object();
	    src.period = 0; // Default not periodic
	    src.value = function(t) { return 0; }  // overridden below
	    src.inflection_point = function(t) { return undefined; };  // may be overridden below

	    // see if there's a "(" in the description
	    var index = v.indexOf('(');
	    var ch;
	    if (index >= 0) {
		src.fun = v.slice(0,index);   // function name is before the "("
		src.args = [];	// we'll push argument values onto this list
		var end = v.indexOf(')',index);
		if (end == -1) end = v.length;

		index += 1;     // start parsing right after "("
		while (index < end) {
		    // figure out where next argument value starts
		    ch = v.charAt(index);
		    if (ch <= ' ') { index++; continue; }
		    // and where it ends
		    var arg_end = v.indexOf(',',index);
		    if (arg_end == -1) arg_end = end;
		    // parse and save result in our list of arg values
		    src.args.push(parse_number(v.slice(index,arg_end),undefined));
		    index = arg_end + 1;
		}
	    } else {
		src.fun = 'dc';
		src.args = [parse_number(v,0)];
	    }

	    // post-processing for constant sources
	    // dc(v)
	    if (src.fun == 'dc') {
		var v = arg_value(src.args,0,0);
		src.args = [v];
		src.value = function(t) { return v; }  // closure
	    }

	    // post-processing for impulse sources
	    // impulse(height,width)
	    else if (src.fun == 'impulse') {
		var h = arg_value(src.args,0,1);  // default height: 1
		var w = Math.abs(arg_value(src.args,2,1e-9));  // default width: 1ns
		src.args = [h,w];  // remember any defaulted values
		pwl_source(src,[0,0,w/2,h,w,0],false);
	    }

	    // post-processing for step sources
	    // step(v_init,v_plateau,t_delay,t_rise)
	    else if (src.fun == 'step') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var td = Math.max(0,arg_value(src.args,2,0));  // time step starts
		var tr = Math.abs(arg_value(src.args,3,1e-9));  // default rise time: 1ns
		src.args = [v1,v2,td,tr];  // remember any defaulted values
		pwl_source(src,[td,v1,td+tr,v2],false);
	    }

	    // post-processing for square wave
	    // square(v_init,v_plateau,freq,duty_cycle)
	    else if (src.fun == 'square') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var freq = Math.abs(arg_value(src.args,2,1));  // default frequency: 1Hz
		var duty_cycle  = Math.min(100,Math.abs(arg_value(src.args,3,50)));  // default duty cycle: 0.5
		src.args = [v1,v2,freq,duty_cycle];  // remember any defaulted values

		var per = freq == 0 ? Infinity : 1/freq;
		var t_change = 0.01 * per;   // rise and fall time
		var t_pw = .01 * duty_cycle * 0.98 * per;  // fraction of cycle minus rise and fall time
		pwl_source(src,[0,v1,t_change,v2,t_change+t_pw,
				v2,t_change+t_pw+t_change,v1,per,v1],true);
	    }

	    // post-processing for triangle
	    // triangle(v_init,v_plateua,t_period)
	    else if (src.fun == 'triangle') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var freq = Math.abs(arg_value(src.args,2,1));  // default frequency: 1s
		src.args = [v1,v2,freq];  // remember any defaulted values

		var per = freq == 0 ? Infinity : 1/freq;
		pwl_source(src,[0,v1,per/2,v2,per,v1],true);
	    }

	    // post-processing for pwl and pwlr sources
	    // pwl[r](t1,v1,t2,v2,...)
	    else if (src.fun == 'pwl' || src.fun == 'pwl_repeating') {
		pwl_source(src,src.args,src.fun == 'pwl_repeating');
	    }

	    // post-processing for pulsed sources
	    // pulse(v_init,v_plateau,t_delay,t_rise,t_fall,t_width,t_period)
	    else if (src.fun == 'pulse') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var td = Math.max(0,arg_value(src.args,2,0));  // time pulse starts
		var tr = Math.abs(arg_value(src.args,3,1e-9));  // default rise time: 1ns
		var tf = Math.abs(arg_value(src.args,4,1e-9));  // default rise time: 1ns
		var pw = Math.abs(arg_value(src.args,5,1e9));  // default pulse width: "infinite"
		var per = Math.abs(arg_value(src.args,6,1e9));  // default period: "infinite"
		src.args = [v1,v2,td,tr,tf,pw,per];

		var t1 = td;       // time when v1 -> v2 transition starts
		var t2 = t1 + tr;  // time when v1 -> v2 transition ends
		var t3 = t2 + pw;  // time when v2 -> v1 transition starts
		var t4 = t3 + tf;  // time when v2 -> v1 transition ends

		pwl_source(src,[t1,v1, t2,v2, t3,v2, t4,v1, per,v1],true);
	    }

	    // post-processing for sinusoidal sources
	    // sin(v_offset,v_amplitude,freq_hz,t_delay,phase_offset_degrees)
	    else if (src.fun == 'sin') {
		var voffset = arg_value(src.args,0,0);  // default offset voltage: 0V
		var va = arg_value(src.args,1,1);  // default amplitude: -1V to 1V
		var freq = Math.abs(arg_value(src.args,2,1));  // default frequency: 1Hz
		src.period = 1.0/freq;

		var td = Math.max(0,arg_value(src.args,3,0));  // default time delay: 0sec
		var phase = arg_value(src.args,4,0);  // default phase offset: 0 degrees
		src.args = [voffset,va,freq,td,phase];

		phase /= 360.0;

		// return value of source at time t
		src.value = function(t) {  // closure
		    if (t < td) return voffset + va*Math.sin(2*Math.PI*phase);
		    else return voffset + va*Math.sin(2*Math.PI*(freq*(t - td) + phase));
		}

		// return time of next inflection point after time t
		src.inflection_point = function(t) {	// closure
		    if (t < td) return td;
		    else return undefined;
		}
	    }
	
	    // object has all the necessary info to compute the source value and inflection points
	    src.dc = src.value(0);   // DC value is value at time 0
	    return src;
	}

	function pwl_source(src,tv_pairs,repeat) {
	    var nvals = tv_pairs.length;
	    if (repeat)
		src.period = tv_pairs[nvals-2];  // Repeat period of source
	    if (nvals % 2 == 1) npts -= 1;  // make sure it's even!

	    if (nvals <= 2) {
		// handle degenerate case
		src.value = function(t) { return nvals == 2 ? tv_pairs[1] : 0; }
		src.inflection_point = function(t) { return undefined; }
	    } else {
		src.value = function(t) { // closure
		    if (repeat)
			// make time periodic if values are to be repeated
			t = Math.fmod(t,tv_pairs[nvals-2]);
		    var last_t = tv_pairs[0];
		    var last_v = tv_pairs[1];
		    if (t > last_t) {
			var next_t,next_v;
			for (var i = 2; i < nvals; i += 2) {
			    next_t = tv_pairs[i];
			    next_v = tv_pairs[i+1];
			    if (next_t > last_t)  // defend against bogus tv pairs
				if (t < next_t)
				    return last_v + (next_v - last_v)*(t - last_t)/(next_t - last_t);
			    last_t = next_t;
			    last_v = next_v;
			}
		    }
		    return last_v;
		}
		src.inflection_point = function(t) {  // closure
		    if (repeat)
			// make time periodic if values are to be repeated
			t = Math.fmod(t,tv_pairs[nvals-2]);
		    for (var i = 0; i < nvals; i += 2) {
			var next_t = tv_pairs[i];
			if (t < next_t) return next_t;
		    }
		    return undefined;
		}
	    }
	}

	// helper function: return args[index] if present, else default_v
	function arg_value(args,index,default_v) {
	    if (index < args.length) {
		var result = args[index];
		if (result === undefined) result = default_v;
		return result;
	    } else return default_v;
	}

	// we need fmod in the Math library!
	Math.fmod = function(numerator,denominator) {
	    var quotient = Math.floor(numerator/denominator);
	    return numerator - quotient*denominator;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Sources
	//
	///////////////////////////////////////////////////////////////////////////////

        function VSource(npos,nneg,branch,v) {
	    Device.call(this);
	    
	    this.src = parse_source(v);
	    this.npos = npos;
	    this.nneg = nneg;
	    this.branch = branch;
	}
	VSource.prototype = new Device();
	VSource.prototype.constructor = VSource;

	// load linear part for source evaluation
        VSource.prototype.load_linear = function(ckt) {
	    // MNA stamp for independent voltage source
	    ckt.add_to_Gl(this.branch,this.npos,1.0);
	    ckt.add_to_Gl(this.branch,this.nneg,-1.0);
	    ckt.add_to_Gl(this.npos,this.branch,1.0);
	    ckt.add_to_Gl(this.nneg,this.branch,-1.0);
	}

	// Source voltage added to b.
        VSource.prototype.load_dc = function(ckt,soln,rhs) {
	    ckt.add_to_rhs(this.branch,this.src.dc,rhs);  
	}

	// Load time-dependent value for voltage source for tran
        VSource.prototype.load_tran = function(ckt,soln,rhs,time) {
	    ckt.add_to_rhs(this.branch,this.src.value(time),rhs);  
	}

	// return time of next breakpoint for the device
	VSource.prototype.breakpoint = function(time) {
	    return this.src.inflection_point(time);
	}

	// small signal model ac value
        VSource.prototype.load_ac = function(ckt,rhs) {
	    ckt.add_to_rhs(this.branch,1.0,rhs);
	}

	function ISource(npos,nneg,v) {
	    Device.call(this);

	    this.src = parse_source(v);
	    this.npos = npos;
	    this.nneg = nneg;
	}
	ISource.prototype = new Device();
	ISource.prototype.constructor = ISource;

        ISource.prototype.load_linear = function(ckt) {
	    // Current source is open when off, no linear contribution
	}

	// load linear system equations for dc analysis
	ISource.prototype.load_dc = function(ckt,soln,rhs) {
	    var is = this.src.dc;

	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.npos,-is,rhs);  // current flow into npos
	    ckt.add_to_rhs(this.nneg,is,rhs);   // and out of nneg
	}

	// load linear system equations for tran analysis (just like DC)
        ISource.prototype.load_tran = function(ckt,soln,rhs,time) {
	    var is = this.src.value(time);

	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.npos,-is,rhs);  // current flow into npos
	    ckt.add_to_rhs(this.nneg,is,rhs);   // and out of nneg
	}

	// return time of next breakpoint for the device
	ISource.prototype.breakpoint = function(time) {
	    return this.src.inflection_point(time);
	}

	// small signal model: open circuit
        ISource.prototype.load_ac = function(ckt,rhs) {
	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.npos,-1.0,rhs);  // current flow into npos
	    ckt.add_to_rhs(this.nneg,1.0,rhs);   // and out of nneg
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Resistor
	//
	///////////////////////////////////////////////////////////////////////////////

	function Resistor(n1,n2,v) {
	    Device.call(this);
	    this.n1 = n1;
	    this.n2 = n2;
	    this.g = 1.0/v;
	}
	Resistor.prototype = new Device();
	Resistor.prototype.constructor = Resistor;

        Resistor.prototype.load_linear = function(ckt) {
	    // MNA stamp for admittance g
	    ckt.add_conductance_l(this.n1,this.n2,this.g);
	}

	Resistor.prototype.load_dc = function(ckt) {
	    // Nothing to see here, move along.
	}

	Resistor.prototype.load_tran = function(ckt,soln) {
	}

	Resistor.prototype.load_ac = function(ckt) {
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Diode
	//
	///////////////////////////////////////////////////////////////////////////////

	function Diode(n1,n2,v,type) {
	    Device.call(this);
	    this.anode = n1;
	    this.cathode = n2;
	    this.area = v;
	    this.type = type;  // 'normal' or 'ideal'
	    this.is = 1.0e-14;
	    this.ais = this.area * this.is;
	    this.vt = (type == 'normal') ? 25.8e-3 : 0.1e-3;  // 26mv or .1mv
	    this.exp_arg_max = 50;  // less than single precision max.
	    this.exp_max = Math.exp(this.exp_arg_max);
	}
	Diode.prototype = new Device();
        Diode.prototype.constructor = Diode;

        Diode.prototype.load_linear = function(ckt) {
	    // Diode is not linear, has no linear piece.
	}

        Diode.prototype.load_dc = function(ckt,soln,rhs) {
	    var vd = ckt.get_two_terminal(this.anode, this.cathode, soln);
	    var exp_arg = vd / this.vt;
	    var temp1, temp2;
	    // Estimate exponential with a quadratic if arg too big.
	    var abs_exp_arg = Math.abs(exp_arg);
	    var d_arg = abs_exp_arg - this.exp_arg_max;
	    if (d_arg > 0) {
		var quad = 1 + d_arg + 0.5*d_arg*d_arg;
		temp1 = this.exp_max * quad;
		temp2 = this.exp_max * (1 + d_arg);
	    } else {
		temp1 = Math.exp(abs_exp_arg);
		temp2 = temp1;
	    }
	    if (exp_arg < 0) {  // Use exp(-x) = 1.0/exp(x)
		temp1 = 1.0/temp1;
		temp2 = (temp1*temp2)*temp1;
	    }
	    var id = this.ais * (temp1 - 1);
	    var gd = this.ais * (temp2 / this.vt);

	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.anode,-id,rhs);  // current flows into anode
	    ckt.add_to_rhs(this.cathode,id,rhs);   // and out of cathode
	    ckt.add_conductance(this.anode,this.cathode,gd);
	}

        Diode.prototype.load_tran = function(ckt,soln,rhs,time) {
	    this.load_dc(ckt,soln,rhs);
	}

	Diode.prototype.load_ac = function(ckt) {
	}


	///////////////////////////////////////////////////////////////////////////////
	//
	//  Capacitor
	//
	///////////////////////////////////////////////////////////////////////////////

	function Capacitor(n1,n2,v) {
	    Device.call(this);
	    this.n1 = n1;
	    this.n2 = n2;
	    this.value = v;
	}
	Capacitor.prototype = new Device();
	Capacitor.prototype.constructor = Capacitor;

        Capacitor.prototype.load_linear = function(ckt) {
	    // MNA stamp for capacitance matrix 
	    ckt.add_capacitance(this.n1,this.n2,this.value);
	}

	Capacitor.prototype.load_dc = function(ckt,soln,rhs) {
	}

	Capacitor.prototype.load_ac = function(ckt) {
	}

	Capacitor.prototype.load_tran = function(ckt) {
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Inductor
	//
	///////////////////////////////////////////////////////////////////////////////

	function Inductor(n1,n2,branch,v) {
	    Device.call(this);
	    this.n1 = n1;
	    this.n2 = n2;
	    this.branch = branch;
	    this.value = v;
	}
	Inductor.prototype = new Device();
	Inductor.prototype.constructor = Inductor;

        Inductor.prototype.load_linear = function(ckt) {
	    // MNA stamp for inductor linear part
	    // L on diag of C because L di/dt = v(n1) - v(n2)
	    ckt.add_to_Gl(this.n1,this.branch,1);
	    ckt.add_to_Gl(this.n2,this.branch,-1);
	    ckt.add_to_Gl(this.branch,this.n1,-1);
	    ckt.add_to_Gl(this.branch,this.n2,1);
	    ckt.add_to_C(this.branch,this.branch,this.value)
	}

	Inductor.prototype.load_dc = function(ckt,soln,rhs) {
	    // Inductor is a short at dc, so is linear.
	}

	Inductor.prototype.load_ac = function(ckt) {
	}

	Inductor.prototype.load_tran = function(ckt) {
	}



	///////////////////////////////////////////////////////////////////////////////
	//
	//  Simple Voltage-Controlled Voltage Source Op Amp model 
	//
	///////////////////////////////////////////////////////////////////////////////

        function Opamp(np,nn,no,ng,branch,A,name) {
	    Device.call(this);
	    this.np = np;
	    this.nn = nn;
	    this.no = no;
	    this.ng = ng;
	    this.branch = branch;
	    this.gain = A;
	    this.name = name;
	}

	Opamp.prototype = new Device();
        Opamp.prototype.constructor = Opamp;
        
        Opamp.prototype.load_linear = function(ckt) {
            // MNA stamp for VCVS: 1/A(v(no) - v(ng)) - (v(np)-v(nn))) = 0.
	    var invA = 1.0/this.gain;
	    ckt.add_to_Gl(this.no,this.branch,1);
	    ckt.add_to_Gl(this.ng,this.branch,-1);
	    ckt.add_to_Gl(this.branch,this.no,invA);
	    ckt.add_to_Gl(this.branch,this.ng,-invA);
	    ckt.add_to_Gl(this.branch,this.np,-1);
	    ckt.add_to_Gl(this.branch,this.nn,1);
	}

	Opamp.prototype.load_dc = function(ckt,soln,rhs) {
	    // Op-amp is linear.
	}

	Opamp.prototype.load_ac = function(ckt) {
	}

	Opamp.prototype.load_tran = function(ckt) {
	}



	///////////////////////////////////////////////////////////////////////////////
	//
	//  Simplified MOS FET with no bulk connection and no body effect.
	//
	///////////////////////////////////////////////////////////////////////////////


        function Fet(d,g,s,ratio,name,type) {
	    Device.call(this);
	    this.d = d;
	    this.g = g;
	    this.s = s;
	    this.name = name;
	    this.ratio = ratio;
	    if (type != 'n' && type != 'p')
	    { throw 'fet type is not n or p';
	    }
	    this.type_sign = (type == 'n') ? 1 : -1;
	    this.vt = 0.5;
	    this.kp = 20e-6;
            this.beta = this.kp * this.ratio;
	    this.lambda = 0.05;
	}
	Fet.prototype = new Device();
        Fet.prototype.constructor = Fet;

        Fet.prototype.load_linear = function(ckt) {
	    // FET's are nonlinear, just like javascript progammers
	}

        Fet.prototype.load_dc = function(ckt,soln,rhs) {
	    var vds = this.type_sign * ckt.get_two_terminal(this.d, this.s, soln);
	    if (vds < 0) { // Drain and source have swapped roles
		var temp = this.d;
		this.d = this.s;
		this.s = temp;
		vds = this.type_sign * ckt.get_two_terminal(this.d, this.s, soln);
	    }
	    var vgs = this.type_sign * ckt.get_two_terminal(this.g, this.s, soln);
	    var vgst = vgs - this.vt;
	    with (this) {
		var gmgs,ids,gds;
		if (vgst > 0.0 ) { // vgst < 0, transistor off, no subthreshold here.
		    if (vgst < vds) { /* Saturation. */
			gmgs =  beta * (1 + (lambda * vds)) * vgst;
			ids = type_sign * 0.5 * gmgs * vgst;
			gds = 0.5 * beta * vgst * vgst * lambda;
		    } else {  /* Linear region */
			gmgs =  beta * (1 + lambda * vds);
			ids = type_sign * gmgs * vds * (vgst - 0.50 * vds);
			gds = gmgs * (vgst - vds) + beta * lambda * vds * (vgst - 0.5 * vds);
			gmgs *= vds;
		    }
		    ckt.add_to_rhs(d,-ids,rhs);  // current flows into the drain
		    ckt.add_to_rhs(s, ids,rhs);   // and out the source		    
		    ckt.add_conductance(d,s,gds);
		    ckt.add_to_G(s,s, gmgs);
		    ckt.add_to_G(d,s,-gmgs);
		    ckt.add_to_G(d,g, gmgs);
		    ckt.add_to_G(s,g,-gmgs);
		}
	    }
	}

	Fet.prototype.load_tran = function(ckt,soln,rhs) {
	    this.load_dc(ckt,soln,rhs);
	}

	Fet.prototype.load_ac = function(ckt) {
	}


	///////////////////////////////////////////////////////////////////////////////
	//
	//  Module definition
	//
	///////////////////////////////////////////////////////////////////////////////
	var module = {
	    'Circuit': Circuit,
	    'parse_number': parse_number,
	    'parse_source': parse_source
	}
	return module;
    }());

/////////////////////////////////////////////////////////////////////////////
//
//  Simple schematic capture
//
////////////////////////////////////////////////////////////////////////////////

// Copyright (C) 2011 Massachusetts Institute of Technology

// add schematics to a document with 
//
//   <input type="hidden" class="schematic" name="unique_form_id" value="JSON netlist..." .../>
//
// other attributes you can add to the input tag:
//   width -- width in pixels of diagram
//   height -- height in pixels of diagram
//   parts -- comma-separated list of parts for parts bin (see parts_map),
//            parts="" disables editing of diagram

// JSON schematic representation:
//  sch :=  [part, part, ...]
//  part := [type, coords, properties, connections]
//  type := string (see parts_map)
//  coords := [number, ...]  // (x,y,rot) or (x1,y1,x2,y2)
//  properties := {name: value, ...}
//  connections := [node, ...]   // one per connection point in canoncial order
//  node := string
// need a netlist? just use the part's type, properites and connections

// TO DO:
// - wire labels?
// - zoom/scroll canvas
// - rotate multiple objects around their center of mass
// - rubber band wires when moving components

// set up each schematic entry widget
function update_schematics() {
    // set up each schematic on the page
    var schematics = $('.schematic');
    for (var i = 0; i < schematics.length; ++i)
	if (schematics[i].getAttribute("loaded") != "true") {
	    try {
		new schematic.Schematic(schematics[i]);
	    } catch (err) {
		var msgdiv = document.createElement('div');
		msgdiv.style.border = 'thick solid #FF0000';
		msgdiv.style.margins = '20px';
		msgdiv.style.padding = '20px';
		var msg = document.createTextNode('Sorry, there a browser error in starting the schematic tool.  The tool is known to be compatible with the latest versions of Firefox and Chrome, which we recommend you use.');
		msgdiv.appendChild(msg);
		schematics[i].parentNode.insertBefore(msgdiv,schematics[i]);
	    }
	    schematics[i].setAttribute("loaded","true");
	}
}
window.update_schematics = update_schematics;

// add ourselves to the tasks that get performed when window is loaded
function add_schematic_handler(other_onload) {
    return function() {
	// execute othe onload functions first
	if (other_onload) other_onload();

	update_schematics();
    }
}
/*
 * THK: Attaching update_schematic to window.onload is rather presumptuous...
 *      The function is called for EVERY page load, whether in courseware or in
 *      course info, in 6.002x or the public health course. It is also redundant
 *      because courseware includes an explicit call to update_schematic after
 *      each ajax exchange. In this case, calling update_schematic twice appears 
 *      to contribute to a bug in Firefox that does not render the schematic
 *      properly depending on timing.
 */
//window.onload = add_schematic_handler(window.onload);

// ask each schematic input widget to update its value field for submission
function prepare_schematics() {
    var schematics = $('.schematic');
    for (var i = schematics.length - 1; i >= 0; i--)
	schematics[i].schematic.update_value();
}

schematic = (function() {
	background_style = 'rgb(220,220,220)';
	element_style = 'rgb(255,255,255)';
	thumb_style = 'rgb(128,128,128)';
	normal_style = 'rgb(0,0,0)';  // default drawing color
	component_style = 'rgb(64,64,255)';  // color for unselected components
	selected_style = 'rgb(64,255,64)';  // highlight color for selected components
	grid_style = "rgb(128,128,128)";
	annotation_style = 'rgb(255,64,64)';  // color for diagram annotations

	property_size = 5;  // point size for Component property text
	annotation_size = 6;  // point size for diagram annotations

	// list of all the defined parts
	parts_map = {
	    'g': [Ground, 'Ground connection'],
	    'L': [Label, 'Node label'],
	    'v': [VSource, 'Voltage source'],
	    'i': [ISource, 'Current source'],
	    'r': [Resistor, 'Resistor'],
	    'c': [Capacitor, 'Capacitor'],
	    'l': [Inductor, 'Inductor'],
	    'o': [OpAmp, 'Op Amp'],
	    'd': [Diode, 'Diode'],
	    'n': [NFet, 'NFet'],
	    'p': [PFet, 'PFet'],
	    's': [Probe, 'Voltage Probe'],
	    'a': [Ammeter, 'Current Probe']
	};

	// global clipboard
	if (typeof sch_clipboard == 'undefined')
	    sch_clipboard = [];

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Schematic = diagram + parts bin + status area
	//
	////////////////////////////////////////////////////////////////////////////////

	// setup a schematic by populating the <div> with the appropriate children
	function Schematic(input) {
	    // set up diagram viewing parameters
	    this.show_grid = true;
	    this.grid = 8;
	    this.scale = 2;
	    this.origin_x = input.getAttribute("origin_x");
	    if (this.origin_x == undefined) this.origin_x = 0;
	    this.origin_y = input.getAttribute("origin_y");
	    if (this.origin_y == undefined) this.origin_y = 0;
	    this.cursor_x = 0;
	    this.cursor_y = 0;

	    this.window_list = [];  // list of pop-up windows in increasing z order

	    // use user-supplied list of parts if supplied
	    // else just populate parts bin with all the parts
	    this.edits_allowed = true;
	    var parts = input.getAttribute('parts');
	    if (parts == undefined || parts == 'None') {
		parts = new Array();
		for (var p in parts_map) parts.push(p);
	    } else if (parts == '') {
		this.edits_allowed = false;
		parts = [];
	    } else parts = parts.split(',');

	    // now add the parts to the parts bin
	    this.parts_bin = [];
	    for (var i = 0; i < parts.length; i++) {
		var part = new Part(this);
		var pm = parts_map[parts[i]];
		part.set_component(new pm[0](0,0,0),pm[1]);
		this.parts_bin.push(part);
	    }

	    // use user-supplied list of analyses, otherwise provide them all
	    // analyses="" means no analyses
	    var analyses = input.getAttribute('analyses');
	    if (analyses == undefined || analyses == 'None')
		analyses = ['dc','ac','tran'];
	    else if (analyses == '') analyses = [];
	    else analyses = analyses.split(',');

	    if (parts.length == 0 && analyses.length == 0) this.diagram_only = true;
	    else this.diagram_only = false;

	    // see what we need to submit.  Expecting attribute of the form
	    // submit_analyses="{'tran':[[node_name,t1,t2,t3],...],
	    //                   'ac':[[node_name,f1,f2,...],...]}"
	    var submit = input.getAttribute('submit_analyses');
	    if (submit && submit.indexOf('{') != -1)
		this.submit_analyses = JSON.parse(submit);
	    else
		this.submit_analyses = undefined;

	    // toolbar
	    this.tools = new Array();
	    this.toolbar = [];

        /* DISABLE HELP BUTTON (target URL not consistent with multicourse hierarchy) -- SJSU
	    if (!this.diagram_only) {
		this.tools['help'] = this.add_tool(help_icon,'Help: display help page',this.help);
		this.enable_tool('help',true);
		this.toolbar.push(null);  // spacer
	    }
        END DISABLE HELP BUTTON -- SJSU */

	    if (this.edits_allowed) {
		this.tools['grid'] = this.add_tool(grid_icon,'Grid: toggle grid display',this.toggle_grid);
		this.enable_tool('grid',true);
		this.tools['cut'] = this.add_tool(cut_icon,'Cut: move selected components from diagram to the clipboard',this.cut);
		this.tools['copy'] = this.add_tool(copy_icon,'Copy: copy selected components into the clipboard',this.copy);
		this.tools['paste'] = this.add_tool(paste_icon,'Paste: copy clipboard into the diagram',this.paste);
		this.toolbar.push(null);  // spacer
	    }

	    // simulation interface if cktsim.js is loaded
	    if (typeof cktsim != 'undefined') {
		if (analyses.indexOf('dc') != -1) {
		    this.tools['dc'] = this.add_tool('DC','DC Analysis',this.dc_analysis);
		    this.enable_tool('dc',true);
		    this.dc_max_iters = '1000';  // default values dc solution
		}

		if (analyses.indexOf('ac') != -1) {
		    this.tools['ac'] = this.add_tool('AC','AC Small-Signal Analysis',this.setup_ac_analysis);
		    this.enable_tool('ac',true);
		    this.ac_npts = '50'; // default values for AC Analysis
		    this.ac_fstart = '10';
		    this.ac_fstop = '1G';
		    this.ac_source_name = undefined;
		}

		if (analyses.indexOf('tran') != -1) {
		    this.tools['tran'] = this.add_tool('TRAN','Transient Analysis',this.transient_analysis);
		    this.enable_tool('tran',true);
		    this.tran_npts = '100';  // default values for transient analysis
		    this.tran_tstop = '1';
		}
	    }
 
	    // set up diagram canvas
	    this.canvas = document.createElement('canvas');
	    this.width = input.getAttribute('width');
	    this.width = parseInt(this.width == undefined ? '400' : this.width);
	    this.canvas.width = this.width;
	    this.height = input.getAttribute('height');
	    this.height = parseInt(this.height == undefined ? '300' : this.height);
	    this.canvas.height = this.height;

	    this.sctl_r = 16;   // scrolling control parameters
	    this.sctl_x = this.sctl_r + 8;   // upper left
	    this.sctl_y = this.sctl_r + 8;
	    this.zctl_left = this.sctl_x - 8;
	    this.zctl_top = this.sctl_y + this.sctl_r + 8;

	    // repaint simply draws this buffer and then adds selected elements on top
	    this.bg_image = document.createElement('canvas');
	    this.bg_image.width = this.width;
	    this.bg_image.height = this.height;

	    if (!this.diagram_only) {
		this.canvas.tabIndex = 1; // so we get keystrokes
		this.canvas.style.borderStyle = 'solid';
		this.canvas.style.borderWidth = '1px';
		this.canvas.style.borderColor = grid_style;
		this.canvas.style.outline = 'none';
	    }

	    this.canvas.schematic = this;
	    if (this.edits_allowed) {
		this.canvas.addEventListener('mousemove',schematic_mouse_move,false);
		this.canvas.addEventListener('mouseover',schematic_mouse_enter,false);
		this.canvas.addEventListener('mouseout',schematic_mouse_leave,false);
		this.canvas.addEventListener('mousedown',schematic_mouse_down,false);
		this.canvas.addEventListener('mouseup',schematic_mouse_up,false);
		this.canvas.addEventListener('mousewheel',schematic_mouse_wheel,false);
		this.canvas.addEventListener('DOMMouseScroll',schematic_mouse_wheel,false);  // for FF
		this.canvas.addEventListener('dblclick',schematic_double_click,false);
		this.canvas.addEventListener('keydown',schematic_key_down,false);
		this.canvas.addEventListener('keyup',schematic_key_up,false);
	    }

	    // set up message area
	    if (!this.diagram_only) {
		this.status_div = document.createElement('div');
		this.status = document.createTextNode('');
		this.status_div.appendChild(this.status);
		this.status_div.style.height = status_height + 'px';
	    } else this.status_div = undefined;

	    this.connection_points = new Array();  // location string => list of cp's
	    this.components = [];

	    this.dragging = false;
	    this.select_rect = undefined;
	    this.wire = undefined;

	    this.operating_point = undefined;  // result from DC analysis
	    this.dc_results = undefined;   // saved analysis results for submission
	    this.ac_results = undefined;   // saved analysis results for submission
	    this.transient_results = undefined;   // saved analysis results for submission

	    // state of modifier keys
	    this.ctrlKey = false;
	    this.shiftKey = false;
	    this.altKey = false;
	    this.cmdKey = false;

	    // make sure other code can find us!
	    input.schematic = this;
	    this.input = input;

	    // set up DOM -- use nested tables to do the layout
	    var table,tr,td;
	    table = document.createElement('table');
	    table.rules = 'none';
	    if (!this.diagram_only) {
		table.frame = 'box';
		table.style.borderStyle = 'solid';
		table.style.borderWidth = '2px';
		table.style.borderColor = normal_style;
		table.style.backgroundColor = background_style;
	    }

	    // add tools to DOM
	    if (this.toolbar.length > 0) {
		tr = document.createElement('tr');
		table.appendChild(tr);
		td = document.createElement('td');
		td.style.verticalAlign = 'top';
		td.colSpan = 2;
		tr.appendChild(td);
		for (var i = 0; i < this.toolbar.length; ++i) {
		    var tool = this.toolbar[i];
		    if (tool != null) td.appendChild(tool);
		}
	    }
	    
	    // add canvas and parts bin to DOM
	    tr = document.createElement('tr');
	    table.appendChild(tr);

	    td = document.createElement('td');
	    tr.appendChild(td);
	    var wrapper = document.createElement('div'); // for inserting pop-up windows
	    td.appendChild(wrapper);
	    wrapper.style.position = 'relative';  // so we can position subwindows
	    wrapper.appendChild(this.canvas);

	    td = document.createElement('td');
	    td.style.verticalAlign = 'top';
	    tr.appendChild(td);
	    var parts_table = document.createElement('table');
	    td.appendChild(parts_table);
	    parts_table.rules = 'none';
	    parts_table.frame = 'void';
	    parts_table.cellPadding = '0';
	    parts_table.cellSpacing = '0';

	    // fill in parts_table
	    var parts_per_column = Math.floor(this.height / (part_h + 5));  // mysterious extra padding
	    for (var i = 0; i < parts_per_column; ++i) {
		tr = document.createElement('tr');
		parts_table.appendChild(tr);
		for (var j = i; j < this.parts_bin.length; j += parts_per_column) {
		    td = document.createElement('td');
		    tr.appendChild(td);
		    td.appendChild(this.parts_bin[j].canvas);
		}
	    }

	    if (this.status_div != undefined) {
		tr = document.createElement('tr');
		table.appendChild(tr);
		td = document.createElement('td');
		tr.appendChild(td);
		td.colSpan = 2;
		td.appendChild(this.status_div);
	    }

	    // add to dom
	    // avoid Chrome bug that changes to text cursor whenever
	    // drag starts.  Just do this in schematic tool...
	    var toplevel = document.createElement('div');
	    toplevel.onselectstart = function(){ return false; };
	    toplevel.appendChild(table);
	    this.input.parentNode.insertBefore(toplevel,this.input.nextSibling);

	    // process initial contents of diagram
	    this.load_schematic(this.input.getAttribute('value'),
				this.input.getAttribute('initial_value'));

	    // start by centering diagram on the screen
	    this.zoomall();
	}

	part_w = 42;   // size of a parts bin compartment
	part_h = 42;
	status_height = 18;

	Schematic.prototype.add_component = function(new_c) {
	    this.components.push(new_c);

	    // create undoable edit record here
	}

	Schematic.prototype.remove_component = function(c) {
	    var index = this.components.indexOf(c);
	    if (index != -1) this.components.splice(index,1);
	}

	Schematic.prototype.find_connections = function(cp) {
	    return this.connection_points[cp.location];
	}

	// add connection point to list of connection points at that location
	Schematic.prototype.add_connection_point = function(cp) {
	    var cplist = this.connection_points[cp.location];
	    if (cplist) cplist.push(cp);
	    else {
		cplist = [cp];
		this.connection_points[cp.location] = cplist;
	    }

	    // return list of conincident connection points
	    return cplist;
	}

	// remove connection point from the list points at the old location
	Schematic.prototype.remove_connection_point = function(cp,old_location) {
	    // remove cp from list at old location
	    var cplist = this.connection_points[old_location];
	    if (cplist) {
		var index = cplist.indexOf(cp);
		if (index != -1) {
		    cplist.splice(index,1);
		    // if no more connections at this location, remove
		    // entry from array to keep our search time short
		    if (cplist.length == 0)
			delete this.connection_points[old_location];
		}
	    }
	}

	// connection point has changed location: remove, then add
	Schematic.prototype.update_connection_point = function(cp,old_location) {
	    this.remove_connection_point(cp,old_location);
	    return this.add_connection_point(cp);
	}

	// add a wire to the schematic
	Schematic.prototype.add_wire = function(x1,y1,x2,y2) {
	    var new_wire = new Wire(x1,y1,x2,y2);
	    new_wire.add(this);
	    new_wire.move_end();
	    return new_wire;
	}

	Schematic.prototype.split_wire = function(w,cp) {
	    // remove bisected wire
	    w.remove();

	    // add two new wires with connection point cp in the middle
	    this.add_wire(w.x,w.y,cp.x,cp.y);
	    this.add_wire(w.x+w.dx,w.y+w.dy,cp.x,cp.y);
	}

	// see if connection points of component c split any wires
	Schematic.prototype.check_wires = function(c) {
	    for (var i = 0; i < this.components.length; i++) {
		var cc = this.components[i];
		if (cc != c) {  // don't check a component against itself
		    // only wires will return non-null from a bisect call
		    var cp = cc.bisect(c);
		    if (cp) {
			// cc is a wire bisected by connection point cp
			this.split_wire(cc,cp);
			this.redraw_background();
		    }
		}
	    }
	}

	// see if there are any existing connection points that bisect wire w
	Schematic.prototype.check_connection_points = function(w) {
	    for (var locn in this.connection_points) {
		var cplist = this.connection_points[locn];
		if (cplist && w.bisect_cp(cplist[0])) {
		    this.split_wire(w,cplist[0]);
		    this.redraw_background();

		    // stop here, new wires introduced by split will do their own checks
		    return;
		}
	    }
	}

	// merge collinear wires sharing an end point
	Schematic.prototype.clean_up_wires = function() {
	    for (var locn in this.connection_points) {
		var cplist = this.connection_points[locn];
		if (cplist && cplist.length == 2) {
		    // found a connection with just two connections, see if they're wires
		    var c1 = cplist[0].parent;
		    var c2 = cplist[1].parent;
		    if (c1.type == 'w' && c2.type == 'w') {
			var e1 = c1.other_end(cplist[0]);
			var e2 = c2.other_end(cplist[1]);
			var e3 = cplist[0];  // point shared by the two wires
			if (collinear(e1,e2,e3)) {
			    c1.remove();
			    c2.remove();
			    this.add_wire(e1.x,e1.y,e2.x,e2.y);
			}
		    }
		}
	    }
	}

	Schematic.prototype.unselect_all = function(which) {
	    this.operating_point = undefined;  // remove annotations

	    for (var i = this.components.length - 1; i >= 0; --i)
		if (i != which) this.components[i].set_select(false);
	}

	Schematic.prototype.drag_begin = function() {
	    // let components know they're about to move
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.selected) component.move_begin();
	    }

	    // remember where drag started
	    this.drag_x = this.cursor_x;
	    this.drag_y = this.cursor_y;
	    this.dragging = true;
	}

	Schematic.prototype.drag_end = function() {
	    // let components know they're done moving
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.selected) component.move_end();
	    }
	    this.dragging = false;

	    this.clean_up_wires();
	    this.redraw_background();
	}

	Schematic.prototype.help = function() {
	    window.open('/static/handouts/schematic_tutorial.pdf');
	}

	// zoom diagram around given coords
	Schematic.prototype.rescale = function(nscale,cx,cy) {
	    if (cx == undefined) {
		// use current center point if no point has been specified
		cx = this.origin_x + this.width/(2*this.scale);
		cy = this.origin_y + this.height/(2*this.scale);
	    }

	    this.origin_x += cx*(this.scale - nscale);
	    this.origin_y += cy*(this.scale - nscale);
	    this.scale = nscale;


	    //this.origin_x = cx - this.width/(2*this.scale);
	    //this.origin_y = cy - this.height/(2*this.scale);

	    this.redraw_background();
	}

	Schematic.prototype.toggle_grid = function() {
	    this.show_grid = !this.show_grid;
	    this.redraw_background();
	}

	zoom_factor = 1.25;    // scaling is some power of zoom_factor
	zoom_min = 0.5;
	zoom_max = 4.0;
	origin_min = -200;    // in grids
	origin_max = 200;

	Schematic.prototype.zoomin = function() {
	    var nscale = this.scale * zoom_factor;

	    if (nscale < zoom_max) {
		// keep center of view unchanged
		this.origin_x += (this.width/2)*(1.0/this.scale - 1.0/nscale);
		this.origin_y += (this.height/2)*(1.0/this.scale - 1.0/nscale);
		this.scale = nscale;
		this.redraw_background();
	    }
	}

	Schematic.prototype.zoomout = function() {
	    var nscale = this.scale / zoom_factor;

	    if (nscale > zoom_min) {
		// keep center of view unchanged
		this.origin_x += (this.width/2)*(1.0/this.scale - 1.0/nscale);
		this.origin_y += (this.height/2)*(1.0/this.scale - 1.0/nscale);
		this.scale = nscale;
		this.redraw_background();
	    }
	}

	Schematic.prototype.zoomall = function() {
	    // w,h for schematic including a 25% margin on all sides
	    var sch_w = 1.5*(this.bbox[2] - this.bbox[0]);
	    var sch_h = 1.5*(this.bbox[3] - this.bbox[1]);

	    if (sch_w == 0 && sch_h == 0) {
		this.origin_x = 0;
		this.origin_y = 0;
		this.scale = 2;
	    } else {
		// compute scales that would make schematic fit, choose smallest
		var scale_x = this.width/sch_w;
		var scale_y = this.height/sch_h;
		this.scale = Math.pow(zoom_factor,Math.ceil(Math.log(Math.min(scale_x,scale_y))/Math.log(zoom_factor)));
		if (this.scale < zoom_min) this.scale = zoom_min;
		else if (this.scale > zoom_max) this.scale = zoom_max;

		// center the schematic
		this.origin_x = (this.bbox[2] + this.bbox[0])/2 - this.width/(2*this.scale);
		this.origin_y = (this.bbox[3] + this.bbox[1])/2 - this.height/(2*this.scale);
	    }

	    this.redraw_background();
	}

	Schematic.prototype.cut = function() {
	    // clear previous contents
	    sch_clipboard = [];

	    // look for selected components, move them to clipboard.
	    for (var i = this.components.length - 1; i >=0; --i) {
		var c = this.components[i];
		if (c.selected) {
		    c.remove();
		    sch_clipboard.push(c);
		}
	    }

	    // update diagram view
	    this.redraw();
	}

	Schematic.prototype.copy = function() {
	    // clear previous contents
	    sch_clipboard = [];

	    // look for selected components, copy them to clipboard.
	    for (var i = this.components.length - 1; i >=0; --i) {
		var c = this.components[i];
		if (c.selected)
		    sch_clipboard.push(c.clone(c.x,c.y));
	    }
	}

	Schematic.prototype.paste = function() {
	    // compute left,top of bounding box for origins of
	    // components in the clipboard
	    var left = undefined;
	    var top = undefined;
	    for (var i = sch_clipboard.length - 1; i >= 0; --i) {
		var c = sch_clipboard[i];
		left = left ? Math.min(left,c.x) : c.x;
		top = top ? Math.min(top,c.y) : c.y;
	    }

	    this.message('cursor '+this.cursor_x+','+this.cursor_y);

	    // clear current selections
	    this.unselect_all(-1);
	    this.redraw_background();  // so we see any components that got unselected

	    // make clones of components on the clipboard, positioning
	    // them relative to the cursor
	    for (var i = sch_clipboard.length - 1; i >= 0; --i) {
		var c = sch_clipboard[i];
		var new_c = c.clone(this.cursor_x + (c.x - left),this.cursor_y + (c.y - top));
		new_c.set_select(true);
		new_c.add(this);
	    }

	    // see what we've wrought
	    this.redraw();
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Netlist and Simulation interface
	//
	////////////////////////////////////////////////////////////////////////////////

	// load diagram from JSON representation
	Schematic.prototype.load_schematic = function(value,initial_value) {
	    // use default value if no schematic info in value
	    if (value == undefined || value.indexOf('[') == -1)
		value = initial_value;
	    
	    if (value && value.indexOf('[') != -1) {
		// convert string value into data structure
		var json = JSON.parse(value);

		// top level is a list of components
		for (var i = json.length - 1; i >= 0; --i) {
		    var c = json[i];
		    if (c[0] == 'view') {
			// special hack: view component lets us recreate view
			// ignore saved view parameters as they sometimes screw students
			//this.origin_x = c[1];
			//this.origin_y = c[2];
			//this.scale = c[3];
			//this.ac_npts = c[4];
			this.ac_fstart = c[5];
			this.ac_fstop = c[6];
			this.ac_source_name = c[7];
			this.tran_npts = c[8];
			this.tran_tstop = c[9];
			this.dc_max_iters = c[10];
		    } else if (c[0] == 'w') {
			// wire
			this.add_wire(c[1][0],c[1][1],c[1][2],c[1][3]);
		    } else if (c[0] == 'dc') {
			this.dc_results = c[1];
		    } else if (c[0] == 'transient') {
			this.transient_results = c[1];
		    } else if (c[0] == 'ac') {
			this.ac_results = c[1];
		    } else {
			// ordinary component
			//  c := [type, coords, properties, connections]
			var type = c[0];
			var coords = c[1];
			var properties = c[2];

			// make the part
			var part = new parts_map[type][0](coords[0],coords[1],coords[2]);

			// give it its properties
			for (var name in properties)
			    part.properties[name] = properties[name];

			// add component to the diagram
			part.add(this);
		    }
		}
	    }

	    // see what we've got!
	    this.redraw_background();
	}

	// label all the nodes in the circuit
	Schematic.prototype.label_connection_points = function() {
	    // start by clearing all the connection point labels
	    for (var i = this.components.length - 1; i >=0; --i)
		this.components[i].clear_labels();

	    // components are in charge of labeling their unlabeled connections.
	    // labels given to connection points will propagate to coincident connection
	    // points and across Wires.

	    // let special components like GND label their connection(s)
	    for (var i = this.components.length - 1; i >=0; --i)
		this.components[i].add_default_labels();

	    // now have components generate labels for unlabeled connections
	    this.next_label = 0;
	    for (var i = this.components.length - 1; i >=0; --i)
		this.components[i].label_connections();
	}

	// generate a new label
	Schematic.prototype.get_next_label = function() {
	    // generate next label in sequence
	    this.next_label += 1;
	    return this.next_label.toString();
	}

	// propagate label to coincident connection points
	Schematic.prototype.propagate_label = function(label,location) {
	    var cplist = this.connection_points[location];
	    for (var i = cplist.length - 1; i >= 0; --i)
		cplist[i].propagate_label(label);
	}

	// update the value field of our corresponding input field with JSON
	// representation of schematic
	Schematic.prototype.update_value = function() {
	    // label connection points
	    this.label_connection_points();

	    // build JSON data structure, convert to string value for
	    // input field
	    this.input.value = JSON.stringify(this.json_with_analyses());
	}

	// produce a JSON representation of the diagram
	Schematic.prototype.json = function() {
	    var json = [];

	    // output all the components/wires in the diagram
	    var n = this.components.length;
	    for (var i = 0; i < n; i++)
		json.push(this.components[i].json(i));

	    // capture the current view parameters
	    json.push(['view',this.origin_x,this.origin_y,this.scale,
		       this.ac_npts,this.ac_fstart,this.ac_fstop,
		       this.ac_source_name,this.tran_npts,this.tran_tstop,
		       this.dc_max_iters]);

	    return json;
	}

	// produce a JSON representation of the diagram
	Schematic.prototype.json_with_analyses = function() {
	    var json = this.json();

	    if (this.dc_results != undefined) json.push(['dc',this.dc_results]);
	    if (this.ac_results != undefined) json.push(['ac',this.ac_results]);
	    if (this.transient_results != undefined) json.push(['transient',this.transient_results]);

	    return json;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Simulation interface
	//
	////////////////////////////////////////////////////////////////////////////////

	Schematic.prototype.extract_circuit = function() {
	    // give all the circuit nodes a name, extract netlist
	    this.label_connection_points();
	    var netlist = this.json();

	    // since we've done the heavy lifting, update input field value
	    // so user can grab diagram if they want
	    this.input.value = JSON.stringify(netlist);

	    // create a circuit from the netlist
	    var ckt = new cktsim.Circuit();
	    if (ckt.load_netlist(netlist))
		return ckt;
	    else
		return null;
	}

	Schematic.prototype.dc_analysis = function() {
	    // remove any previous annotations
	    this.unselect_all(-1);
	    this.redraw_background();

	    var ckt = this.extract_circuit();
	    if (ckt === null) return;

	    // run the analysis
	    this.operating_point = ckt.dc();

	    if (this.operating_point != undefined) {
		// save a copy of the results for submission
		this.dc_results = {};
		for (var i in this.operating_point) this.dc_results[i] = this.operating_point[i];

		// display results on diagram
		this.redraw();
	    }
	}

	// return a list of [color,node_label,offset,type] for each probe in the diagram
	// type == 'voltage' or 'current'
	Schematic.prototype.find_probes = function() {
	    var result = [];
	    var result = [];
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var c = this.components[i];
		var info = c.probe_info();
		if (info != undefined) result.push(c.probe_info());
	    }
	    return result;
	}

	// use a dialog to get AC analysis parameters
	Schematic.prototype.setup_ac_analysis = function() {
	    this.unselect_all(-1);
	    this.redraw_background();

	    var npts_lbl = 'Number of points/decade';
	    var fstart_lbl = 'Starting frequency (Hz)';
	    var fstop_lbl = 'Ending frequency (Hz)';
	    var source_name_lbl = 'Name of V or I source for ac'
    
	    if (this.find_probes().length == 0) {
		alert("AC Analysis: there are no voltage probes in the diagram!");
		return;
	    }

	    var fields = new Array();
	    //fields[npts_lbl] = build_input('text',10,this.ac_npts);
	    fields[fstart_lbl] = build_input('text',10,this.ac_fstart);
	    fields[fstop_lbl] = build_input('text',10,this.ac_fstop);
	    fields[source_name_lbl] = build_input('text',10,this.ac_source_name);

	    var content = build_table(fields);
	    content.fields = fields;
	    content.sch = this;

	    this.dialog('AC Analysis',content,function(content) {
		    var sch = content.sch;

		    // retrieve parameters, remember for next time
		    //sch.ac_npts = content.fields[npts_lbl].value;
		    sch.ac_fstart = content.fields[fstart_lbl].value;
		    sch.ac_fstop = content.fields[fstop_lbl].value;
		    sch.ac_source_name = content.fields[source_name_lbl].value;

		    sch.ac_analysis(cktsim.parse_number(sch.ac_npts),
				    cktsim.parse_number(sch.ac_fstart),
				    cktsim.parse_number(sch.ac_fstop),
				    sch.ac_source_name);
		});
	}

	// perform ac analysis
	Schematic.prototype.ac_analysis = function(npts,fstart,fstop,ac_source_name) {
	    // run the analysis
	    var ckt = this.extract_circuit();
	    if (ckt === null) return;
	    var results = ckt.ac(npts,fstart,fstop,ac_source_name);

	    if (typeof results == 'string') 
		this.message(results);
	    else {
		var x_values = results['_frequencies_'];

		// x axis will be a log scale
		for (var i = x_values.length - 1; i >= 0; --i)
		    x_values[i] = Math.log(x_values[i])/Math.LN10;


		if (this.submit_analyses != undefined) {
		    var submit = this.submit_analyses['ac'];
		    if (submit != undefined) {
			// save a copy of the results for submission
			this.ac_results = {};

			// save requested values for each requested node
			for (var j = 0; j < submit.length; j++) {
			    var flist = submit[j];    // [node_name,f1,f2,...]
			    var node = flist[0];
			    var values = results[node];
			    var fvlist = [];
			    // for each requested freq, interpolate response value
			    for (var k = 1; k < flist.length; k++) {
				var f = flist[k];
				var v = interpolate(f,x_values,values);
				// convert to dB
				fvlist.push([f,v == undefined ? 'undefined' : 20.0 * Math.log(v)/Math.LN10]);
			    }
			    // save results as list of [f,response] paris
			    this.ac_results[node] = fvlist;
			}
		    }
		}

		// set up plot values for each node with a probe
		var y_values = [];  // list of [color, result_array]
		var z_values = [];  // list of [color, result_array]
		var probes = this.find_probes();

		var probe_maxv = [];
		var probe_color = [];

		// Check for probe with near zero transfer function and warn
		for (var i = probes.length - 1; i >= 0; --i) {
		    if (probes[i][3] != 'voltage') continue;
		    probe_color[i] = probes[i][0];
		    var label = probes[i][1];
		    var v = results[label];
		    probe_maxv[i] = array_max(v); // magnitudes always > 0
		}
		var all_max = array_max(probe_maxv);

		if (all_max < 1.0e-16) {
		    alert('Zero ac response, -infinity on DB scale.');
		} else {
		    for (var i = probes.length - 1; i >= 0; --i) {
			if (probes[i][3] != 'voltage') continue;
			if ((probe_maxv[i] / all_max) < 1.0e-10) {
			    alert('Near zero ac response, remove ' + probe_color[i] + ' probe');
			    return;
			}
		    }
		}

		for (var i = probes.length - 1; i >= 0; --i) {
		    if (probes[i][3] != 'voltage') continue;
		    var color = probes[i][0];
		    var label = probes[i][1];
		    var offset = cktsim.parse_number(probes[i][2]);

		    var v = results[label];
		    // convert values into dB relative to source amplitude
		    var v_max = 1;
		    for (var j = v.length - 1; j >= 0; --j)
			// convert each value to dB relative to max
			v[j] = 20.0 * Math.log(v[j]/v_max)/Math.LN10;
		    y_values.push([color,offset,v]);

		    var v = results[label+'_phase'];
		    z_values.push([color,0,v]);
		}

		// graph the result and display in a window
		var graph2 = this.graph(x_values,'log(Frequency in Hz)',z_values,'degrees');
		this.window('AC Analysis - Phase',graph2);
		var graph1 = this.graph(x_values,'log(Frequency in Hz)',y_values,'dB');
		this.window('AC Analysis - Magnitude',graph1,50);
	    }
	}

	Schematic.prototype.transient_analysis = function() {
	    this.unselect_all(-1);
	    this.redraw_background();

	    var npts_lbl = 'Minimum number of timepoints';
	    var tstop_lbl = 'Stop Time (seconds)';
    
	    var probes = this.find_probes();
	    if (probes.length == 0) {
		alert("Transient Analysis: there are no probes in the diagram!");
		return;
	    }

	    var fields = new Array();
	    //fields[npts_lbl] = build_input('text',10,this.tran_npts);
	    fields[tstop_lbl] = build_input('text',10,this.tran_tstop);

	    var content = build_table(fields);
	    content.fields = fields;
	    content.sch = this;

	    this.dialog('Transient Analysis',content,function(content) {
		    var sch = content.sch;
		    var ckt = sch.extract_circuit();
		    if (ckt === null) return;

		    // retrieve parameters, remember for next time
		    //sch.tran_npts = content.fields[npts_lbl].value;
		    sch.tran_tstop = content.fields[tstop_lbl].value;

		    // gather a list of nodes that are being probed.  These
		    // will be added to the list of nodes checked during the
		    // LTE calculations in transient analysis
		    var probe_list = sch.find_probes();
		    var probe_names = new Array(probe_list.length);
		    for (var i = probe_list.length - 1; i >= 0; --i)
			probe_names[i] = probe_list[i][1];

		    // run the analysis
		    var results = ckt.tran(ckt.parse_number(sch.tran_npts), 0,
					   ckt.parse_number(sch.tran_tstop), probe_names, false);

		    if (typeof results == 'string') 
			sch.message(results);
		    else {
			if (sch.submit_analyses != undefined) {
			    var submit = sch.submit_analyses['tran'];
			    if (submit != undefined) {
				// save a copy of the results for submission
				sch.transient_results = {};
				var times = results['_time_'];

				// save requested values for each requested node
				for (var j = 0; j < submit.length; j++) {
				    var tlist = submit[j];    // [node_name,t1,t2,...]
				    var node = tlist[0];
				    var values = results[node];
				    var tvlist = [];
				    // for each requested time, interpolate waveform value
				    for (var k = 1; k < tlist.length; k++) {
					var t = tlist[k];
					var v = interpolate(t,times,values);
					tvlist.push([t,v == undefined ? 'undefined' : v]);
				    }
				    // save results as list of [t,value] pairs
				    sch.transient_results[node] = tvlist;
				}
			    }
			}

			var x_values = results['_time_'];
			var x_legend = 'Time';

			// set up plot values for each node with a probe
			var v_values = [];  // voltage values: list of [color, result_array]
			var i_values = [];  // current values: list of [color, result_array]
			var probes = sch.find_probes();

			for (var i = probes.length - 1; i >= 0; --i) {
			    var color = probes[i][0];
			    var label = probes[i][1];
			    var offset = cktsim.parse_number(probes[i][2]);
			    var v = results[label];
			    if (v == undefined) {
				alert('The ' + color + ' probe is connected to node ' + '"' + label + '"' + ' which is not an actual circuit node');
			    } else if (probes[i][3] == 'voltage') {
				if (color == 'x-axis') {
				    x_values = v;
				    x_legend = 'Voltage';
				} else v_values.push([color,offset,v]);
			    } else {
				if (color == 'x-axis') {
				    x_values = v;
				    x_legend = 'Current';
				} else i_values.push([color,offset,v]);
			    }
			}

			// graph the result and display in a window
			var graph = sch.graph(x_values,x_legend,v_values,'Voltage',i_values,'Current');
			sch.window('Results of Transient Analysis',graph);
		    }
	    })
	}

	// t is the time at which we want a value
	// times is a list of timepoints from the simulation
	function interpolate(t,times,values) {
	    if (values == undefined) return undefined;

	    for (var i = 0; i < times.length; i++)
		if (t < times[i]) {
		    // t falls between times[i-1] and times[i]
		    var t1 = (i == 0) ? times[0] : times[i-1];
		    var t2 = times[i];

		    if (t2 == undefined) return undefined;

		    var v1 = (i == 0) ? values[0] : values[i-1];
		    var v2 = values[i];
		    var v = v1;
		    if (t != t1) v += (t - t1)*(v2 - v1)/(t2 - t1);
		    return v;
		}
	}

	// external interface for setting the property value of a named component
	Schematic.prototype.set_property = function(component_name,property,value) {
	    this.unselect_all(-1);

	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.properties['name'] == component_name) {
		    component.properties[property] = value.toString();
		    break;
		}
	    }

	    // update diagram
	    this.redraw_background();
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Drawing support -- deals with scaling and scrolling of diagrama
	//
	////////////////////////////////////////////////////////////////////////////////

	// here to redraw background image containing static portions of the schematic.
	// Also redraws dynamic portion.
	Schematic.prototype.redraw_background = function() {
	    var c = this.bg_image.getContext('2d');

	    c.lineCap = 'round';

	    // paint background color
	    c.fillStyle = element_style;
	    c.fillRect(0,0,this.width,this.height);

	    if (!this.diagram_only && this.show_grid) {
		// grid
		c.strokeStyle = grid_style;
		var first_x = this.origin_x;
		var last_x = first_x + this.width/this.scale;
		var first_y = this.origin_y;
		var last_y = first_y + this.height/this.scale;

		for (var i = this.grid*Math.ceil(first_x/this.grid); i < last_x; i += this.grid)
		    this.draw_line(c,i,first_y,i,last_y,0.1);

		for (var i = this.grid*Math.ceil(first_y/this.grid); i < last_y; i += this.grid)
		    this.draw_line(c,first_x,i,last_x,i,0.1);
	    }

	    // unselected components
	    var min_x = Infinity;  // compute bounding box for diagram
	    var max_x = -Infinity;
	    var min_y = Infinity;
	    var max_y = -Infinity;
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (!component.selected) {
		    component.draw(c);
		    min_x = Math.min(component.bbox[0],min_x);
		    max_x = Math.max(component.bbox[2],max_x);
		    min_y = Math.min(component.bbox[1],min_y);
		    max_y = Math.max(component.bbox[3],max_y);
		}
	    }
	    this.unsel_bbox = [min_x,min_y,max_x,max_y];

	    this.redraw();   // background changed, redraw on screen
	}

	// redraw what user sees = static image + dynamic parts
	Schematic.prototype.redraw = function() {
	    var c = this.canvas.getContext('2d');

	    // put static image in the background
	    c.drawImage(this.bg_image, 0, 0);

	    // selected components
	    var min_x = this.unsel_bbox[0];   // compute bounding box for diagram
	    var max_x = this.unsel_bbox[2];
	    var min_y = this.unsel_bbox[1];
	    var max_y = this.unsel_bbox[3];
	    var selections = false;
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.selected) {
		    component.draw(c);
		    selections = true;
		    min_x = Math.min(component.bbox[0],min_x);
		    max_x = Math.max(component.bbox[2],max_x);
		    min_y = Math.min(component.bbox[1],min_y);
		    max_y = Math.max(component.bbox[3],max_y);
		}
	    }
	    if (min_x == Infinity) this.bbox = [0,0,0,0];
	    else this.bbox = [min_x,min_y,max_x,max_y];
	    this.enable_tool('cut',selections);
	    this.enable_tool('copy',selections);
	    this.enable_tool('paste',sch_clipboard.length > 0);

	    // connection points: draw one at each location
	    for (var location in this.connection_points) {
		var cplist = this.connection_points[location];
		cplist[0].draw(c,cplist.length);
	    }
    
	    // draw new wire
	    if (this.wire) {
		var r = this.wire;
		c.strokeStyle = selected_style;
		this.draw_line(c,r[0],r[1],r[2],r[3],1);
	    }

	    // draw selection rectangle
	    if (this.select_rect) {
		var r = this.select_rect;
		c.lineWidth = 1;
		c.strokeStyle = selected_style;
		c.beginPath();
		c.moveTo(r[0],r[1]);
		c.lineTo(r[0],r[3]);
		c.lineTo(r[2],r[3]);
		c.lineTo(r[2],r[1]);
		c.lineTo(r[0],r[1]);
		c.stroke();
	    }
    
	    // display operating point results
	    if (this.operating_point) {
		if (typeof this.operating_point == 'string')
		    this.message(this.operating_point);
		else {
		    // make a copy of the operating_point info so we can mess with it
		    var temp = new Array();
		    for (var i in this.operating_point) temp[i] = this.operating_point[i];

		    // run through connection points displaying (once) the voltage
		    // for each electrical node
		    for (var location in this.connection_points)
			(this.connection_points[location])[0].display_voltage(c,temp);

		    // let components display branch current info if available
		    for (var i = this.components.length - 1; i >= 0; --i)
			this.components[i].display_current(c,temp)
		}
	    }
	    
	    // add scrolling/zooming control
	    if (!this.diagram_only) {
		var r = this.sctl_r;
		var x = this.sctl_x;
		var y = this.sctl_y;

		// circle with border
		c.fillStyle = element_style;
		c.beginPath();
		c.arc(x,y,r,0,2*Math.PI);
		c.fill();

		c.strokeStyle = grid_style;
		c.lineWidth = 0.5;
		c.beginPath();
		c.arc(x,y,r,0,2*Math.PI);
		c.stroke();

		// direction markers for scroll
		c.lineWidth = 3;
		c.beginPath();

		c.moveTo(x + 4,y - r + 8);   // north
		c.lineTo(x,y - r + 4);
		c.lineTo(x - 4,y - r + 8);

		c.moveTo(x + r - 8,y + 4);   // east
		c.lineTo(x + r - 4,y);
		c.lineTo(x + r - 8,y - 4);

		c.moveTo(x + 4,y + r - 8);   // south
		c.lineTo(x,y + r - 4);
		c.lineTo(x - 4,y + r - 8);

		c.moveTo(x - r + 8,y + 4);   // west
		c.lineTo(x - r + 4,y);
		c.lineTo(x - r + 8,y - 4);

		c.stroke();

		// zoom control
		x = this.zctl_left;
		y = this.zctl_top;
		c.lineWidth = 0.5;
		c.fillStyle = element_style;    // background
		c.fillRect(x,y,16,48);
		c.strokeStyle = grid_style;     // border
		c.strokeRect(x,y,16,48);
		c.lineWidth = 1.0;
		c.beginPath();
		// zoom in label
		c.moveTo(x+4,y+8); c.lineTo(x+12,y+8); c.moveTo(x+8,y+4); c.lineTo(x+8,y+12);
		// zoom out label
		c.moveTo(x+4,y+24); c.lineTo(x+12,y+24);
		// surround label
		c.strokeRect(x+4,y+36,8,8);
		c.stroke();
	    }
	}

	// draws a cross cursor
	Schematic.prototype.cross_cursor = function(c,x,y) {
	    this.draw_line(c,x-this.grid,y,x+this.grid,y,1);
	    this.draw_line(c,x,y-this.grid,x,y+this.grid,1);
	}

	Schematic.prototype.moveTo = function(c,x,y) {
	    c.moveTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Schematic.prototype.lineTo = function(c,x,y) {
	    c.lineTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Schematic.prototype.draw_line = function(c,x1,y1,x2,y2,width) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.moveTo((x1 - this.origin_x) * this.scale,(y1 - this.origin_y) * this.scale);
	    c.lineTo((x2 - this.origin_x) * this.scale,(y2 - this.origin_y) * this.scale);
	    c.stroke();
	}

	Schematic.prototype.draw_arc = function(c,x,y,radius,start_radians,end_radians,anticlockwise,width,filled) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.arc((x - this.origin_x)*this.scale,(y - this.origin_y)*this.scale,radius*this.scale,
		  start_radians,end_radians,anticlockwise);
	    if (filled) c.fill();
	    else c.stroke();
	}

	Schematic.prototype.draw_text = function(c,text,x,y,size) {
	    c.font = size*this.scale+'pt sans-serif'
	    c.fillText(text,(x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	// add method to canvas to compute relative coords for event
	try {
		if (HTMLCanvasElement)
		 HTMLCanvasElement.prototype.relMouseCoords = function(event){
		    // run up the DOM tree to figure out coords for top,left of canvas
		    var totalOffsetX = 0;
		    var totalOffsetY = 0;
		    var currentElement = this;
		    do {
			totalOffsetX += currentElement.offsetLeft;
			totalOffsetY += currentElement.offsetTop;
		    }
		    while (currentElement = currentElement.offsetParent);
	
		    // now compute relative position of click within the canvas
		    this.mouse_x = event.pageX - totalOffsetX;
		    this.mouse_y = event.pageY - totalOffsetY;
	
		    this.page_x = event.pageX;
		    this.page_y = event.pageY;
		 }
	}
	catch (err) { // ignore
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Event handling
	//
	////////////////////////////////////////////////////////////////////////////////

	// process keystrokes, consuming those that are meaningful to us
	function schematic_key_down(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;
	    var code = event.keyCode;

	    // keep track of modifier key state
	    if (code == 16) sch.shiftKey = true;
	    else if (code == 17) sch.ctrlKey = true;
	    else if (code == 18) sch.altKey = true;
	    else if (code == 91) sch.cmdKey = true;

	    // backspace or delete: delete selected components
	    else if (code == 8 || code == 46) {
		// delete selected components
		for (var i = sch.components.length - 1; i >= 0; --i) {
		    var component = sch.components[i];
		    if (component.selected) component.remove();
		}
		sch.clean_up_wires();
		sch.redraw_background();
		event.preventDefault();
		return false;
	    }

	    // cmd/ctrl x: cut
	    else if ((sch.ctrlKey || sch.cmdKey) && code == 88) {
		sch.cut();
		event.preventDefault();
		return false;
	    }

	    // cmd/ctrl c: copy
	    else if ((sch.ctrlKey || sch.cmdKey) && code == 67) {
		sch.copy();
		event.preventDefault();
		return false;
	    }

	    // cmd/ctrl v: paste
	    else if ((sch.ctrlKey || sch.cmdKey) && code == 86) {
		sch.paste();
		event.preventDefault();
		return false;
	    }

	    // 'r': rotate component
	    else if (!sch.ctrlKey && !sch.altKey && !sch.cmdKey && code == 82) {
		// rotate
		for (var i = sch.components.length - 1; i >= 0; --i) {
		    var component = sch.components[i];
		    if (component.selected) {
			component.rotate(1);
			sch.check_wires(component);
		    }
		}
		sch.clean_up_wires();
		sch.redraw_background();
		event.preventDefault();
		return false;
	    }

	    else return true;

	    // consume keystroke
	    sch.redraw();
	    event.preventDefault();
	    return false;
	}

	function schematic_key_up(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;
	    var code = event.keyCode;

	    if (code == 16) sch.shiftKey = false;
	    else if (code == 17) sch.ctrlKey = false;
	    else if (code == 18) sch.altKey = false;
	    else if (code == 91) sch.cmdKey = false;
	}

	function schematic_mouse_enter(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // see if user has selected a new part
	    if (sch.new_part) {
		// grab incoming part, turn off selection of parts bin
		var part = sch.new_part;
		sch.new_part = undefined;
		part.select(false);

		// unselect everything else in the schematic, add part and select it
		sch.unselect_all(-1);
		sch.redraw_background();  // so we see any components that got unselected

		// make a clone of the component in the parts bin
		part = part.component.clone(sch.cursor_x,sch.cursor_y);
		part.add(sch);  // add it to schematic
		part.set_select(true);

		// and start dragging it
		sch.drag_begin();
	    }

	    sch.drawCursor = true;
	    sch.redraw();
	    sch.canvas.focus();  // capture key strokes
	    return false;
	}

	function schematic_mouse_leave(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;
	    sch.drawCursor = false;
	    sch.redraw();
	    return false;
	}

	function schematic_mouse_down(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // determine where event happened in schematic coordinates
	    sch.canvas.relMouseCoords(event);

	    var mx = sch.canvas.mouse_x;
	    var my = sch.canvas.mouse_y;
	    var sx = mx - sch.sctl_x;
	    var sy = my - sch.sctl_y;
	    var zx = mx - sch.zctl_left;
	    var zy = my - sch.zctl_top;
	    if (sx*sx + sy*sy <= sch.sctl_r*sch.sctl_r) {   // click in scrolling control
		// click on scrolling control, check which quadrant
		if (Math.abs(sy) > Math.abs(sx)) {   // N or S
		    var delta = this.height / 8;
		    if (sy > 0) delta = -delta;
		    var temp = sch.origin_y - delta;
		    if (temp > origin_min*sch.grid && temp < origin_max*sch.grid) sch.origin_y = temp;
		} else {			    // E or W
		    var delta = this.width / 8;
		    if (sx < 0) delta = -delta;
		    var temp = sch.origin_x + delta;
		    if (temp > origin_min*sch.grid && temp < origin_max*sch.grid) sch.origin_x = temp;
		}
	    } else if (zx >= 0 && zx < 16 && zy >= 0 && zy < 48) {   // click in zoom control
		if (zy < 16) sch.zoomin();
		else if (zy < 32) sch.zoomout();
		else sch.zoomall();
	    } else {
		var x = mx/sch.scale + sch.origin_x;
		var y = my/sch.scale + sch.origin_y;
		sch.cursor_x = Math.round(x/sch.grid) * sch.grid;
		sch.cursor_y = Math.round(y/sch.grid) * sch.grid;

		// is mouse over a connection point?  If so, start dragging a wire
		var cplist = sch.connection_points[sch.cursor_x + ',' + sch.cursor_y];
		if (cplist && !event.shiftKey) {
		    sch.unselect_all(-1);
		    sch.wire = [sch.cursor_x,sch.cursor_y,sch.cursor_x,sch.cursor_y];
		} else {
		    // give all components a shot at processing the selection event
		    var which = -1;
		    for (var i = sch.components.length - 1; i >= 0; --i)
			if (sch.components[i].select(x,y,event.shiftKey)) {
			    if (sch.components[i].selected) {
				sch.drag_begin();
				which = i;  // keep track of component we found
			    }
			    break;
			}
		    // did we just click on a previously selected component?
		    var reselect = which!=-1 && sch.components[which].was_previously_selected;

		    if (!event.shiftKey) {
			// if shift key isn't pressed and we didn't click on component
			// that was already selected, unselect everyone except component
			// we just clicked on
			if (!reselect) sch.unselect_all(which);

			// if there's nothing to drag, set up a selection rectangle
			if (!sch.dragging) sch.select_rect = [sch.canvas.mouse_x,sch.canvas.mouse_y,
							      sch.canvas.mouse_x,sch.canvas.mouse_y];
		    }
		}
	    }

	    sch.redraw_background();
	    return false;
	}

	function schematic_mouse_move(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    sch.canvas.relMouseCoords(event);
	    var x = sch.canvas.mouse_x/sch.scale + sch.origin_x;
	    var y = sch.canvas.mouse_y/sch.scale + sch.origin_y;
	    sch.cursor_x = Math.round(x/sch.grid) * sch.grid;
	    sch.cursor_y = Math.round(y/sch.grid) * sch.grid;

	    if (sch.wire) {
		// update new wire end point
		sch.wire[2] = sch.cursor_x;
		sch.wire[3] = sch.cursor_y;
	    } else if (sch.dragging) {
		// see how far we moved
		var dx = sch.cursor_x - sch.drag_x;
		var dy = sch.cursor_y - sch.drag_y;
		if (dx != 0 || dy != 0) {
		    // update position for next time
		    sch.drag_x = sch.cursor_x;
		    sch.drag_y = sch.cursor_y;

		    // give all components a shot at processing the event
		    for (var i = sch.components.length - 1; i >= 0; --i) {
			var component = sch.components[i];
			if (component.selected) component.move(dx,dy);
		    }
		}
	    } else if (sch.select_rect) {
		// update moving corner of selection rectangle
		sch.select_rect[2] = sch.canvas.mouse_x;
		sch.select_rect[3] = sch.canvas.mouse_y;
		//sch.message(sch.select_rect.toString());
	    }
    
	    // just redraw dynamic components
	    sch.redraw();
	    //sch.message(sch.canvas.page_x + ',' + sch.canvas.page_y + ';' + sch.canvas.mouse_x + ',' + sch.canvas.mouse_y + ';' + sch.cursor_x + ',' + sch.cursor_y);

	    return false;
	}

	function schematic_mouse_up(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // drawing a new wire
	    if (sch.wire) {
		var r = sch.wire;
		sch.wire = undefined;

		if (r[0]!=r[2] || r[1]!=r[3]) {
		    // insert wire component
		    sch.add_wire(r[0],r[1],r[2],r[3]);
		    sch.clean_up_wires();
		    sch.redraw_background();
		} else sch.redraw();
	    }

	    // dragging
	    if (sch.dragging) sch.drag_end();

	    // selection rectangle
	    if (sch.select_rect) {
		var r = sch.select_rect;

		// if select_rect is a point, we've already dealt with selection
		// in mouse_down handler
		if (r[0]!=r[2] || r[1]!=r[3]) {
		    // convert to schematic coordinates
		    var s = [r[0]/sch.scale + sch.origin_x, r[1]/sch.scale + sch.origin_y,
			     r[2]/sch.scale + sch.origin_x, r[3]/sch.scale + sch.origin_y];
		    canonicalize(s);
	    
		    if (!event.shiftKey) sch.unselect_all();

		    // select components that intersect selection rectangle
		    for (var i = sch.components.length - 1; i >= 0; --i)
			sch.components[i].select_rect(s,event.shiftKey);
		}

		sch.select_rect = undefined;
		sch.redraw_background();
	    }
	    return false;
	}

	function schematic_mouse_wheel(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    var delta = 0;
	    if (event.wheelDelta) delta = event.wheelDelta;
	    else if (event.detail) delta = -event.detail;

	    if (delta) {
		var nscale = (delta > 0) ? sch.scale*zoom_factor : sch.scale/zoom_factor;

		if (nscale > zoom_min && nscale < zoom_max) {
		    // zoom around current mouse position
		    sch.canvas.relMouseCoords(event);
		    var s = 1.0/sch.scale - 1.0/nscale;
		    sch.origin_x += sch.canvas.mouse_x*s;
		    sch.origin_y += sch.canvas.mouse_y*s;
		    sch.scale = nscale;
		    sch.redraw_background();
		}
	    }
	}

	function schematic_double_click(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // determine where event happened in schematic coordinates
	    sch.canvas.relMouseCoords(event);
	    var x = sch.canvas.mouse_x/sch.scale + sch.origin_x;
	    var y = sch.canvas.mouse_y/sch.scale + sch.origin_y;
	    sch.cursor_x = Math.round(x/sch.grid) * sch.grid;
	    sch.cursor_y = Math.round(y/sch.grid) * sch.grid;

	    // see if we double-clicked a component.  If so, edit it's properties
	    for (var i = sch.components.length - 1; i >= 0; --i)
		if (sch.components[i].edit_properties(x,y))
		    break;

	    return false;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Status message and dialogs
	//
	////////////////////////////////////////////////////////////////////////////////

	Schematic.prototype.message = function(message) {
	    this.status.nodeValue = message;
	}

	Schematic.prototype.append_message = function(message) {
	    this.status.nodeValue += ' / '+message;
	}
    
	// set up a dialog with specified title, content and two buttons at
	// the bottom: OK and Cancel.  If Cancel is clicked, dialog goes away
	// and we're done.  If OK is clicked, dialog goes away and the
	// callback function is called with the content as an argument (so
	// that the values of any fields can be captured).
	Schematic.prototype.dialog = function(title,content,callback) {
	    // create the div for the top level of the dialog, add to DOM
	    var dialog = document.createElement('div');
	    dialog.sch = this;
	    dialog.content = content;
	    dialog.callback = callback;

	    // look for property input fields in the content and give
	    // them a keypress listener that interprets ENTER as
	    // clicking OK.
	    var plist = content.getElementsByClassName('property');
	    for (var i = plist.length - 1; i >= 0; --i) {
		var field = plist[i];
		field.dialog = dialog;  // help event handler find us...
		field.addEventListener('keypress',dialog_check_for_ENTER,false);
	    }

	    // div to hold the content
	    var body = document.createElement('div');
	    content.style.marginBotton = '5px';
	    body.appendChild(content);
	    body.style.padding = '5px';
	    dialog.appendChild(body);

	    // OK button
	    var ok_button = document.createElement('span');
	    ok_button.appendChild(document.createTextNode('OK'));
	    ok_button.dialog = dialog;   // for the handler to use
	    ok_button.addEventListener('click',dialog_okay,false);
	    ok_button.style.display = 'inline';
	    ok_button.style.border = '1px solid';
	    ok_button.style.padding = '5px';
	    ok_button.style.margin = '10px';

	    // cancel button
	    var cancel_button = document.createElement('span');
	    cancel_button.appendChild(document.createTextNode('Cancel'));
	    cancel_button.dialog = dialog;   // for the handler to use
	    cancel_button.addEventListener('click',dialog_cancel,false);
	    cancel_button.style.display = 'inline';
	    cancel_button.style.border = '1px solid';
	    cancel_button.style.padding = '5px';
	    cancel_button.style.margin = '10px';

	    // div to hold the two buttons
	    var buttons = document.createElement('div');
	    buttons.style.textAlign = 'center';
	    buttons.appendChild(ok_button);
	    buttons.appendChild(cancel_button);
	    buttons.style.padding = '5px';
	    buttons.style.margin = '10px';
	    dialog.appendChild(buttons);

	    // put into an overlay window
	    this.window(title,dialog);
	}

	// callback when user click "Cancel" in a dialog
	function dialog_cancel(event) {
	    if (!event) event = window.event;
	    var dialog = (window.event) ? event.srcElement.dialog : event.target.dialog;

	    window_close(dialog.win);
	}

	// callback when user click "OK" in a dialog
	function dialog_okay(event) {
	    if (!event) event = window.event;
	    var dialog = (window.event) ? event.srcElement.dialog : event.target.dialog;

	    window_close(dialog.win);

	    // invoke the callback with the dialog contents as the argument
	    if (dialog.callback) dialog.callback(dialog.content);
	}

	// callback for keypress in input fields: if user typed ENTER, act
	// like they clicked OK button.
	function dialog_check_for_ENTER(event) {
	    var key = (window.event) ? window.event.keyCode : event.keyCode;
	    if (key == 13) dialog_okay(event);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Draggable, resizeable, closeable window
	//
	////////////////////////////////////////////////////////////////////////////////

	// build a 2-column HTML table from an associative array (keys as text in
	// column 1, values in column 2).
	function build_table(a) {
	    var tbl = document.createElement('table');

	    // build a row for each element in associative array
	    for (var i in a) {
		var label = document.createTextNode(i + ': ');
		var col1 = document.createElement('td');
		col1.appendChild(label);
		var col2 = document.createElement('td');
		col2.appendChild(a[i]);
		var row = document.createElement('tr');
		row.appendChild(col1);
		row.appendChild(col2);
		row.style.verticalAlign = 'center';
		tbl.appendChild(row);
	    }

	    return tbl;
	}

	// build an input field
	function build_input(type,size,value) {
	    var input = document.createElement('input');
	    input.type = type;
	    input.size = size;
	    input.className = 'property';  // make this easier to find later
	    if (value == undefined) input.value = '';
	    else input.value = value.toString();
	    return input;
	}

	// build a select widget using the strings found in the options array
	function build_select(options,selected) {
	    var select = document.createElement('select');
	    for (var i = 0; i < options.length; i++) {
		var option = document.createElement('option');
		option.text = options[i];
		select.add(option);
		if (options[i] == selected) select.selectedIndex = i;
	    }
	    return select;
	}

	Schematic.prototype.window = function(title,content,offset) {
	    // create the div for the top level of the window
	    var win = document.createElement('div');
	    win.sch = this;
	    win.content = content;
	    win.drag_x = undefined;
	    win.draw_y = undefined;

	    // div to hold the title
	    var head = document.createElement('div');
	    head.style.backgroundColor = 'black';
	    head.style.color = 'white';
	    head.style.textAlign = 'center';
	    head.style.padding = '5px';
	    head.appendChild(document.createTextNode(title));
	    head.win = win;
	    win.head = head;

	    var close_button = new Image();
	    close_button.src = close_icon;
	    close_button.style.cssFloat = 'right';
	    close_button.addEventListener('click',window_close_button,false);
	    close_button.win = win;
	    head.appendChild(close_button);

	    win.appendChild(head);

	    // capture mouse events in title bar
	    head.addEventListener('mousedown',window_mouse_down,false);

	    // div to hold the content
	    //var body = document.createElement('div');
	    //body.appendChild(content);
	    win.appendChild(content);
	    content.win = win;   // so content can contact us

	    // compute location relative to canvas
	    if (offset == undefined) offset = 0;
	    win.left = this.canvas.mouse_x + offset;
	    win.top = this.canvas.mouse_y + offset;

	    // add to DOM
	    win.style.background = 'white';
	    //win.style.zIndex = '1000';
	    win.style.position = 'absolute';
	    win.style.left = win.left + 'px';
	    win.style.top = win.top + 'px';
	    win.style.border = '2px solid';

	    this.canvas.parentNode.insertBefore(win,this.canvas);
	    bring_to_front(win,true);
	}

	// adjust zIndex of pop-up window so that it is in front
	function bring_to_front(win,insert) {
	    var wlist = win.sch.window_list;
	    var i = wlist.indexOf(win);

	    // remove from current position (if any) in window list
	    if (i != -1) wlist.splice(i,1);

	    // if requested, add to end of window list
	    if (insert) wlist.push(win);

	    // adjust all zIndex values
	    for (i = 0; i < wlist.length; i += 1)
		wlist[i].style.zIndex = 1000 + i;
	}

	// close the window
	function window_close(win) {
	    // remove the window from the top-level div of the schematic
	    win.parentNode.removeChild(win);

	    // remove from list of pop-up windows
	    bring_to_front(win,false);
	}

	function window_close_button(event) {
	    if (!event) event = window.event;
	    var src = (window.event) ? event.srcElement : event.target;
	    window_close(src.win);
	}

	// capture mouse events in title bar of window
	function window_mouse_down(event) {
	    if (!event) event = window.event;
	    var src = (window.event) ? event.srcElement : event.target;
	    var win = src.win;

	    bring_to_front(win,true);

	    // add handlers to document so we capture them no matter what
	    document.addEventListener('mousemove',window_mouse_move,false);
	    document.addEventListener('mouseup',window_mouse_up,false);
	    document.tracking_window = win;
    
	    // remember where mouse is so we can compute dx,dy during drag
	    win.drag_x = event.pageX;
	    win.drag_y = event.pageY;

	    return false;
	}

	function window_mouse_up(event) {
	    var win = document.tracking_window;
    
	    // show's over folks...
	    document.removeEventListener('mousemove',window_mouse_move,false);
	    document.removeEventListener('mouseup',window_mouse_up,false);
	    document.tracking_window = undefined;
	    win.drag_x = undefined;
	    win.drag_y = undefined;
	    return true;  // consume event
	}

	function window_mouse_move(event) {
	    var win = document.tracking_window;
    
	    if (win.drag_x) {
		var dx = event.pageX - win.drag_x;
		var dy = event.pageY - win.drag_y;

		// move the window
		win.left += dx;
		win.top += dy;
		win.style.left = win.left + 'px';
		win.style.top = win.top + 'px';
	
		// update reference point
		win.drag_x += dx;
		win.drag_y += dy;

		return true;  // consume event
	    }
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Toolbar
	//
	////////////////////////////////////////////////////////////////////////////////

	Schematic.prototype.add_tool = function(icon,tip,callback) {
	    var tool;
	    if (icon.search('data:image') != -1) {
		tool = document.createElement('img');
		tool.src = icon;
	    } else {
		tool = document.createElement('span');
		tool.style.font = 'small-caps small sans-serif';
		var label = document.createTextNode(icon);
		tool.appendChild(label);
	    }

	    // decorate tool
	    tool.style.borderWidth = '1px';
	    tool.style.borderStyle = 'solid';
	    tool.style.borderColor = background_style;
	    tool.style.padding = '2px';
	    tool.style.verticalAlign = 'middle';
	    tool.style.cursor = 'default';

	    // set up event processing
	    tool.addEventListener('mouseover',tool_enter,false);
	    tool.addEventListener('mouseout',tool_leave,false);
	    tool.addEventListener('click',tool_click,false);

	    // add to toolbar
	    tool.sch = this;
	    tool.tip = tip;
	    tool.callback = callback;
	    this.toolbar.push(tool);

	    tool.enabled = false;
	    tool.style.opacity = 0.2;

	    return tool;
	}

	Schematic.prototype.enable_tool = function(tname,which) {
	    var tool = this.tools[tname];

	    if (tool != undefined) {
		tool.style.opacity = which ? 1.0 : 0.2;
		tool.enabled = which;

		// if disabling tool, remove border and tip
		if (!which) {
		    tool.style.borderColor = background_style;
		    tool.sch.message('');
		}
	    }
	}

	// highlight tool button by turning on border, changing background
	function tool_enter(event) {
	    if (!event) event = window.event;
	    var tool = (window.event) ? event.srcElement : event.target;

	    if (tool.enabled) {
		tool.style.borderColor = normal_style;
		tool.sch.message(tool.tip);
		tool.opacity = 1.0;
	    }
	}

	// unhighlight tool button by turning off border, reverting to normal background
	function tool_leave(event) {
	    if (!event) event = window.event;
	    var tool = (window.event) ? event.srcElement : event.target;

	    if (tool.enabled) {
		tool.style.borderColor = background_style;
		tool.sch.message('');
	    }
	}

	// handle click on a tool
	function tool_click(event) {
	    if (!event) event = window.event;
	    var tool = (window.event) ? event.srcElement : event.target;

	    if (tool.enabled) {
		tool.sch.canvas.relMouseCoords(event);  // so we can position pop-up window correctly
		tool.callback.call(tool.sch);
	    }
	}

	help_icon = 'data:image/gif;base64,R0lGODlhEAAQAJEAAAAAAP///wAAAAAAACH5BAkAAAIAIf8LSUNDUkdCRzEwMTL/AAAHqGFwcGwCIAAAbW50clJHQiBYWVogB9kAAgAZAAsAGgALYWNzcEFQUEwAAAAAYXBwbAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZGVzYwAAAQgAAABvZHNjbQAAAXgAAAVsY3BydAAABuQAAAA4d3RwdAAABxwAAAAUclhZWgAABzAAAAAUZ1hZWgAAB0QAAAAUYlhZWgAAB1gAAAAUclRSQwAAB2wAAAAOY2hhZAAAB3wAAAAsYlRSQwAAB2wAAAAOZ1RS/0MAAAdsAAAADmRlc2MAAAAAAAAAFEdlbmVyaWMgUkdCIFByb2ZpbGUAAAAAAAAAAAAAABRHZW5lcmljIFJHQiBQcm9maWxlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtbHVjAAAAAAAAAB4AAAAMc2tTSwAAACgAAAF4aHJIUgAAACgAAAGgY2FFUwAAACQAAAHIcHRCUgAAACYAAAHsdWtVQQAAACoAAAISZnJGVQAAACgAAAI8emhUVwAAABYAAAJkaXRJVAAAACgAAAJ6bmJOTwAAACYAAAKia29LUgAAABYAAP8CyGNzQ1oAAAAiAAAC3mhlSUwAAAAeAAADAGRlREUAAAAsAAADHmh1SFUAAAAoAAADSnN2U0UAAAAmAAAConpoQ04AAAAWAAADcmphSlAAAAAaAAADiHJvUk8AAAAkAAADomVsR1IAAAAiAAADxnB0UE8AAAAmAAAD6G5sTkwAAAAoAAAEDmVzRVMAAAAmAAAD6HRoVEgAAAAkAAAENnRyVFIAAAAiAAAEWmZpRkkAAAAoAAAEfHBsUEwAAAAsAAAEpHJ1UlUAAAAiAAAE0GFyRUcAAAAmAAAE8mVuVVMAAAAmAAAFGGRhREsAAAAuAAAFPgBWAWEAZQBvAGIAZQD/YwBuAP0AIABSAEcAQgAgAHAAcgBvAGYAaQBsAEcAZQBuAGUAcgBpAQ0AawBpACAAUgBHAEIAIABwAHIAbwBmAGkAbABQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6AByAGkAYwBQAGUAcgBmAGkAbAAgAFIARwBCACAARwBlAG4A6QByAGkAYwBvBBcEMAQzBDAEOwRMBD0EOAQ5ACAEPwRABD4ERAQwBDkEOwAgAFIARwBCAFAAcgBvAGYAaQBsACAAZwDpAG4A6QByAGkAcQB1AGUAIABSAFYAQpAadSgAIABSAEcAQgAggnJfaWPPj/AAUAByAG8AZgBp/wBsAG8AIABSAEcAQgAgAGcAZQBuAGUAcgBpAGMAbwBHAGUAbgBlAHIAaQBzAGsAIABSAEcAQgAtAHAAcgBvAGYAaQBsx3y8GAAgAFIARwBCACDVBLhc0wzHfABPAGIAZQBjAG4A/QAgAFIARwBCACAAcAByAG8AZgBpAGwF5AXoBdUF5AXZBdwAIABSAEcAQgAgBdsF3AXcBdkAQQBsAGwAZwBlAG0AZQBpAG4AZQBzACAAUgBHAEIALQBQAHIAbwBmAGkAbADBAGwAdABhAGwA4QBuAG8AcwAgAFIARwBCACAAcAByAG8AZgBpAGxmbpAaACAAUgBHAEIAIGPPj//wZYdO9k4AgiwAIABSAEcAQgAgMNcw7TDVMKEwpDDrAFAAcgBvAGYAaQBsACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjA5MDtQO9A7kDugPMACADwAPBA78DxgOvA7sAIABSAEcAQgBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6QByAGkAYwBvAEEAbABnAGUAbQBlAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGUAbA5CDhsOIw5EDh8OJQ5MACAAUgBHAEIAIA4XDjEOSA4nDkQOGwBHAGUAbgBlAGwAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGkAWQBsAGX/AGkAbgBlAG4AIABSAEcAQgAtAHAAcgBvAGYAaQBpAGwAaQBVAG4AaQB3AGUAcgBzAGEAbABuAHkAIABwAHIAbwBmAGkAbAAgAFIARwBCBB4EMQRJBDgEOQAgBD8EQAQ+BEQEOAQ7BEwAIABSAEcAQgZFBkQGQQAgBioGOQYxBkoGQQAgAFIARwBCACAGJwZEBjkGJwZFAEcAZQBuAGUAcgBpAGMAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGUARwBlAG4AZQByAGUAbAAgAFIARwBCAC0AYgBlAHMAawByAGkAdgBlAGwAcwBldGV4dAAAAABDb3B5cmlnaHQgMjAwrzcgQXBwbGUgSW5jLiwgYWxsIHJpZ2h0cyByZXNlcnZlZC4AWFlaIAAAAAAAAPNSAAEAAAABFs9YWVogAAAAAAAAdE0AAD3uAAAD0FhZWiAAAAAAAABadQAArHMAABc0WFlaIAAAAAAAACgaAAAVnwAAuDZjdXJ2AAAAAAAAAAEBzQAAc2YzMgAAAAAAAQxCAAAF3v//8yYAAAeSAAD9kf//+6L///2jAAAD3AAAwGwALAAAAAAQABAAAAIglI+pwK3XInhSLoZc0oa/7lHRB4bXRJZoaqau+o6ujBQAOw==';

	cut_icon = 'data:image/gif;base64,R0lGODlhEAAQALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAAcALAAAAAAQABAAAAQu8MhJqz1g5qs7lxv2gRkQfuWomarXEgDRHjJhf3YtyRav0xcfcFgR0nhB5OwTAQA7';

	copy_icon = 'data:image/gif;base64,R0lGODlhEAAQALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAAcALAAAAAAQABAAAAQ+8MhJ6wE4Wwqef9gmdV8HiKZJrCz3ecS7TikWfzExvk+M9a0a4MbTkXCgTMeoHPJgG5+yF31SLazsTMTtViIAOw==';

	paste_icon = 'data:image/gif;base64,R0lGODlhEAAQALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAAcALAAAAAAQABAAAARL8MhJqwUYWJnxWp3GDcgAgCdQIqLKXmVLhhnyHiqpr7rME8AgocVDEB5IJHD0SyofBFzxGIQGAbvB0ZkcTq1CKK6z5YorwnR0w44AADs=';

	close_icon = 'data:image/gif;base64,R0lGODlhEAAQAMQAAGtra/f3/62tre/v9+bm787O1pycnHNzc6WlpcXFxd7e3tbW1nt7e7W1te/v74SEhMXFzmNjY+bm5v///87OzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAALAAAAAAQABAAAAVt4DRMZGmSwRQQBUS9MAwRIyQ5Uq7neEFSDtxOF4T8cobIQaE4RAQ5yjHHiCCSD510QtFGvoCFdppDfBu7bYzy+D7WP5ggAgA8Y3FKwi5IAhIweW1vbBGEWy5rilsFi2tGAwSJixAFBCkpJ5ojIQA7';

	grid_icon = 'data:image/gif;base64,R0lGODlhEAAQAMQAAAAAAP///zAwYT09bpGRqZ6et5iYsKWlvbi40MzM5cXF3czM5OHh5tTU2fDw84uMom49DbWKcfLy8g0NDcDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABQALAAAAAAQABAAAAUtICWOZGmeKDCqIlu68AvMdO2ueHvGuslTN6Bt6MsBd8Zg77hsDW3FpRJFrYpCADs=';

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Graphing
	//
	///////////////////////////////////////////////////////////////////////////////

	// add dashed lines!
	// from http://davidowens.wordpress.com/2010/09/07/html-5-canvas-and-dashed-lines/
	try {
		if (CanvasRenderingContext2D)
			CanvasRenderingContext2D.prototype.dashedLineTo = function(fromX, fromY, toX, toY, pattern) {
			    // Our growth rate for our line can be one of the following:
			    //   (+,+), (+,-), (-,+), (-,-)
			    // Because of this, our algorithm needs to understand if the x-coord and
			    // y-coord should be getting smaller or larger and properly cap the values
			    // based on (x,y).
			    var lt = function (a, b) { return a <= b; };
			    var gt = function (a, b) { return a >= b; };
			    var capmin = function (a, b) { return Math.min(a, b); };
			    var capmax = function (a, b) { return Math.max(a, b); };
		
			    var checkX = { thereYet: gt, cap: capmin };
			    var checkY = { thereYet: gt, cap: capmin };
		
			    if (fromY - toY > 0) {
				checkY.thereYet = lt;
				checkY.cap = capmax;
			    }
			    if (fromX - toX > 0) {
				checkX.thereYet = lt;
				checkX.cap = capmax;
			    }
		
			    this.moveTo(fromX, fromY);
			    var offsetX = fromX;
			    var offsetY = fromY;
			    var idx = 0, dash = true;
			    while (!(checkX.thereYet(offsetX, toX) && checkY.thereYet(offsetY, toY))) {
				var ang = Math.atan2(toY - fromY, toX - fromX);
				var len = pattern[idx];
		
				offsetX = checkX.cap(toX, offsetX + (Math.cos(ang) * len));
				offsetY = checkY.cap(toY, offsetY + (Math.sin(ang) * len));
		
				if (dash) this.lineTo(offsetX, offsetY);
				else this.moveTo(offsetX, offsetY);
		
				idx = (idx + 1) % pattern.length;
				dash = !dash;
			    }
			};
	}
	catch (err) { //noop
	}
	// given a range of values, return a new range [vmin',vmax'] where the limits
	// have been chosen "nicely".  Taken from matplotlib.ticker.LinearLocator
	function view_limits(vmin,vmax) {
	    // deal with degenerate case...
	    if (vmin == vmax) {
		if (vmin == 0) { vmin = -0.5; vmax = 0.5; }
		else {
		    vmin = vmin > 0 ? 0.9*vmin : 1.1*vmin;
		    vmax = vmax > 0 ? 1.1*vmax : 0.9*vmax;
		}
	    }

	    var log_range = Math.log(vmax - vmin)/Math.LN10;
	    var exponent = Math.floor(log_range);
	    //if (log_range - exponent < 0.5) exponent -= 1;
	    var scale = Math.pow(10,-exponent);
	    vmin = Math.floor(scale*vmin)/scale;
	    vmax = Math.ceil(scale*vmax)/scale;

	    return [vmin,vmax,1.0/scale];
	}

	function engineering_notation(n,nplaces,trim) {
	    if (n == 0) return '0';
	    if (n == undefined) return 'undefined';
	    if (trim == undefined) trim = true;

	    var sign = n < 0 ? -1 : 1;
	    var log10 = Math.log(sign*n)/Math.LN10;
	    var exp = Math.floor(log10/3);   // powers of 1000
	    var mantissa = sign*Math.pow(10,log10 - 3*exp);

	    // keep specified number of places following decimal point
	    var mstring = (mantissa + sign*0.5*Math.pow(10,-nplaces)).toString();
	    var mlen = mstring.length;
	    var endindex = mstring.indexOf('.');
	    if (endindex != -1) {
		if (nplaces > 0) {
		    endindex += nplaces + 1;
		    if (endindex > mlen) endindex = mlen;
		    if (trim) {
			while (mstring.charAt(endindex-1) == '0') endindex -= 1;
			if (mstring.charAt(endindex-1) == '.') endindex -= 1;
		    }
		}
		if (endindex < mlen)
		    mstring = mstring.substring(0,endindex);
	    }

	    switch(exp) {
	    case -5:	return mstring+"f";
	    case -4:	return mstring+"p";
	    case -3:	return mstring+"n";
	    case -2:	return mstring+"u";
	    case -1:	return mstring+"m";
	    case 0:	return mstring;
	    case 1:	return mstring+"K";
	    case 2:	return mstring+"M";
	    case 3:	return mstring+"G";
	    }

	    // don't have a good suffix, so just print the number
	    return n.toString();
	}

	var grid_pattern = [1,2];
	var cursor_pattern = [5,5];

	// x_values is an array of x coordinates for each of the plots
	// y_values is an array of [color, value_array], one entry for each plot on left vertical axis
	// z_values is an array of [color, value_array], one entry for each plot on right vertical axis
	Schematic.prototype.graph = function(x_values,x_legend,y_values,y_legend,z_values,z_legend) {
	    var pwidth = 400;	// dimensions of actual plot
	    var pheight = 300;	// dimensions of actual plot
	    var left_margin = (y_values != undefined && y_values.length > 0) ? 55 : 25;
	    var top_margin = 25;
	    var right_margin = (z_values != undefined && z_values.length > 0) ? 55 : 25;
	    var bottom_margin = 45;
	    var tick_length = 5;

	    var w = pwidth + left_margin + right_margin;
	    var h = pheight + top_margin + bottom_margin;

	    var canvas = document.createElement('canvas');
	    canvas.width = w;
	    canvas.height = h;

	    // the graph itself will be drawn here and this image will be copied
	    // onto canvas, where it can be overlayed with mouse cursors, etc.
	    var bg_image = document.createElement('canvas');
	    bg_image.width = w;
	    bg_image.height = h;
	    canvas.bg_image = bg_image;	// so we can find it during event handling

	    // start by painting an opaque background
	    var c = bg_image.getContext('2d');
	    c.fillStyle = background_style;
	    c.fillRect(0,0,w,h);
	    c.fillStyle = element_style;
	    c.fillRect(left_margin,top_margin,pwidth,pheight);

	    // figure out scaling for plots
	    var x_min = array_min(x_values);
	    var x_max = array_max(x_values);
	    var x_limits = view_limits(x_min,x_max);
	    x_min = x_limits[0];
	    x_max = x_limits[1];
	    var x_scale = pwidth/(x_max - x_min);

	    function plot_x(x) {
		return (x - x_min)*x_scale + left_margin;
	    }

	    // draw x grid
	    c.strokeStyle = grid_style;
	    c.lineWidth = 1;
	    c.fillStyle = normal_style;
	    c.font = '10pt sans-serif';
	    c.textAlign = 'center';
	    c.textBaseline = 'top';
	    var end = top_margin + pheight;
	    for (var x = x_min; x <= x_max; x += x_limits[2]) {
		var temp = plot_x(x) + 0.5;  // keep lines crisp!

		// grid line
		c.beginPath();
		if (x == x_min) {
		    c.moveTo(temp,top_margin);
		    c.lineTo(temp,end);
		} else 
		    c.dashedLineTo(temp,top_margin,temp,end,grid_pattern);
		c.stroke();

		// tick mark
		c.beginPath();
		c.moveTo(temp,end);
		c.lineTo(temp,end + tick_length);
		c.stroke();
		c.fillText(engineering_notation(x,2),temp,end + tick_length);
	    }

	    if (y_values != undefined && y_values.length > 0) {
		var y_min = Infinity;
		var y_max = -Infinity;
		var plot;
		for (plot = y_values.length - 1; plot >= 0; --plot) {
		    var values = y_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = y_values[plot][1];
		    var temp = array_min(values) + offset;
		    if (temp < y_min) y_min = temp;
		    temp = array_max(values) + offset;
		    if (temp > y_max) y_max = temp;
		}
		var y_limits = view_limits(y_min,y_max);
		y_min = y_limits[0];
		y_max = y_limits[1];
		var y_scale = pheight/(y_max - y_min);

		function plot_y(y) {
		    return (y_max - y)*y_scale + top_margin;
		}

		// draw y grid
		c.textAlign = 'right';
		c.textBaseline = 'middle';
		for (var y = y_min; y <= y_max; y += y_limits[2]) {
		    if (Math.abs(y/y_max) < 0.001) y = 0.0; // Just 3 digits
		    var temp = plot_y(y) + 0.5;  // keep lines crisp!

		    // grid line
		    c.beginPath();
		    if (y == y_min) {
			c.moveTo(left_margin,temp);
			c.lineTo(left_margin + pwidth,temp);
		    } else 
			c.dashedLineTo(left_margin,temp,left_margin + pwidth,temp,grid_pattern);
		    c.stroke();

		    // tick mark
		    c.beginPath();
		    c.moveTo(left_margin - tick_length,temp);
		    c.lineTo(left_margin,temp);
		    c.stroke();
		    c.fillText(engineering_notation(y,2),left_margin - tick_length -2,temp);
		}

		// now draw each plot
		var x,y;
		var nx,ny;
		c.lineWidth = 3;
		c.lineCap = 'round';
		for (plot = y_values.length - 1; plot >= 0; --plot) {
		    var color = probe_colors_rgb[y_values[plot][0]];
		    if (color == undefined) continue;  // no plot color (== x-axis)
		    c.strokeStyle = color;
		    var values = y_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = y_values[plot][1];

		    x = plot_x(x_values[0]);
		    y = plot_y(values[0] + offset);
		    c.beginPath();
		    c.moveTo(x,y);
		    for (var i = 1; i < x_values.length; i++) {
			nx = plot_x(x_values[i]);
			ny = plot_y(values[i] + offset);
			c.lineTo(nx,ny);
			x = nx;
			y = ny;
			if (i % 100 == 99) {
			    // too many lineTo's cause canvas to break
			    c.stroke();
			    c.beginPath();
			    c.moveTo(x,y);
			}
		    }
		    c.stroke();
		}
	    }

	    if (z_values != undefined && z_values.length > 0) {
		var z_min = Infinity;
		var z_max = -Infinity;
		for (plot = z_values.length - 1; plot >= 0; --plot) {
		    var values = z_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = z_values[plot][1];
		    var temp = array_min(values) + offset;
		    if (temp < z_min) z_min = temp;
		    temp = array_max(values) + offset;
		    if (temp > z_max) z_max = temp;
		}
		var z_limits = view_limits(z_min,z_max);
		z_min = z_limits[0];
		z_max = z_limits[1];
		var z_scale = pheight/(z_max - z_min);

		function plot_z(z) {
		    return (z_max - z)*z_scale + top_margin;
		}

		// draw z ticks
		c.textAlign = 'left';
		c.textBaseline = 'middle';
		c.lineWidth = 1;
		c.strokeStyle = normal_style;
		var tick_length_half = Math.floor(tick_length/2);
		var tick_delta = tick_length - tick_length_half;
		for (var z = z_min; z <= z_max; z += z_limits[2]) {
		    if (Math.abs(z/z_max) < 0.001) z = 0.0; // Just 3 digits
		    var temp = plot_z(z) + 0.5;  // keep lines crisp!

		    // tick mark
		    c.beginPath();
		    c.moveTo(left_margin + pwidth - tick_length_half,temp);
		    c.lineTo(left_margin + pwidth + tick_delta,temp);
		    c.stroke();
		    c.fillText(engineering_notation(z,2),left_margin + pwidth + tick_length + 2,temp);
		}

		var z;
		var nz;
		c.lineWidth = 3;
		for (plot = z_values.length - 1; plot >= 0; --plot) {
		    var color = probe_colors_rgb[z_values[plot][0]];
		    if (color == undefined) continue;  // no plot color (== x-axis)
		    c.strokeStyle = color;
		    var values = z_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = z_values[plot][1];
		    
		    x = plot_x(x_values[0]);
		    z = plot_z(values[0] + offset);
		    c.beginPath();
		    c.moveTo(x,z);
		    for (var i = 1; i < x_values.length; i++) {
			nx = plot_x(x_values[i]);
			nz = plot_z(values[i] + offset);
			c.lineTo(nx,nz);
			x = nx;
			z = nz;
			if (i % 100 == 99) {
			    // too many lineTo's cause canvas to break
			    c.stroke();
			    c.beginPath();
			    c.moveTo(x,z);
			}
		    }
		    c.stroke();
		}
	    }

	    // draw legends
	    c.font = '12pt sans-serif';
	    c.textAlign = 'center';
	    c.textBaseline = 'bottom';
	    c.fillText(x_legend,left_margin + pwidth/2,h - 5);

	    if (y_values != undefined && y_values.length > 0) {
		c.textBaseline = 'top';
		c.save();
		c.translate(5 ,top_margin + pheight/2);
		c.rotate(-Math.PI/2);
		c.fillText(y_legend,0,0);
		c.restore();
	    }

	    if (z_values != undefined && z_values.length > 0) {
		c.textBaseline = 'bottom';
		c.save();
		c.translate(w-5 ,top_margin + pheight/2);
		c.rotate(-Math.PI/2);
		c.fillText(z_legend,0,0);
		c.restore();
	    }

	    // save info need for interactions with the graph
	    canvas.x_values = x_values;
	    canvas.y_values = y_values;
	    canvas.z_values = z_values;
	    canvas.x_legend = x_legend;
	    canvas.y_legend = y_legend;
	    canvas.z_legend = y_legend;
	    canvas.x_min = x_min;
	    canvas.x_scale = x_scale;
	    canvas.y_min = y_min;
	    canvas.y_scale = y_scale;
	    canvas.z_min = z_min;
	    canvas.z_scale = z_scale;
	    canvas.left_margin = left_margin;
	    canvas.top_margin = top_margin;
	    canvas.pwidth = pwidth;
	    canvas.pheight = pheight;
	    canvas.tick_length = tick_length;

	    canvas.cursor1_x = undefined;
	    canvas.cursor2_x = undefined;
	    canvas.sch = this;

	    // do something useful when user mouses over graph
	    canvas.addEventListener('mousemove',graph_mouse_move,false);

	    // return our masterpiece
	    redraw_plot(canvas);
	    return canvas;
	}

	function array_max(a) {
	    max = -Infinity;
	    for (var i = a.length - 1; i >= 0; --i)
		if (a[i] > max) max = a[i];
	    return max;
	}

	function array_min(a) {
	    min = Infinity;
	    for (var i = a.length - 1; i >= 0; --i)
		if (a[i] < min) min = a[i];
	    return min;
	}

	function plot_cursor(c,graph,cursor_x,left_margin) {
	    // draw dashed vertical marker that follows mouse
	    var x = graph.left_margin + cursor_x;
	    var end_y = graph.top_margin + graph.pheight + graph.tick_length;
	    c.strokeStyle = grid_style;
	    c.lineWidth = 1;
	    c.beginPath();
	    c.dashedLineTo(x,graph.top_margin,x,end_y,cursor_pattern);
	    c.stroke();

	    // add x label at bottom of marker
	    var graph_x = cursor_x/graph.x_scale + graph.x_min;
	    c.font = '10pt sans-serif';
	    c.textAlign = 'center';
	    c.textBaseline = 'top';
	    c.fillStyle = background_style;
	    c.fillText('\u2588\u2588\u2588\u2588\u2588',x,end_y);
	    c.fillStyle = normal_style;
	    c.fillText(engineering_notation(graph_x,3,false),x,end_y);

	    // compute which points marker is between
	    var x_values = graph.x_values;
	    var len = x_values.length;
	    var index = 0;
	    while (index < len && graph_x >= x_values[index]) index += 1;
	    var x1 = (index == 0) ? x_values[0] : x_values[index-1];
	    var x2 = x_values[index];

	    if (x2 != undefined) {
		// for each plot, interpolate and output value at intersection with marker
		c.textAlign = 'left';
		var tx = graph.left_margin + left_margin;
		var ty = graph.top_margin;
		if (graph.y_values != undefined) {
		    for (var plot = 0; plot < graph.y_values.length; plot++) {
			var values = graph.y_values[plot][2];
			var color = probe_colors_rgb[graph.y_values[plot][0]];
			if (values == undefined || color == undefined) continue;  // no data points or x-axis
		    
			// interpolate signal value at graph_x using values[index-1] and values[index]
			var y1 = (index == 0) ? values[0] : values[index-1];
			var y2 = values[index];
			var y = y1;
			if (graph_x != x1) y += (graph_x - x1)*(y2 - y1)/(x2 - x1);
		    
			// annotate plot with value of signal at marker
			c.fillStyle = element_style;
			c.fillText('\u2588\u2588\u2588\u2588\u2588',tx-3,ty);
			c.fillStyle = color;
			c.fillText(engineering_notation(y,3,false),tx,ty);
			ty += 14;
		    }
		}

		c.textAlign = 'right';
		if (graph.z_values != undefined) {
		    var tx = graph.left_margin + graph.pwidth - left_margin;
		    var ty = graph.top_margin;
		    for (var plot = 0; plot < graph.z_values.length; plot++) {
			var values = graph.z_values[plot][2];
			var color = probe_colors_rgb[graph.z_values[plot][0]];
			if (values == undefined || color == undefined) continue;  // no data points or x-axis
		    
			// interpolate signal value at graph_x using values[index-1] and values[index]
			var z1 = (index == 0) ? values[0]: values[index-1];
			var z2 = values[index];
			var z = z1;
			if (graph_x != x1) z += (graph_x - x1)*(z2 - z1)/(x2 - x1);
		    
			// annotate plot with value of signal at marker
			c.fillStyle = element_style;
			c.fillText('\u2588\u2588\u2588\u2588\u2588',tx+3,ty);
			c.fillStyle = color;
			c.fillText(engineering_notation(z,3,false),tx,ty);
			ty += 14;
		    }
		}
	    }
	}

	function redraw_plot(graph) {
	    var c = graph.getContext('2d');
	    c.drawImage(graph.bg_image,0,0);

	    if (graph.cursor1_x != undefined) plot_cursor(c,graph,graph.cursor1_x,4);
	    if (graph.cursor2_x != undefined) plot_cursor(c,graph,graph.cursor2_x,30);

	    /*
	    if (graph.cursor1_x != undefined) {
		// draw dashed vertical marker that follows mouse
		var x = graph.left_margin + graph.cursor1_x;
		var end_y = graph.top_margin + graph.pheight + graph.tick_length;
		c.strokeStyle = grid_style;
		c.lineWidth = 1;
		c.beginPath();
		c.dashedLineTo(x,graph.top_margin,x,end_y,cursor_pattern);
		c.stroke();

		// add x label at bottom of marker
		var graph_x = graph.cursor1_x/graph.x_scale + graph.x_min;
		c.font = '10pt sans-serif';
		c.textAlign = 'center';
		c.textBaseline = 'top';
		c.fillStyle = background_style;
		c.fillText('\u2588\u2588\u2588\u2588\u2588',x,end_y);
		c.fillStyle = normal_style;
		c.fillText(engineering_notation(graph_x,3,false),x,end_y);

		// compute which points marker is between
		var x_values = graph.x_values;
		var len = x_values.length;
		var index = 0;
		while (index < len && graph_x >= x_values[index]) index += 1;
		var x1 = (index == 0) ? x_values[0] : x_values[index-1];
		var x2 = x_values[index];

		if (x2 != undefined) {
		    // for each plot, interpolate and output value at intersection with marker
		    c.textAlign = 'left';
		    var tx = graph.left_margin + 4;
		    var ty = graph.top_margin;
		    for (var plot = 0; plot < graph.y_values.length; plot++) {
			var values = graph.y_values[plot][1];

			// interpolate signal value at graph_x using values[index-1] and values[index]
			var y1 = (index == 0) ? values[0] : values[index-1];
			var y2 = values[index];
			var y = y1;
			if (graph_x != x1) y += (graph_x - x1)*(y2 - y1)/(x2 - x1);

			// annotate plot with value of signal at marker
			c.fillStyle = element_style;
			c.fillText('\u2588\u2588\u2588\u2588\u2588',tx-3,ty);
			c.fillStyle = probe_colors_rgb[graph.y_values[plot][0]];
			c.fillText(engineering_notation(y,3,false),tx,ty);
			ty += 14;
		    }
		}
	    }
	    */
	}

	function graph_mouse_move(event) {
	    if (!event) event = window.event;
	    var g = (window.event) ? event.srcElement : event.target;

	    g.relMouseCoords(event);
	    // not sure yet where the 3,-3 offset correction comes from (borders? padding?)
	    var gx = g.mouse_x - g.left_margin - 3;
	    var gy = g.pheight - (g.mouse_y - g.top_margin) + 3;
	    if (gx >= 0 && gx <= g.pwidth && gy >=0 && gy <= g.pheight) {
		//g.sch.message('button: '+event.button+', which: '+event.which);
		g.cursor1_x = gx;
	    } else {
		g.cursor1_x = undefined;
		g.cursor2_x = undefined;
	    }

	    redraw_plot(g);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Parts bin
	//
	////////////////////////////////////////////////////////////////////////////////

	// one instance will be created for each part in the parts bin
	function Part(sch) {
	    this.sch = sch;
	    this.component = undefined;
	    this.selected = false;

	    // set up canvas
	    this.canvas = document.createElement('canvas');
	    this.canvas.style.borderStyle = 'solid';
	    this.canvas.style.borderWidth = '1px';
	    this.canvas.style.borderColor = background_style;
	    //this.canvas.style.position = 'absolute';
	    this.canvas.style.cursor = 'default';
	    this.canvas.height = part_w;
	    this.canvas.width = part_h;
	    this.canvas.part = this;

	    this.canvas.addEventListener('mouseover',part_enter,false);
	    this.canvas.addEventListener('mouseout',part_leave,false);
	    this.canvas.addEventListener('mousedown',part_mouse_down,false);
	    this.canvas.addEventListener('mouseup',part_mouse_up,false);

	    // make the part "clickable" by registering a dummy click handler
	    // this should make things work on the iPad
	    this.canvas.addEventListener('click',function(){},false);
	}

	Part.prototype.set_location = function(left,top) {
	    this.canvas.style.left = left + 'px';
	    this.canvas.style.top = top + 'px';
	}

	Part.prototype.right = function() {
	    return this.canvas.offsetLeft + this.canvas.offsetWidth;
	}

	Part.prototype.bottom = function() {
	    return this.canvas.offsetTop + this.canvas.offsetHeight;
	}

	Part.prototype.set_component = function(component,tip) {
	    component.sch = this;
	    this.component = component;
	    this.tip = tip;

	    // figure out scaling and centering of parts icon
	    var b = component.bounding_box;
	    var dx = b[2] - b[0];
	    var dy = b[3] - b[1];
	    this.scale = 0.8; //Math.min(part_w/(1.2*dx),part_h/(1.2*dy));
	    this.origin_x = b[0] + dx/2.0 - part_w/(2.0*this.scale);
	    this.origin_y = b[1] + dy/2.0 - part_h/(2.0*this.scale);

	    this.redraw();
	}

	Part.prototype.redraw = function(part) {
	    var c = this.canvas.getContext('2d');

	    // paint background color
	    c.fillStyle = this.selected ? selected_style : background_style;
	    c.fillRect(0,0,part_w,part_h);

	    if (this.component) this.component.draw(c);
	}

	Part.prototype.select = function(which) {
	    this.selected = which;
	    this.redraw();
	}

	Part.prototype.update_connection_point = function(cp,old_location) {
	    // no connection points in the parts bin
	}

	Part.prototype.moveTo = function(c,x,y) {
	    c.moveTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Part.prototype.lineTo = function(c,x,y) {
	    c.lineTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Part.prototype.draw_line = function(c,x1,y1,x2,y2,width) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.moveTo((x1 - this.origin_x) * this.scale,(y1 - this.origin_y) * this.scale);
	    c.lineTo((x2 - this.origin_x) * this.scale,(y2 - this.origin_y) * this.scale);
	    c.stroke();
	}

	Part.prototype.draw_arc = function(c,x,y,radius,start_radians,end_radians,anticlockwise,width,filled) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.arc((x - this.origin_x)*this.scale,(y - this.origin_y)*this.scale,radius*this.scale,
		  start_radians,end_radians,anticlockwise);
	    if (filled) c.fill();
	    else c.stroke();
	}

	Part.prototype.draw_text = function(c,text,x,y,size) {
	    // no text displayed for the parts icon
	}

	function part_enter(event) {
	    if (!event) event = window.event;
	    var canvas = (window.event) ? event.srcElement : event.target;
	    var part = canvas.part;

	    // avoid Chrome bug that changes to text cursor whenever
	    // drag starts.  We'll restore the default handler at
	    // the appropriate point so behavior in other parts of
	    // the document are unaffected.
	    //part.sch.saved_onselectstart = document.onselectstart;
	    //document.onselectstart = function () { return false; };

	    canvas.style.borderColor = normal_style;
	    part.sch.message(part.tip+': drag onto diagram to insert');
	    return false;
	}

	function part_leave(event) {
	    if (!event) event = window.event;
	    var canvas = (window.event) ? event.srcElement : event.target;
	    var part = canvas.part;

	    if (typeof part.sch.new_part == 'undefined') {
		// leaving with no part selected?  revert handler
		//document.onselectstart = part.sch.saved_onselectstart;
	    }

	    canvas.style.borderColor = background_style;
	    part.sch.message('');
	    return false;
	}

	function part_mouse_down(event) {
	    if (!event) event = window.event;
	    var part = (window.event) ? event.srcElement.part : event.target.part;

	    part.select(true);
	    part.sch.new_part = part;
	    return false;
	}

	function part_mouse_up(event) {
	    if (!event) event = window.event;
	    var part = (window.event) ? event.srcElement.part : event.target.part;

	    part.select(false);
	    part.sch.new_part = undefined;
	    return false;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Rectangle helper functions
	//
	////////////////////////////////////////////////////////////////////////////////

	// rect is an array of the form [left,top,right,bottom]

	// ensure left < right, top < bottom
	function canonicalize(r) {
	    var temp;

	    // canonicalize bounding box
	    if (r[0] > r[2]) {
		temp = r[0];
		r[0] = r[2];
		r[2] = temp;
	    }
	    if (r[1] > r[3]) {
		temp = r[1];
		r[1] = r[3];
		r[3] = temp;
	    }
	}
    
	function between(x,x1,x2) {
	    return x1 <= x && x <= x2;
	}

	function inside(rect,x,y) {
	    return between(x,rect[0],rect[2]) && between(y,rect[1],rect[3]);
	}

	// only works for manhattan rectangles
	function intersect(r1,r2) {
	    // look for non-intersection, negate result
	    var result = !(r2[0] > r1[2] ||
			   r2[2] < r1[0] ||
			   r2[1] > r1[3] ||
			   r2[3] < r1[1]);

	    // if I try to return the above expression, javascript returns undefined!!!
	    return result;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Component base class
	//
	////////////////////////////////////////////////////////////////////////////////

	function Component(type,x,y,rotation) {
	    this.sch = undefined;
	    this.type = type;
	    this.x = x;
	    this.y = y;
	    this.rotation = rotation;
	    this.selected = false;
	    this.properties = new Array();
	    this.bounding_box = [0,0,0,0];   // in device coords [left,top,right,bottom]
	    this.bbox = this.bounding_box;   // in absolute coords
	    this.connections = [];
	}

	Component.prototype.json = function(index) {
	    this.properties['_json_'] = index; // remember where we are in the JSON list

	    var props = {};
	    for (var p in this.properties) props[p] = this.properties[p];

	    var conns = [];
	    for (var i = 0; i < this.connections.length; i++)
		conns.push(this.connections[i].json());

	    var json = [this.type,[this.x, this.y, this.rotation],props,conns];
	    return json;
	}

	Component.prototype.add_connection = function(offset_x,offset_y) {
	    this.connections.push(new ConnectionPoint(this,offset_x,offset_y));
	}

	Component.prototype.update_coords = function() {
	    var x = this.x;
	    var y = this.y;

	    // update bbox
	    var b = this.bounding_box;
	    this.bbox[0] = this.transform_x(b[0],b[1]) + x;
	    this.bbox[1] = this.transform_y(b[0],b[1]) + y;
	    this.bbox[2] = this.transform_x(b[2],b[3]) + x;
	    this.bbox[3] = this.transform_y(b[2],b[3]) + y;
	    canonicalize(this.bbox);

	    // update connections
	    for (var i = this.connections.length - 1; i >= 0; --i)
		this.connections[i].update_location();
	}

	Component.prototype.rotate = function(amount) {
	    var old_rotation = this.rotation;
	    this.rotation = (this.rotation + amount) % 8;
	    this.update_coords();

	    // create an undoable edit record here
	    // using old_rotation
	}

	Component.prototype.move_begin = function() {
	    // remember where we started this move
	    this.move_x = this.x;
	    this.move_y = this.y;
	}

	Component.prototype.move = function(dx,dy) {
	    // update coordinates
	    this.x += dx;
	    this.y += dy;
	    this.update_coords();
	}
    
	Component.prototype.move_end = function() {
	    var dx = this.x - this.move_x;
	    var dy = this.y - this.move_y;

	    if (dx != 0 || dy != 0) {
		// create an undoable edit record here

		this.sch.check_wires(this);
	    }
	}

	Component.prototype.add = function(sch) {
	    this.sch = sch;   // we now belong to a schematic!
	    sch.add_component(this);
	    this.update_coords();
	}

	Component.prototype.remove = function() {
	    // remove connection points from schematic
	    for (var i = this.connections.length - 1; i >= 0; --i) {
		var cp = this.connections[i];
		this.sch.remove_connection_point(cp,cp.location);
	    }

	    // remove component from schematic
	    this.sch.remove_component(this);
	    this.sch = undefined;

	    // create an undoable edit record here
	}

	Component.prototype.transform_x = function(x,y) {
	    var rot = this.rotation;
	    if (rot == 0 || rot == 6) return x;
	    else if (rot == 1 || rot == 5) return -y;
	    else if (rot == 2 || rot == 4) return -x;
	    else return y;
	}

	Component.prototype.transform_y = function(x,y) {
	    var rot = this.rotation;
	    if (rot == 1 || rot == 7) return x;
	    else if (rot == 2 || rot == 6) return -y;
	    else if (rot == 3 || rot == 5) return -x;
	    else return y;
	}

	Component.prototype.moveTo = function(c,x,y) {
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;
	    this.sch.moveTo(c,nx,ny);
	}

	Component.prototype.lineTo = function(c,x,y) {
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;
	    this.sch.lineTo(c,nx,ny);
	}

	Component.prototype.draw_line = function(c,x1,y1,x2,y2) {
	    c.strokeStyle = this.selected ? selected_style :
                            this.type == 'w' ? normal_style : component_style;
	    var nx1 = this.transform_x(x1,y1) + this.x;
	    var ny1 = this.transform_y(x1,y1) + this.y;
	    var nx2 = this.transform_x(x2,y2) + this.x;
	    var ny2 = this.transform_y(x2,y2) + this.y;
	    this.sch.draw_line(c,nx1,ny1,nx2,ny2,1);
	}

	Component.prototype.draw_circle = function(c,x,y,radius,filled) {
	    if (filled) c.fillStyle = this.selected ? selected_style : normal_style;
	    else c.strokeStyle = this.selected ? selected_style :
		     this.type == 'w' ? normal_style : component_style;
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;

	    this.sch.draw_arc(c,nx,ny,radius,0,2*Math.PI,false,1,filled);
	}

	rot_angle = [
		     0.0,		// NORTH (identity)
		     Math.PI/2,	// EAST (rot270)
		     Math.PI,	// SOUTH (rot180)
		     3*Math.PI/2,  // WEST (rot90)
		     0.0,		// RNORTH (negy)
		     Math.PI/2,	// REAST (int-neg)
		     Math.PI,	// RSOUTH (negx)
		     3*Math.PI/2,	// RWEST (int-pos)
		     ];

	Component.prototype.draw_arc = function(c,x,y,radius,start_radians,end_radians) {
	    c.strokeStyle = this.selected ? selected_style :
                            this.type == 'w' ? normal_style : component_style;
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;
	    this.sch.draw_arc(c,nx,ny,radius,
			      start_radians+rot_angle[this.rotation],end_radians+rot_angle[this.rotation],
			      false,1,false);
	}

	Component.prototype.draw = function(c) {
	    /*
	    for (var i = this.connections.length - 1; i >= 0; --i) {
		var cp = this.connections[i];
		cp.draw_x(c);
	    }
	    */
	}

	// result of rotating an alignment [rot*9 + align]
	aOrient = [
		   0, 1, 2, 3, 4, 5, 6, 7, 8,		// NORTH (identity)
		   2, 5, 8, 1, 4, 7, 0, 3, 6, 		// EAST (rot270)
		   8, 7, 6, 5, 4, 3, 2, 1, 0,		// SOUTH (rot180)
		   6, 3, 0, 7, 4, 1, 8, 5, 3,		// WEST (rot90)
		   2, 1, 0, 5, 4, 3, 8, 7, 6,		// RNORTH (negy)
		   8, 5, 2, 7, 4, 1, 6, 3, 0, 		// REAST (int-neg)
		   6, 7, 8, 3, 4, 5, 0, 1, 2,		// RSOUTH (negx)
		   0, 3, 6, 1, 4, 7, 2, 5, 8		// RWEST (int-pos)
		   ];

	textAlign = [
		     'left', 'center', 'right',
		     'left', 'center', 'right',
		     'left', 'center', 'right'
		     ];

	textBaseline = [
			'top', 'top', 'top',
			'middle', 'middle', 'middle',
			'bottom', 'bottom', 'bottom'
			];

	Component.prototype.draw_text = function(c,text,x,y,alignment,size,fill) {
	    var a = aOrient[this.rotation*9 + alignment];
	    c.textAlign = textAlign[a];
	    c.textBaseline = textBaseline[a];
	    if (fill == undefined)
		c.fillStyle = this.selected ? selected_style : normal_style;
	    else
		c.fillStyle = fill;
	    this.sch.draw_text(c,text,
			       this.transform_x(x,y) + this.x,
			       this.transform_y(x,y) + this.y,
			       size);
	}

	Component.prototype.set_select = function(which) {
	    if (which != this.selected) {
		this.selected = which;
		// create an undoable edit record here
	    }
	}
    
	Component.prototype.select = function(x,y,shiftKey) {
	    this.was_previously_selected = this.selected;
	    if (this.near(x,y)) {
		this.set_select(shiftKey ? !this.selected : true);
		return true;
	    } else return false;
	}

	Component.prototype.select_rect = function(s) {
	    this.was_previously_selected = this.selected;
	    if (intersect(this.bbox,s))
		this.set_select(true);
	}

	// if connection point of component c bisects the
	// wire represented by this compononent, return that
	// connection point.  Otherwise return null.
	Component.prototype.bisect = function(c) {
	    return null;
	}

	// does mouse click fall on this component?
	Component.prototype.near = function(x,y) {
	    return inside(this.bbox,x,y);
	}

	Component.prototype.edit_properties = function(x,y) {
	    if (this.near(x,y)) {
		// make an <input> widget for each property
		var fields = new Array();
		for (var i in this.properties)
		    // underscore at beginning of property name => system property
		    if (i.charAt(0) != '_')
			fields[i] = build_input('text',10,this.properties[i]);

		var content = build_table(fields);
		content.fields = fields;
		content.component = this;

		this.sch.dialog('Edit Properties',content,function(content) {
			for (var i in content.fields)
			    content.component.properties[i] = content.fields[i].value;
			content.component.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}

	// clear the labels on all connections
	Component.prototype.clear_labels = function() {
	    for (var i = this.connections.length - 1; i >=0; --i) {
		this.connections[i].clear_label();
	    }
	}

	// default action: don't propagate label
	Component.prototype.propagate_label = function(label) {
	}

	// give components a chance to generate default labels for their connection(s)
	// default action: do nothing
	Component.prototype.add_default_labels = function() {
	}

	// component should generate labels for all unlabeled connections
	Component.prototype.label_connections = function() {
	    for (var i = this.connections.length - 1; i >=0; --i) {
		var cp = this.connections[i];
		if (!cp.label)
		    cp.propagate_label(this.sch.get_next_label());
	    }
	}

	// default behavior: no probe info
	Component.prototype.probe_info = function() { return undefined; }

	// default behavior: nothing to display for DC analysis
	Component.prototype.display_current = function(c,vmap) {
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Connection point
	//
	////////////////////////////////////////////////////////////////////////////////

	connection_point_radius = 2;

	function ConnectionPoint(parent,x,y) {
	    this.parent = parent;
	    this.offset_x = x;
	    this.offset_y = y;
	    this.location = '';
	    this.update_location();
	    this.label = undefined;
	}

	ConnectionPoint.prototype.toString = function() {
	    return '<ConnectionPoint ('+this.offset_x+','+this.offset_y+') '+this.parent.toString()+'>';
	}

	ConnectionPoint.prototype.json = function() {
	    return this.label;
	}

	ConnectionPoint.prototype.clear_label = function() {
	    this.label = undefined;
	}

	ConnectionPoint.prototype.propagate_label = function(label) {
	    // should we check if existing label is the same?  it should be...

	    if (this.label === undefined) {
		// label this connection point
		this.label = label;

		// propagate label to coincident connection points
		this.parent.sch.propagate_label(label,this.location);

		// possibly label other cp's for this device?
		this.parent.propagate_label(label);
	    } else if (this.label != '0' && label != '0' && this.label != label)
		alert("Node has two conflicting labels: "+this.label+", "+label);
	}

	ConnectionPoint.prototype.update_location = function() {
	    // update location string which we use as a key to find coincident connection points
	    var old_location = this.location;
	    var parent = this.parent;
	    var nx = parent.transform_x(this.offset_x,this.offset_y) + parent.x;
	    var ny = parent.transform_y(this.offset_x,this.offset_y) + parent.y;
	    this.x = nx;
	    this.y = ny;
	    this.location = nx + ',' + ny;

	    // add ourselves to the connection list for the new location
	    if (parent.sch) 
		parent.sch.update_connection_point(this,old_location);
	}

	ConnectionPoint.prototype.coincident = function(x,y) {
	    return this.x==x && this.y==y;
	}

	ConnectionPoint.prototype.draw = function(c,n) {
	    if (n != 2)
		this.parent.draw_circle(c,this.offset_x,this.offset_y,connection_point_radius,n > 2);
	}

	ConnectionPoint.prototype.draw_x = function(c) {
	    this.parent.draw_line(c,this.offset_x-2,this.offset_y-2,this.offset_x+2,this.offset_y+2,grid_style);
	    this.parent.draw_line(c,this.offset_x+2,this.offset_y-2,this.offset_x-2,this.offset_y+2,grid_style);
	}

	ConnectionPoint.prototype.display_voltage = function(c,vmap) {
	    var v = vmap[this.label];
	    if (v != undefined) {
		var label = v.toFixed(2) + 'V';
		
		// first draw some solid blocks in the background
		c.globalAlpha = 0.85;
		this.parent.draw_text(c,'\u2588\u2588\u2588',this.offset_x,this.offset_y,
				      4,annotation_size,element_style);
		c.globalAlpha = 1.0;

		// display the node voltage at this connection point
		this.parent.draw_text(c,label,this.offset_x,this.offset_y,
				      4,annotation_size,annotation_style);

		// only display each node voltage once
		delete vmap[this.label];
	    }
	}

	// see if three connection points are collinear
	function collinear(p1,p2,p3) {
	    // from http://mathworld.wolfram.com/Collinear.html
	    var area = p1.x*(p2.y - p3.y) + p2.x*(p3.y - p1.y) + p3.x*(p1.y - p2.y);
	    return area == 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Wire
	//
	////////////////////////////////////////////////////////////////////////////////

	near_distance = 2;   // how close to wire counts as "near by"

	function Wire(x1,y1,x2,y2) {
	    // arbitrarily call x1,y1 the origin
	    Component.call(this,'w',x1,y1,0);
	    this.dx = x2 - x1;
	    this.dy = y2 - y1;
	    this.add_connection(0,0);
	    this.add_connection(this.dx,this.dy);

	    // compute bounding box (expanded slightly)
	    var r = [0,0,this.dx,this.dy];
	    canonicalize(r);
	    r[0] -= near_distance;
	    r[1] -= near_distance;
	    r[2] += near_distance;
	    r[3] += near_distance;
	    this.bounding_box = r;
	    this.update_coords();    // update bbox

	    // used in selection calculations
	    this.len = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
	}
	Wire.prototype = new Component();
	Wire.prototype.constructor = Wire;

	Wire.prototype.toString = function() {
	    return '<Wire ('+this.x+','+this.y+') ('+(this.x+this.dx)+','+(this.y+this.dy)+')>';
	}
    
	// return connection point at other end of wire from specified cp
	Wire.prototype.other_end = function(cp) {
	    if (cp == this.connections[0]) return this.connections[1];
	    else if (cp == this.connections[1]) return this.connections[0];
	    else return undefined;
	}

	Wire.prototype.json = function(index) {
	    var json = ['w',[this.x, this.y, this.x+this.dx, this.y+this.dy]];
	    return json;
	}

	Wire.prototype.draw = function(c) {
	    this.draw_line(c,0,0,this.dx,this.dy);
	}

	Wire.prototype.clone = function(x,y) {
	    return new Wire(x,y,x+this.dx,y+this.dy);
	}

	Wire.prototype.near = function(x,y) {
	    // crude check: (x,y) within expanded bounding box of wire
	    if (inside(this.bbox,x,y)) {
		// compute distance between x,y and nearst point on line
		// http://www.allegro.cc/forums/thread/589720
		var D = Math.abs((x - this.x)*this.dy - (y - this.y)*this.dx)/this.len;
		if (D <= near_distance) return true;
	    }
	    return false;
	}

	// selection rectangle selects wire only if it includes
	// one of the end points
	Wire.prototype.select_rect = function(s) {
	    this.was_previously_selected = this.selected;
	    if (inside(s,this.x,this.y) || inside(s,this.x+this.dx,this.y+this.dy))
		this.set_select(true);
	}

	// if connection point cp bisects the
	// wire represented by this compononent, return true
	Wire.prototype.bisect_cp = function(cp) {
	    var x = cp.x;
	    var y = cp.y;

	    // crude check: (x,y) within expanded bounding box of wire
	    if (inside(this.bbox,x,y)) {
		// compute distance between x,y and nearst point on line
		// http://www.allegro.cc/forums/thread/589720
		var D = Math.abs((x - this.x)*this.dy - (y - this.y)*this.dx)/this.len;
		// final check: ensure point isn't an end point of the wire
		if (D < 1 && !this.connections[0].coincident(x,y) && !this.connections[1].coincident(x,y))
		    return true;
	    }
	    return false;
	}

	// if some connection point of component c bisects the
	// wire represented by this compononent, return that
	// connection point.  Otherwise return null.
	Wire.prototype.bisect = function(c) {
	    if (c == undefined) return;
	    for (var i = c.connections.length - 1; i >= 0; --i) {
		var cp = c.connections[i];
		if (this.bisect_cp(cp)) return cp;
	    }
	    return null;
	}

	Wire.prototype.move_end = function() {
	    // look for wires bisected by this wire
	    this.sch.check_wires(this);

	    // look for connection points that might bisect us
	    this.sch.check_connection_points(this);
	}

	// wires "conduct" their label to the other end
	Wire.prototype.propagate_label = function(label) {
	    // don't worry about relabeling a cp, it won't recurse!
	    this.connections[0].propagate_label(label);
	    this.connections[1].propagate_label(label);
	}

	// Wires have no properties to edit
	Wire.prototype.edit_properties = function(x,y) {
	    return false;
	}

	// some actual component will start the labeling of electrical nodes,
	// so do nothing here
	Wire.prototype.label_connections = function() {
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Ground
	//
	////////////////////////////////////////////////////////////////////////////////

	function Ground(x,y,rotation) {
	    Component.call(this,'g',x,y,rotation);
	    this.add_connection(0,0);
	    this.bounding_box = [-6,0,6,8];
	    this.update_coords();
	}
	Ground.prototype = new Component();
	Ground.prototype.constructor = Ground;

	Ground.prototype.toString = function() {
	    return '<Ground ('+this.x+','+this.y+')>';
	}
    
	Ground.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,8);
	    this.draw_line(c,-6,8,6,8);
	}

	Ground.prototype.clone = function(x,y) {
	    return new Ground(x,y,this.rotation);
	}

	// Grounds no properties to edit
	Ground.prototype.edit_properties = function(x,y) {
	    return false;
	}

	// give components a chance to generate a label for their connection(s)
	// default action: do nothing
	Ground.prototype.add_default_labels = function() {
	    this.connections[0].propagate_label('0');   // canonical label for GND node
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Label
	//
	////////////////////////////////////////////////////////////////////////////////

	function Label(x,y,rotation,label) {
	    Component.call(this,'L',x,y,rotation);
	    this.properties['label'] = label ? label : '???';
	    this.add_connection(0,0);
	    this.bounding_box = [-2,0,2,8];
	    this.update_coords();
	}
	Label.prototype = new Component();
	Label.prototype.constructor = Label;

	Label.prototype.toString = function() {
	    return '<Label'+' ('+this.x+','+this.y+')>';
	}
    
	Label.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,8);
	    this.draw_text(c,this.properties['label'],0,9,1,property_size);
	}

	Label.prototype.clone = function(x,y) {
	    return new Label(x,y,this.rotation,this.properties['label']);
	}

	// give components a chance to generate a label for their connection(s)
	// default action: do nothing
	Label.prototype.add_default_labels = function() {
	    this.connections[0].propagate_label(this.properties['label']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Voltage Probe
	//
	////////////////////////////////////////////////////////////////////////////////

	probe_colors = ['red','green','blue','cyan','magenta','yellow','black','x-axis'];
	probe_colors_rgb = {
	    'red': 'rgb(255,64,64)',
	    'green': 'rgb(64,255,64)',
	    'blue': 'rgb(64,64,255)',
	    'cyan': 'rgb(64,255,255)',
	    'magenta' : 'rgb(255,64,255)',
	    'yellow': 'rgb(255,255,64)',
	    'black': 'rgb(0,0,0)',
	    'x-axis': undefined
	};

	function Probe(x,y,rotation,color,offset) {
	    Component.call(this,'s',x,y,rotation);
	    this.add_connection(0,0);
	    this.properties['color'] = color ? color : 'cyan';
	    this.properties['offset'] = (offset==undefined || offset=='') ? '0' : offset;
	    this.bounding_box = [0,0,27,-21];
	    this.update_coords();
	}
	Probe.prototype = new Component();
	Probe.prototype.constructor = Probe;

	Probe.prototype.toString = function() {
	    return '<Probe ('+this.x+','+this.y+')>';
	}
    
	Probe.prototype.draw = function(c) {
	    // draw outline
	    this.draw_line(c,0,0,4,-4);
	    this.draw_line(c,2,-6,6,-2);
	    this.draw_line(c,2,-6,17,-21);
	    this.draw_line(c,6,-2,21,-17);
	    this.draw_line(c,17,-21,21,-17);
	    this.draw_arc(c,19,-11,8,3*Math.PI/2,0);

	    // fill body with plot color
	    var color = probe_colors_rgb[this.properties['color']];
	    if (color != undefined) {
		c.fillStyle = color;
		c.beginPath();
		this.moveTo(c,2,-6);
		this.lineTo(c,6,-2);
		this.lineTo(c,21,-17);
		this.lineTo(c,17,-21);
		this.lineTo(c,2,-6);
		c.fill();
	    } else {
		this.draw_text(c,this.properties['color'],27,-11,1,property_size);
	    }
	}

	Probe.prototype.clone = function(x,y) {
	    return new Probe(x,y,this.rotation,this.properties['color'],this.properties['offset']);
	}

	Probe.prototype.edit_properties = function(x,y) {
	    if (inside(this.bbox,x,y)) {
		var fields = new Array();
		fields['Plot color'] = build_select(probe_colors,this.properties['color']);
		fields['Plot offset'] = build_input('text',10,this.properties['offset']);

		var content = build_table(fields);
		content.fields = fields;
		content.component = this;

		this.sch.dialog('Edit Properties',content,function(content) {
			var color_choice = content.fields['Plot color'];
			content.component.properties['color'] = probe_colors[color_choice.selectedIndex];
			content.component.properties['offset'] = content.fields['Plot offset'].value;
			content.component.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}

	// return [color, node_label, offset, type] for this probe
	Probe.prototype.probe_info = function() {
	    var color = this.properties['color'];
	    var offset = this.properties['offset'];
	    if (offset==undefined || offset=="") offset = '0';
	    return [color,this.connections[0].label,offset,'voltage'];
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Ammeter Probe
	//
	////////////////////////////////////////////////////////////////////////////////

	function Ammeter(x,y,rotation,color,offset) {
	    Component.call(this,'a',x,y,rotation);
	    this.add_connection(0,0);   // pos
	    this.add_connection(16,0);   // neg
	    this.properties['color'] = color ? color : 'magenta';
	    this.properties['offset'] = (offset==undefined || offset=='') ? '0' : offset;
	    this.bounding_box = [-3,0,16,3];
	    this.update_coords();
	}
	Ammeter.prototype = new Component();
	Ammeter.prototype.constructor = Ammeter;

	Ammeter.prototype.toString = function() {
	    return '<Ammeter ('+this.x+','+this.y+')>';
	}
    
	Ammeter.prototype.move_end = function() {
	    Component.prototype.move_end.call(this);   // do the normal processing

	    // special for current probes: see if probe has been placed
	    // in the middle of wire, creating three wire segments one
	    // of which is shorting the two terminals of the probe.  If
	    // so, auto remove the shorting segment.
	    var e1 = this.connections[0].location;
	    var e2 = this.connections[1].location;
	    var cplist = this.sch.find_connections(this.connections[0]);
	    for (var i = cplist.length - 1; i >= 0; --i) {
		var c = cplist[i].parent;  // a component connected to ammeter terminal
		// look for a wire whose end points match those of the ammeter
		if (c.type == 'w') {
		    var c_e1 = c.connections[0].location;
		    var c_e2 = c.connections[1].location;
		    if ((e1 == c_e1 && c2 == c_e2) || (e1 == c_e2 && e2 == c_e1)) {
			c.remove();
			break;
		    }
		}
	    }
	}

	Ammeter.prototype.draw = function(c) {
	    this.draw_line(c,0,0,16,0);

	    // draw chevron in probe color
	    c.strokeStyle = probe_colors_rgb[this.properties['color']];
	    if (c.strokeStyle != undefined) {
		c.beginPath();
		this.moveTo(c,6,-3);
		this.lineTo(c,10,0);
		this.lineTo(c,6,3);
		c.stroke();
	    }
	}

	Ammeter.prototype.clone = function(x,y) {
	    return new Ammeter(x,y,this.rotation,this.properties['color'],this.properties['offset']);
	}

	// share code with voltage probe
	Ammeter.prototype.edit_properties = Probe.prototype.edit_properties;

	Ammeter.prototype.label = function() {
	    var name = this.properties['name'];
	    var label = 'I(' + (name ? name : '_' + this.properties['_json_']) + ')';
	    return label;
	}

	// display current for DC analysis
	Ammeter.prototype.display_current = function(c,vmap) {
	    var label = this.label();
	    var v = vmap[label];
	    if (v != undefined) {
		var i = engineering_notation(v,2) + 'A';
		this.draw_text(c,i,8,-5,7,annotation_size,annotation_style);

		// only display each current once
		delete vmap[label];
	    }
	}

	// return [color, current_label, offset, type] for this probe
	Ammeter.prototype.probe_info = function() {
	    var color = this.properties['color'];
	    var offset = this.properties['offset'];
	    if (offset==undefined || offset=="") offset = '0';
	    return [color,this.label(),offset,'current'];
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Resistor
	//
	////////////////////////////////////////////////////////////////////////////////

	function Resistor(x,y,rotation,name,r) {
	    Component.call(this,'r',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['r'] = r ? r : '1';
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-5,0,5,48];
	    this.update_coords();
	}
	Resistor.prototype = new Component();
	Resistor.prototype.constructor = Resistor;

	Resistor.prototype.toString = function() {
	    return '<Resistor '+this.properties['r']+' ('+this.x+','+this.y+')>';
	}
    
	Resistor.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,12);
	    this.draw_line(c,0,12,4,14);
	    this.draw_line(c,4,14,-4,18);
	    this.draw_line(c,-4,18,4,22);
	    this.draw_line(c,4,22,-4,26);
	    this.draw_line(c,-4,26,4,30);
	    this.draw_line(c,4,30,-4,34);
	    this.draw_line(c,-4,34,0,36);
	    this.draw_line(c,0,36,0,48);
	    if (this.properties['r'])
		this.draw_text(c,this.properties['r']+'\u03A9',5,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-5,24,5,property_size);
	}

	Resistor.prototype.clone = function(x,y) {
	    return new Resistor(x,y,this.rotation,this.properties['name'],this.properties['r']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Capacitor
	//
	////////////////////////////////////////////////////////////////////////////////

	function Capacitor(x,y,rotation,name,c) {
	    Component.call(this,'c',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['c'] = c ? c : '1p';
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-8,0,8,48];
	    this.update_coords();
	}
	Capacitor.prototype = new Component();
	Capacitor.prototype.constructor = Capacitor;

	Capacitor.prototype.toString = function() {
	    return '<Capacitor '+this.properties['r']+' ('+this.x+','+this.y+')>';
	}
    
	Capacitor.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,22);
	    this.draw_line(c,-8,22,8,22);
	    this.draw_line(c,-8,26,8,26);
	    this.draw_line(c,0,26,0,48);
	    if (this.properties['c'])
		this.draw_text(c,this.properties['c']+'F',9,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-9,24,5,property_size);
	}

	Capacitor.prototype.clone = function(x,y) {
	    return new Capacitor(x,y,this.rotation,this.properties['name'],this.properties['c']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Inductor
	//
	////////////////////////////////////////////////////////////////////////////////

	function Inductor(x,y,rotation,name,l) {
	    Component.call(this,'l',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['l'] = l ? l : '1n';
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-4,0,5,48];
	    this.update_coords();
	}
	Inductor.prototype = new Component();
	Inductor.prototype.constructor = Inductor;

	Inductor.prototype.toString = function() {
	    return '<Inductor '+this.properties['l']+' ('+this.x+','+this.y+')>';
	}
    
	Inductor.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,14);
	    this.draw_arc(c,0,18,4,6*Math.PI/4,3*Math.PI/4);
	    this.draw_arc(c,0,24,4,5*Math.PI/4,3*Math.PI/4);
	    this.draw_arc(c,0,30,4,5*Math.PI/4,2*Math.PI/4);
	    this.draw_line(c,0,34,0,48);

	    if (this.properties['l'])
		this.draw_text(c,this.properties['l']+'H',6,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-3,24,5,property_size);
	}

	Inductor.prototype.clone = function(x,y) {
	    return new Inductor(x,y,this.rotation,this.properties['name'],this.properties['l']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Diode
	//
	////////////////////////////////////////////////////////////////////////////////

	diode_types = ['normal','ideal'];

	function Diode(x,y,rotation,name,area,type) {
	    Component.call(this,'d',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['area'] = area ? area : '1';
	    this.properties['type'] = type ? type : 'normal';
	    this.add_connection(0,0);   // anode
	    this.add_connection(0,48);  // cathode
	    this.bounding_box = (type == 'ideal') ? [-12,0,12,48] : [-8,0,8,48];
	    this.update_coords();
	}
	Diode.prototype = new Component();
	Diode.prototype.constructor = Diode;

	Diode.prototype.toString = function() {
	    return '<Diode '+this.properties['area']+' ('+this.x+','+this.y+')>';
	}
    
	Diode.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,16);
	    this.draw_line(c,-8,16,8,16);
	    this.draw_line(c,-8,16,0,32);
	    this.draw_line(c,8,16,0,32);
	    this.draw_line(c,-8,32,8,32);
	    this.draw_line(c,0,32,0,48);

	    if (this.properties['type'] == 'ideal') {
		// put a box around an ideal diode
		this.draw_line(c,-10,12,10,12);
		this.draw_line(c,-10,12,-10,36);
		this.draw_line(c,10,12,10,36);
		this.draw_line(c,-10,36,10,36);
	    }

	    if (this.properties['area'])
		this.draw_text(c,this.properties['area'],10,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-10,24,5,property_size);
	}

	Diode.prototype.clone = function(x,y) {
	    return new Diode(x,y,this.rotation,this.properties['name'],this.properties['area'],this.properties['type']);
	}

	Diode.prototype.edit_properties = function(x,y) {
	    if (inside(this.bbox,x,y)) {
		var fields = new Array();
		fields['name'] = build_input('text',10,this.properties['name']);
		fields['area'] = build_input('text',10,this.properties['area']);
		fields['type'] = build_select(diode_types,this.properties['type']);

		var content = build_table(fields);
		content.fields = fields;
		content.component = this;

		this.sch.dialog('Edit Properties',content,function(content) {
			content.component.properties['name'] = content.fields['name'].value;
			content.component.properties['area'] = content.fields['area'].value;
			content.component.properties['type'] = diode_types[content.fields['type'].selectedIndex];
			content.component.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  N-channel Mosfet
	//
	////////////////////////////////////////////////////////////////////////////////

	function NFet(x,y,rotation,name,w_over_l) {
	    Component.call(this,'n',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['W/L'] = w_over_l ? w_over_l : '2';
	    this.add_connection(0,0);   // drain
	    this.add_connection(-24,24);  // gate
	    this.add_connection(0,48);  // source
	    this.bounding_box = [-24,0,8,48];
	    this.update_coords();
	}
	NFet.prototype = new Component();
	NFet.prototype.constructor = NFet;

	NFet.prototype.toString = function() {
	    return '<NFet '+this.properties['W/L']+' ('+this.x+','+this.y+')>';
	}
    
	NFet.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,16);
	    this.draw_line(c,-8,16,0,16);
	    this.draw_line(c,-8,16,-8,32);
	    this.draw_line(c,-8,32,0,32);
	    this.draw_line(c,0,32,0,48);

	    this.draw_line(c,-24,24,-12,24);
	    this.draw_line(c,-12,16,-12,32);

	    var dim = this.properties['W/L'];
	    if (this.properties['name']) {
		this.draw_text(c,this.properties['name'],2,22,6,property_size);
		this.draw_text(c,dim,2,26,0,property_size);
	    } else
		this.draw_text(c,dim,2,24,3,property_size);
	}

	NFet.prototype.clone = function(x,y) {
	    return new NFet(x,y,this.rotation,this.properties['name'],this.properties['W/L']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  P-channel Mosfet
	//
	////////////////////////////////////////////////////////////////////////////////

	function PFet(x,y,rotation,name,w_over_l) {
	    Component.call(this,'p',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['W/L'] = w_over_l ? w_over_l : '2';
	    this.add_connection(0,0);   // drain
	    this.add_connection(-24,24);  // gate
	    this.add_connection(0,48);  // source
	    this.bounding_box = [-24,0,8,48];
	    this.update_coords();
	}
	PFet.prototype = new Component();
	PFet.prototype.constructor = PFet;

	PFet.prototype.toString = function() {
	    return '<PFet '+this.properties['W/L']+' ('+this.x+','+this.y+')>';
	}
    
	PFet.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,16);
	    this.draw_line(c,-8,16,0,16);
	    this.draw_line(c,-8,16,-8,32);
	    this.draw_line(c,-8,32,0,32);
	    this.draw_line(c,0,32,0,48);

	    this.draw_line(c,-24,24,-16,24);

	    this.draw_circle(c,-14,24,2,false);
	    this.draw_line(c,-12,16,-12,32);

	    var dim = this.properties['W/L'];
	    if (this.properties['name']) {
		this.draw_text(c,this.properties['name'],2,22,6,property_size);
		this.draw_text(c,dim,2,26,0,property_size);
	    } else
		this.draw_text(c,dim,2,24,3,property_size);
	}

	PFet.prototype.clone = function(x,y) {
	    return new PFet(x,y,this.rotation,this.properties['name'],this.properties['W/L']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Op Amp
	//
	////////////////////////////////////////////////////////////////////////////////

	function OpAmp(x,y,rotation,name,A) {
	    Component.call(this,'o',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['A'] = A ? A : '30000';
	    this.add_connection(0,0);   // +
	    this.add_connection(0,16);  // -
	    this.add_connection(48,8);  // output
	    this.add_connection(24,32);  // ground
	    this.bounding_box = [0,-8,48,32];
	    this.update_coords();
	}
	OpAmp.prototype = new Component();
	OpAmp.prototype.constructor = OpAmp;

	OpAmp.prototype.toString = function() {
	    return '<OpAmp'+this.properties['A']+' ('+this.x+','+this.y+')>';
	}
    
	OpAmp.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    // triangle
	    this.draw_line(c,8,-8,8,24);
	    this.draw_line(c,8,-8,40,8);
	    this.draw_line(c,8,24,40,8);
	    // inputs and output
	    this.draw_line(c,0,0,8,0);
	    this.draw_line(c,0,16,8,16);
	    this.draw_text(c,'gnd',37,18,property_size);
	    this.draw_line(c,40,8,48,8);
	    this.draw_line(c,24,16,24,32);
	    // + and -
	    this.draw_line(c,10,0,16,0);
	    this.draw_line(c,13,-3,13,3);
	    this.draw_line(c,10,16,16,16);

	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],32,16,0,property_size);
	}

	OpAmp.prototype.clone = function(x,y) {
	    return new OpAmp(x,y,this.rotation,this.properties['name'],this.properties['A']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Source
	//
	////////////////////////////////////////////////////////////////////////////////

	
	function Source(x,y,rotation,name,type,value) {
	    Component.call(this,type,x,y,rotation);
	    this.properties['name'] = name;
	    if (value == undefined) value = 'dc(1)';
	    this.properties['value'] = value;
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-12,0,12,48];
	    this.update_coords();

	    this.content = document.createElement('div');  // used by edit_properties
	}
	Source.prototype = new Component();
	Source.prototype.constructor = Source;

	Source.prototype.toString = function() {
	    return '<'+this.type+'source '+this.properties['params']+' ('+this.x+','+this.y+')>';
	}
    
	Source.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,12);
	    this.draw_circle(c,0,24,12,false);
	    this.draw_line(c,0,36,0,48);

	    if (this.type == 'v') {  // voltage source
		//this.draw_text(c,'+',0,12,1,property_size);
		//this.draw_text(c,'\u2013',0,36,7,property_size);  // minus sign
		// draw + and -
		this.draw_line(c,0,15,0,21);
		this.draw_line(c,-3,18,3,18);
		this.draw_line(c,-3,30,3,30);
		// draw V
		//this.draw_line(c,-3,20,0,28);
		//this.draw_line(c,3,20,0,28);
	    } else if (this.type == 'i') {  // current source
		// draw arrow: pos to neg
		this.draw_line(c,0,15,0,32);
		this.draw_line(c,-3,26,0,32);
		this.draw_line(c,3,26,0,32);
	    }

	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-13,24,5,property_size);
	    if (this.properties['value'])
		this.draw_text(c,this.properties['value'],13,24,3,property_size);
	}

	// map source function name to labels for each source parameter
	source_functions = {
	    'dc': ['DC value'],

	    'impulse': ['Height',
			'Width (secs)'],

	    'step': ['Initial value',
		     'Plateau value',
		     'Delay until step (secs)',
		     'Rise time (secs)'],

	    'square': ['Initial value',
		       'Plateau value',
		       'Frequency (Hz)',
		       'Duty cycle (%)'],

	    'triangle': ['Initial value',
			 'Plateau value',
			 'Frequency (Hz)'],

	    'pwl': ['Comma-separated list of alternating times and values'],

	    'pwl_repeating': ['Comma-separated list of alternating times and values'],

	    'pulse': ['Initial value',
		      'Plateau value',
		      'Delay until pulse (secs)',
		      'Time for first transition (secs)',
		      'Time for second transition (secs)',
		      'Pulse width (secs)',
		      'Period (secs)'],

	    'sin': ['Offset value',
		    'Amplitude',
		    'Frequency (Hz)',
		    'Delay until sin starts (secs)',
		    'Phase offset (degrees)']
	}

	// build property editor div
	Source.prototype.build_content = function(src) {
	    // make an <input> widget for each property
	    var fields = []
	    fields['name'] = build_input('text',10,this.properties['name']);

	    if (src == undefined) {
		fields['value'] = this.properties['value'];
	    } else {
		// fancy version: add select tag for source type
		var src_types = [];
		for (var t in source_functions) src_types.push(t);
		var type_select = build_select(src_types,src.fun);
		type_select.component = this;
		type_select.addEventListener('change',source_type_changed,false)
		fields['type'] = type_select;

		if (src.fun == 'pwl' || src.run == 'pwl_repeating') {
		    var v = '';
		    var first = true;
		    for (var i = 0; i < src.args.length; i++) {
			if (first) first = false;
			else v += ',';
			v += engineering_notation(src.args[i],3);
			if (i % 2 == 0) v += 's';
		    }
		    fields[source_functions[src.fun][0]] = build_input('text',30,v);
		} else {
		    // followed separate input tag for each parameter
		    var labels = source_functions[src.fun];
		    for (var i = 0; i < labels.length; i++) {
			var v = engineering_notation(src.args[i],3);
			fields[labels[i]] = build_input('text',10,v);
		    }
		}
	    }

	    var div = this.content;
	    if (div.hasChildNodes())
		div.removeChild(div.firstChild);  // remove table of input fields
	    div.appendChild(build_table(fields));
	    div.fields = fields;
	    div.component = this;
	    return div;
	}

	function source_type_changed(event) {
	    if (!event) event = window.event;
	    var select = (window.event) ? event.srcElement : event.target;

	    // see where to get source parameters from
	    var type = select.options[select.selectedIndex].value;
	    var src = undefined;
	    if (this.src != undefined && type == this.src.fun)
		src = this.src;
	    else if (typeof cktsim != 'undefined')
		src = cktsim.parse_source(type+'()');

	    select.component.build_content(src);
	}

	Source.prototype.edit_properties = function(x,y) {
	    if (this.near(x,y)) {
		this.src = undefined;
		if (typeof cktsim != 'undefined')
		    this.src = cktsim.parse_source(this.properties['value']);
		var content = this.build_content(this.src);

		this.sch.dialog('Edit Properties',content,function(content) {
			var c = content.component;
			var fields = content.fields;

			var first = true;
			var value = '';
			for (var label in fields) {
			    if (label == 'name') 
				c.properties['name'] = fields['name'].value;
			    else if (label == 'value')  {
				// if unknown source type
				value = fields['value'].value;
				c.sch.redraw_background();
				return;
			    } else if (label == 'type') {
				var select = fields['type'];
				value = select.options[select.selectedIndex].value + '(';
			    } else {
				if (first) first = false;
				else value += ',';
				value += fields[label].value;
			    }
			}
			c.properties['value'] = value + ')';
			c.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}


	function VSource(x,y,rotation,name,value) {
	    Source.call(this,x,y,rotation,name,'v',value);
	    this.type = 'v';
	}
	VSource.prototype = new Component();
	VSource.prototype.constructor = VSource;
	VSource.prototype.toString = Source.prototype.toString;
	VSource.prototype.draw = Source.prototype.draw;
	VSource.prototype.clone = Source.prototype.clone;
	VSource.prototype.build_content = Source.prototype.build_content;
	VSource.prototype.edit_properties = Source.prototype.edit_properties;

	// display current for DC analysis
	VSource.prototype.display_current = function(c,vmap) {
	    var name = this.properties['name'];
	    var label = 'I(' + (name ? name : '_' + this.properties['_json_']) + ')';
	    var v = vmap[label];
	    if (v != undefined) {
		// first draw some solid blocks in the background
		c.globalAlpha = 0.5;
		this.draw_text(c,'\u2588\u2588\u2588',-8,8,4,annotation_size,element_style);
		c.globalAlpha = 1.0;

		// display the element current 
		var i = engineering_notation(v,2) + 'A';
		this.draw_text(c,i,-3,5,5,annotation_size,annotation_style);
		// draw arrow for current
		this.draw_line(c,-3,4,0,8);
		this.draw_line(c,3,4,0,8);
		// only display each current once
		delete vmap[label];
	    }
	}

	VSource.prototype.clone = function(x,y) {
	    return new VSource(x,y,this.rotation,this.properties['name'],this.properties['value']);
	}

	function ISource(x,y,rotation,name,value) {
	    Source.call(this,x,y,rotation,name,'i',value);
	    this.type = 'i';
	}
	ISource.prototype = new Component();
	ISource.prototype.constructor = ISource;
	ISource.prototype.toString = Source.prototype.toString;
	ISource.prototype.draw = Source.prototype.draw;
	ISource.prototype.clone = Source.prototype.clone;
	ISource.prototype.build_content = Source.prototype.build_content;
	ISource.prototype.edit_properties = Source.prototype.edit_properties;

	ISource.prototype.clone = function(x,y) {
	    return new ISource(x,y,this.rotation,this.properties['name'],this.properties['value']);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  JQuery slider support for setting a component value
	//
	///////////////////////////////////////////////////////////////////////////////

	function component_slider(event,ui) {
	    var sname = $(this).slider("option","schematic");

	    // set value of specified component
	    var cname = $(this).slider("option","component");
	    var pname = $(this).slider("option","property");
	    var suffix = $(this).slider("option","suffix");
	    if (typeof suffix != "string") suffix = "";

	    var v = ui.value;
	    $(this).slider("value",v);  // move slider's indicator

	    var choices = $(this).slider("option","choices");
	    if (choices instanceof Array) v = choices[v];

	    // selector may match several schematics
	    $("." + sname).each(function(index,element) {
		    element.schematic.set_property(cname,pname,v.toString() + suffix);
		})

	    // perform requested analysis
	    var analysis = $(this).slider("option","analysis");
	    if (analysis == "dc")
		$("." + sname).each(function(index,element) {
			element.schematic.dc_analysis();
		    })

	    return false;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Module definition
	//
	///////////////////////////////////////////////////////////////////////////////

	var module = {
	    'Schematic': Schematic,
	    'component_slider': component_slider
	}
	return module;
    }());

(function (define) {
define(
'video/00_async_process.js',
[],
function() {
"use strict";
/**
 * Provides convenient way to process big amount of data without UI blocking.
 *
 * @param {array} list Array to process.
 * @param {function} process Calls this function on each item in the list.
 * @return {array} Returns a Promise object to observe when all actions of a
 *                 certain type bound to the collection, queued or not, have finished.
 */
    var AsyncProcess = {
        array: function (list, process) {
            if (!_.isArray(list)) {
                return $.Deferred().reject().promise();
            }

            if (!_.isFunction(process) || !list.length) {
                return $.Deferred().resolve(list).promise();
            }

            var MAX_DELAY = 50, // maximum amount of time that js code should be allowed to run continuously
                dfd = $.Deferred(),
                result = [],
                index = 0,
                len = list.length;

            var getCurrentTime = function () {
                return (new Date()).getTime();
            };

            var handler = function () {
                var start = getCurrentTime();

                do {
                    result[index] = process(list[index], index);
                    index++;
                } while (index < len && getCurrentTime() - start < MAX_DELAY);

                if (index < len) {
                    setTimeout(handler, 25);
                } else {
                    dfd.resolve(result);
                }
            };

            setTimeout(handler, 25);

            return dfd.promise();
        }
    };

    return AsyncProcess;
});
}(RequireJS.define));


// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('GeneralMethods', [], function () {
    if (!String.prototype.trim) {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        String.prototype.trim = function trim(str) {
            return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        };
    }

    return {
        'module_name': 'GeneralMethods',
        'module_status': 'OK'
    };
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

window.WordCloud = function (el) {
    RequireJS.require(['WordCloudMain'], function (WordCloudMain) {
        new WordCloudMain(el);
    });
};

/*!
 * Draggabilly PACKAGED v1.0.5
 * Make that shiz draggable
 * http://draggabilly.desandro.com
 */

/*!
 * classie - class helper functions
 * from bonzo https://github.com/ded/bonzo
 * 
 * classie.has( elem, 'my-class' ) -> true/false
 * classie.add( elem, 'my-new-class' )
 * classie.remove( elem, 'my-unwanted-class' )
 * classie.toggle( elem, 'my-class' )
 */

/*jshint browser: true, strict: true, undef: true */
/*global define: false */

( function( window ) {

    'use strict';

// class helper functions from bonzo https://github.com/ded/bonzo

    function classReg( className ) {
        return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
    }

// classList support for class management
// altho to be fair, the api sucks because it won't accept multiple classes at once
    var hasClass, addClass, removeClass;

    if ( 'classList' in document.documentElement ) {
        hasClass = function( elem, c ) {
            return elem.classList.contains( c );
        };
        addClass = function( elem, c ) {
            elem.classList.add( c );
        };
        removeClass = function( elem, c ) {
            elem.classList.remove( c );
        };
    }
    else {
        hasClass = function( elem, c ) {
            return classReg( c ).test( elem.className );
        };
        addClass = function( elem, c ) {
            if ( !hasClass( elem, c ) ) {
                elem.className = elem.className + ' ' + c;
            }
        };
        removeClass = function( elem, c ) {
            elem.className = elem.className.replace( classReg( c ), ' ' );
        };
    }

    function toggleClass( elem, c ) {
        var fn = hasClass( elem, c ) ? removeClass : addClass;
        fn( elem, c );
    }

    var classie = {
        // full names
        hasClass: hasClass,
        addClass: addClass,
        removeClass: removeClass,
        toggleClass: toggleClass,
        // short names
        has: hasClass,
        add: addClass,
        remove: removeClass,
        toggle: toggleClass
    };

// transport
    if ( typeof define === 'function' && define.amd ) {
        // AMD
        define("classie", classie);
    } else {
        // browser global
        window.classie = classie;
    }

})( window );

/*!
 * eventie v1.0.3
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {

    'use strict';

    var docElem = document.documentElement;

    var bind = function() {};

    if ( docElem.addEventListener ) {
        bind = function( obj, type, fn ) {
            obj.addEventListener( type, fn, false );
        };
    } else if ( docElem.attachEvent ) {
        bind = function( obj, type, fn ) {
            obj[ type + fn ] = fn.handleEvent ?
                function() {
                    var event = window.event;
                    // add event.target
                    event.target = event.target || event.srcElement;
                    fn.handleEvent.call( fn, event );
                } :
                function() {
                    var event = window.event;
                    // add event.target
                    event.target = event.target || event.srcElement;
                    fn.call( obj, event );
                };
            obj.attachEvent( "on" + type, obj[ type + fn ] );
        };
    }

    var unbind = function() {};

    if ( docElem.removeEventListener ) {
        unbind = function( obj, type, fn ) {
            obj.removeEventListener( type, fn, false );
        };
    } else if ( docElem.detachEvent ) {
        unbind = function( obj, type, fn ) {
            obj.detachEvent( "on" + type, obj[ type + fn ] );
            try {
                delete obj[ type + fn ];
            } catch ( err ) {
                // can't delete window object properties
                obj[ type + fn ] = undefined;
            }
        };
    }

    var eventie = {
        bind: bind,
        unbind: unbind
    };

// transport
    if ( typeof define === 'function' && define.amd ) {
        // AMD
        define("eventie", eventie);
    } else {
        // browser global
        window.eventie = eventie;
    }

})( this );

/*!
 * EventEmitter v4.2.4 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function () {
    'use strict';

    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size

    // Easy access to the prototype
    var proto = EventEmitter.prototype;

    /**
     * Finds the index of the listener for the event in it's storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (typeof evt === 'object') {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        }
        else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after it's first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of it's properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    }
                    else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        }
        else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        }
        else if (type === 'object') {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        }
        else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listeners = this.getListenersAsObject(evt);
        var listener;
        var i;
        var key;
        var response;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                i = listeners[key].length;

                while (i--) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[key][i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        }
        else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    // Expose the class either via AMD, CommonJS or the global object
    if (typeof define === 'function' && define.amd) {
        define("EventEmitter", function () {
            return EventEmitter;
        });
    }
    else if (typeof module === 'object' && module.exports){
        module.exports = EventEmitter;
    }
    else {
        this.EventEmitter = EventEmitter;
    }
}.call(this));

/*!
 * getStyleProperty by kangax
 * http://perfectionkills.com/feature-testing-css-properties/
 */

/*jshint browser: true, strict: true, undef: true */
/*globals define: false */

( function( window ) {

    'use strict';

    var prefixes = 'Webkit Moz ms Ms O'.split(' ');
    var docElemStyle = document.documentElement.style;

    function getStyleProperty( propName ) {
        if ( !propName ) {
            return;
        }

        // test standard property first
        if ( typeof docElemStyle[ propName ] === 'string' ) {
            return propName;
        }

        // capitalize
        propName = propName.charAt(0).toUpperCase() + propName.slice(1);

        // test vendor specific properties
        var prefixed;
        for ( var i=0, len = prefixes.length; i < len; i++ ) {
            prefixed = prefixes[i] + propName;
            if ( typeof docElemStyle[ prefixed ] === 'string' ) {
                return prefixed;
            }
        }
    }

// transport
    if ( typeof define === 'function' && define.amd ) {
        // AMD
        define("getStyleProperty", function() {
            return getStyleProperty;
        });
    } else {
        // browser global
        window.getStyleProperty = getStyleProperty;
    }

})( window );

/**
 * getSize v1.1.4
 * measure size of elements
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false */

( function( window, undefined ) {

    'use strict';

// -------------------------- helpers -------------------------- //

    var defView = document.defaultView;

    var getStyle = defView && defView.getComputedStyle ?
        function( elem ) {
            return defView.getComputedStyle( elem, null );
        } :
        function( elem ) {
            return elem.currentStyle;
        };

// get a number from a string, not a percentage
    function getStyleSize( value ) {
        var num = parseFloat( value );
        // not a percent like '100%', and a number
        var isValid = value.indexOf('%') === -1 && !isNaN( num );
        return isValid && num;
    }

// -------------------------- measurements -------------------------- //

    var measurements = [
        'paddingLeft',
        'paddingRight',
        'paddingTop',
        'paddingBottom',
        'marginLeft',
        'marginRight',
        'marginTop',
        'marginBottom',
        'borderLeftWidth',
        'borderRightWidth',
        'borderTopWidth',
        'borderBottomWidth'
    ];

    function getZeroSize() {
        var size = {
            width: 0,
            height: 0,
            innerWidth: 0,
            innerHeight: 0,
            outerWidth: 0,
            outerHeight: 0
        };
        for ( var i=0, len = measurements.length; i < len; i++ ) {
            var measurement = measurements[i];
            size[ measurement ] = 0;
        }
        return size;
    }



    function defineGetSize( getStyleProperty ) {

// -------------------------- box sizing -------------------------- //

        var boxSizingProp = getStyleProperty('boxSizing');
        var isBoxSizeOuter;

        /**
         * WebKit measures the outer-width on style.width on border-box elems
         * IE & Firefox measures the inner-width
         */
        ( function() {
            if ( !boxSizingProp ) {
                return;
            }

            var div = document.createElement('div');
            div.style.width = '200px';
            div.style.padding = '1px 2px 3px 4px';
            div.style.borderStyle = 'solid';
            div.style.borderWidth = '1px 2px 3px 4px';
            div.style[ boxSizingProp ] = 'border-box';

            var body = document.body || document.documentElement;
            body.appendChild( div );
            var style = getStyle( div );

            isBoxSizeOuter = getStyleSize( style.width ) === 200;
            body.removeChild( div );
        })();


// -------------------------- getSize -------------------------- //

        function getSize( elem ) {
            // use querySeletor if elem is string
            if ( typeof elem === 'string' ) {
                elem = document.querySelector( elem );
            }

            // do not proceed on non-objects
            if ( !elem || typeof elem !== 'object' || !elem.nodeType ) {
                return;
            }

            var style = getStyle( elem );

            // if hidden, everything is 0
            if ( style.display === 'none' ) {
                return getZeroSize();
            }

            var size = {};
            size.width = elem.offsetWidth;
            size.height = elem.offsetHeight;

            var isBorderBox = size.isBorderBox = !!( boxSizingProp &&
                style[ boxSizingProp ] && style[ boxSizingProp ] === 'border-box' );

            // get all measurements
            for ( var i=0, len = measurements.length; i < len; i++ ) {
                var measurement = measurements[i];
                var value = style[ measurement ];
                var num = parseFloat( value );
                // any 'auto', 'medium' value will be 0
                size[ measurement ] = !isNaN( num ) ? num : 0;
            }

            var paddingWidth = size.paddingLeft + size.paddingRight;
            var paddingHeight = size.paddingTop + size.paddingBottom;
            var marginWidth = size.marginLeft + size.marginRight;
            var marginHeight = size.marginTop + size.marginBottom;
            var borderWidth = size.borderLeftWidth + size.borderRightWidth;
            var borderHeight = size.borderTopWidth + size.borderBottomWidth;

            var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

            // overwrite width and height if we can get it from style
            var styleWidth = getStyleSize( style.width );
            if ( styleWidth !== false ) {
                size.width = styleWidth +
                    // add padding and border unless it's already including it
                    ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
            }

            var styleHeight = getStyleSize( style.height );
            if ( styleHeight !== false ) {
                size.height = styleHeight +
                    // add padding and border unless it's already including it
                    ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
            }

            size.innerWidth = size.width - ( paddingWidth + borderWidth );
            size.innerHeight = size.height - ( paddingHeight + borderHeight );

            size.outerWidth = size.width + marginWidth;
            size.outerHeight = size.height + marginHeight;

            return size;
        }

        return getSize;

    }

// transport
    if ( typeof define === 'function' && define.amd ) {
        // AMD
        define("getSize", [ 'getStyleProperty' ], defineGetSize );
    } else {
        // browser global
        window.getSize = defineGetSize( window.getStyleProperty );
    }

})( window );

/*!
 * Draggabilly v1.0.5
 * Make that shiz draggable
 * http://draggabilly.desandro.com
 */

( function( window ) {

    'use strict';

// vars
    var document = window.document;

// -------------------------- helpers -------------------------- //

// extend objects
    function extend( a, b ) {
        for ( var prop in b ) {
            a[ prop ] = b[ prop ];
        }
        return a;
    }

    function noop() {}

// ----- get style ----- //

    var defView = document.defaultView;

    var getStyle = defView && defView.getComputedStyle ?
        function( elem ) {
            return defView.getComputedStyle( elem, null );
        } :
        function( elem ) {
            return elem.currentStyle;
        };


// http://stackoverflow.com/a/384380/182183
    var isElement = ( typeof HTMLElement === 'object' ) ?
        function isElementDOM2( obj ) {
            return obj instanceof HTMLElement;
        } :
        function isElementQuirky( obj ) {
            return obj && typeof obj === 'object' &&
                obj.nodeType === 1 && typeof obj.nodeName === 'string';
        };

// -------------------------- requestAnimationFrame -------------------------- //

// https://gist.github.com/1866474

    var lastTime = 0;
    var prefixes = 'webkit moz ms o'.split(' ');
// get unprefixed rAF and cAF, if present
    var requestAnimationFrame = window.requestAnimationFrame;
    var cancelAnimationFrame = window.cancelAnimationFrame;
// loop through vendor prefixes and get prefixed rAF and cAF
    var prefix;
    for( var i = 0; i < prefixes.length; i++ ) {
        if ( requestAnimationFrame && cancelAnimationFrame ) {
            break;
        }
        prefix = prefixes[i];
        requestAnimationFrame = requestAnimationFrame || window[ prefix + 'RequestAnimationFrame' ];
        cancelAnimationFrame  = cancelAnimationFrame  || window[ prefix + 'CancelAnimationFrame' ] ||
            window[ prefix + 'CancelRequestAnimationFrame' ];
    }

// fallback to setTimeout and clearTimeout if either request/cancel is not supported
    if ( !requestAnimationFrame || !cancelAnimationFrame )  {
        requestAnimationFrame = function( callback ) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
            var id = window.setTimeout( function() {
                callback( currTime + timeToCall );
            }, timeToCall );
            lastTime = currTime + timeToCall;
            return id;
        };

        cancelAnimationFrame = function( id ) {
            window.clearTimeout( id );
        };
    }

// -------------------------- definition -------------------------- //

    function draggabillyDefinition( classie, EventEmitter, eventie, getStyleProperty, getSize ) {

// -------------------------- support -------------------------- //

        var transformProperty = getStyleProperty('transform');
// TODO fix quick & dirty check for 3D support
        var is3d = !!getStyleProperty('perspective');

// --------------------------  -------------------------- //

        function Draggabilly( element, options ) {
            this.element = element;

            this.options = extend( {}, this.options );
            extend( this.options, options );

            this._create();

        }

// inherit EventEmitter methods
        extend( Draggabilly.prototype, EventEmitter.prototype );

        Draggabilly.prototype.options = {
        };

        Draggabilly.prototype._create = function() {

            // properties
            this.position = {};
            this._getPosition();

            this.startPoint = { x: 0, y: 0 };
            this.dragPoint = { x: 0, y: 0 };

            this.startPosition = extend( {}, this.position );

            // set relative positioning
            var style = getStyle( this.element );
            if ( style.position !== 'relative' && style.position !== 'absolute' ) {
                this.element.style.position = 'relative';
            }

            this.enable();
            this.setHandles();

        };

        /**
         * set this.handles and bind start events to 'em
         */
        Draggabilly.prototype.setHandles = function() {
            this.handles = this.options.handle ?
                this.element.querySelectorAll( this.options.handle ) : [ this.element ];

            for ( var i=0, len = this.handles.length; i < len; i++ ) {
                var handle = this.handles[i];
                // bind pointer start event
                // listen for both, for devices like Chrome Pixel
                //   which has touch and mouse events
                eventie.bind( handle, 'mousedown', this );
                eventie.bind( handle, 'touchstart', this );
                disableImgOndragstart( handle );
            }
        };

// remove default dragging interaction on all images in IE8
// IE8 does its own drag thing on images, which messes stuff up

        function noDragStart() {
            return false;
        }

// TODO replace this with a IE8 test
        var isIE8 = 'attachEvent' in document.documentElement;

// IE8 only
        var disableImgOndragstart = !isIE8 ? noop : function( handle ) {

            if ( handle.nodeName === 'IMG' ) {
                handle.ondragstart = noDragStart;
            }

            var images = handle.querySelectorAll('img');
            for ( var i=0, len = images.length; i < len; i++ ) {
                var img = images[i];
                img.ondragstart = noDragStart;
            }
        };


// get left/top position from style
        Draggabilly.prototype._getPosition = function() {
            // properties
            var style = getStyle( this.element );

            var x = parseInt( style.left, 10 );
            var y = parseInt( style.top, 10 );

            // clean up 'auto' or other non-integer values
            this.position.x = isNaN( x ) ? 0 : x;
            this.position.y = isNaN( y ) ? 0 : y;

            this._addTransformPosition( style );
        };

// add transform: translate( x, y ) to position
        Draggabilly.prototype._addTransformPosition = function( style ) {
            if ( !transformProperty ) {
                return;
            }
            var transform = style[ transformProperty ];
            // bail out if value is 'none'
            if ( transform.indexOf('matrix') !== 0 ) {
                return;
            }
            // split matrix(1, 0, 0, 1, x, y)
            var matrixValues = transform.split(',');
            // translate X value is in 12th or 4th position
            var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;
            var translateX = parseInt( matrixValues[ xIndex ], 10 );
            // translate Y value is in 13th or 5th position
            var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );
            this.position.x += translateX;
            this.position.y += translateY;
        };

// -------------------------- events -------------------------- //

// trigger handler methods for events
        Draggabilly.prototype.handleEvent = function( event ) {
            var method = 'on' + event.type;
            if ( this[ method ] ) {
                this[ method ]( event );
            }
        };

// returns the touch that we're keeping track of
        Draggabilly.prototype.getTouch = function( touches ) {
            for ( var i=0, len = touches.length; i < len; i++ ) {
                var touch = touches[i];
                if ( touch.identifier === this.pointerIdentifier ) {
                    return touch;
                }
            }
        };

// ----- start event ----- //

        Draggabilly.prototype.onmousedown = function( event ) {
            this.dragStart( event, event );
        };

        Draggabilly.prototype.ontouchstart = function( event ) {
            // disregard additional touches
            if ( this.isDragging ) {
                return;
            }

            this.dragStart( event, event.changedTouches[0] );
        };

        function setPointerPoint( point, pointer ) {
            point.x = pointer.pageX !== undefined ? pointer.pageX : pointer.clientX;
            point.y = pointer.pageY !== undefined ? pointer.pageY : pointer.clientY;
        }

        /**
         * drag start
         * @param {Event} event
         * @param {Event or Touch} pointer
         */
        Draggabilly.prototype.dragStart = function( event, pointer ) {
            if ( !this.isEnabled ) {
                return;
            }

            if ( event.preventDefault ) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }

            var isTouch = event.type === 'touchstart';

            // save pointer identifier to match up touch events
            this.pointerIdentifier = pointer.identifier;

            this._getPosition();

            this.measureContainment();

            // point where drag began
            setPointerPoint( this.startPoint, pointer );
            // position _when_ drag began
            this.startPosition.x = this.position.x;
            this.startPosition.y = this.position.y;

            // reset left/top style
            this.setLeftTop();

            this.dragPoint.x = 0;
            this.dragPoint.y = 0;

            // bind move and end events
            this._bindEvents({
                events: isTouch ? [ 'touchmove', 'touchend', 'touchcancel' ] :
                    [ 'mousemove', 'mouseup' ],
                // IE8 needs to be bound to document
                node: event.preventDefault ? window : document
            });

            classie.add( this.element, 'is-dragging' );

            // reset isDragging flag
            this.isDragging = true;

            this.emitEvent( 'dragStart', [ this, event, pointer ] );

            // start animation
            this.animate();
        };

        Draggabilly.prototype._bindEvents = function( args ) {
            for ( var i=0, len = args.events.length; i < len; i++ ) {
                var event = args.events[i];
                eventie.bind( args.node, event, this );
            }
            // save these arguments
            this._boundEvents = args;
        };

        Draggabilly.prototype._unbindEvents = function() {
            var args = this._boundEvents;
            for ( var i=0, len = args.events.length; i < len; i++ ) {
                var event = args.events[i];
                eventie.unbind( args.node, event, this );
            }
            delete this._boundEvents;
        };

        Draggabilly.prototype.measureContainment = function() {
            var containment = this.options.containment;
            if ( !containment ) {
                return;
            }

            this.size = getSize( this.element );
            var elemRect = this.element.getBoundingClientRect();

            // use element if element
            var container = isElement( containment ) ? containment :
                // fallback to querySelector if string
                typeof containment === 'string' ? document.querySelector( containment ) :
                    // otherwise just `true`, use the parent
                    this.element.parentNode;

            this.containerSize = getSize( container );
            var containerRect = container.getBoundingClientRect();

            this.relativeStartPosition = {
                x: elemRect.left - containerRect.left,
                y: elemRect.top  - containerRect.top
            };
        };

// ----- move event ----- //

        Draggabilly.prototype.onmousemove = function( event ) {
            this.dragMove( event, event );
        };

        Draggabilly.prototype.ontouchmove = function( event ) {
            var touch = this.getTouch( event.changedTouches );
            if ( touch ) {
                this.dragMove( event, touch );
            }
        };

        /**
         * drag move
         * @param {Event} event
         * @param {Event or Touch} pointer
         */
        Draggabilly.prototype.dragMove = function( event, pointer ) {

            setPointerPoint( this.dragPoint, pointer );
            this.dragPoint.x -= this.startPoint.x;
            this.dragPoint.y -= this.startPoint.y;

            if ( this.options.containment ) {
                var relX = this.relativeStartPosition.x;
                var relY = this.relativeStartPosition.y;
                this.dragPoint.x = Math.max( this.dragPoint.x, -relX );
                this.dragPoint.y = Math.max( this.dragPoint.y, -relY );
                this.dragPoint.x = Math.min( this.dragPoint.x, this.containerSize.width - relX - this.size.width );
                this.dragPoint.y = Math.min( this.dragPoint.y, this.containerSize.height - relY - this.size.height );
            }

            this.position.x = this.startPosition.x + this.dragPoint.x;
            this.position.y = this.startPosition.y + this.dragPoint.y;

            this.emitEvent( 'dragMove', [ this, event, pointer ] );
        };


// ----- end event ----- //

        Draggabilly.prototype.onmouseup = function( event ) {
            this.dragEnd( event, event );
        };

        Draggabilly.prototype.ontouchend = function( event ) {
            var touch = this.getTouch( event.changedTouches );
            if ( touch ) {
                this.dragEnd( event, touch );
            }
        };

        /**
         * drag end
         * @param {Event} event
         * @param {Event or Touch} pointer
         */
        Draggabilly.prototype.dragEnd = function( event, pointer ) {
            this.isDragging = false;

            delete this.pointerIdentifier;

            // use top left position when complete
            if ( transformProperty ) {
                this.element.style[ transformProperty ] = '';
                this.setLeftTop();
            }

            // remove events
            this._unbindEvents();

            classie.remove( this.element, 'is-dragging' );

            this.emitEvent( 'dragEnd', [ this, event, pointer ] );

        };

// ----- cancel event ----- //

// coerce to end event
        Draggabilly.prototype.ontouchcancel = function( event ) {
            var touch = this.getTouch( event.changedTouches );
            this.dragEnd( event, touch );
        };

// -------------------------- animation -------------------------- //

        Draggabilly.prototype.animate = function() {
            // only render and animate if dragging
            if ( !this.isDragging ) {
                return;
            }

            this.positionDrag();

            var _this = this;
            requestAnimationFrame( function animateFrame() {
                _this.animate();
            });

        };

// transform translate function
        var translate = is3d ?
            function( x, y ) {
                return 'translate3d( ' + x + 'px, ' + y + 'px, 0)';
            } :
            function( x, y ) {
                return 'translate( ' + x + 'px, ' + y + 'px)';
            };

// left/top positioning
        Draggabilly.prototype.setLeftTop = function() {
            this.element.style.left = this.position.x + 'px';
            this.element.style.top  = this.position.y + 'px';
        };

        Draggabilly.prototype.positionDrag = transformProperty ?
            function() {
                // position with transform
                this.element.style[ transformProperty ] = translate( this.dragPoint.x, this.dragPoint.y );
            } : Draggabilly.prototype.setLeftTop;

        Draggabilly.prototype.enable = function() {
            this.isEnabled = true;
        };

        Draggabilly.prototype.disable = function() {
            this.isEnabled = false;
            if ( this.isDragging ) {
                this.dragEnd();
            }
        };

        return Draggabilly;

    } // end definition

// -------------------------- transport -------------------------- //

    if ( typeof define === 'function' && define.amd ) {
        // AMD
        define('draggabilly', [
            'classie',
            'EventEmitter',
            'eventie',
            'getStyleProperty',
            'getSize'
        ],
            draggabillyDefinition );
    } else {
        // browser global
        window.Draggabilly = draggabillyDefinition(
            window.classie,
            window.EventEmitter,
            window.eventie,
            window.getStyleProperty,
            window.getSize
        );
    }

})( window );
(function (define) {
'use strict';
define(
'video/00_i18n.js',
[],
function() {
    /**
     * i18n module.
     * @exports video/00_i18n.js
     * @return {object}
     */

    return {
        'Volume': gettext('Volume'),
        // Translators: Volume level equals 0%.
        'Muted': gettext('Muted'),
        // Translators: Volume level in range ]0,20]%
        'Very low': gettext('Very low'),
        // Translators: Volume level in range ]20,40]%
        'Low': gettext('Low'),
        // Translators: Volume level in range ]40,60]%
        'Average': gettext('Average'),
        // Translators: Volume level in range ]60,80]%
        'Loud': gettext('Loud'),
        // Translators: Volume level in range ]80,99]%
        'Very loud': gettext('Very loud'),
        // Translators: Volume level equals 100%.
        'Maximum': gettext('Maximum')
    };
});
}(RequireJS.define));

/**
 * @file The main module definition for Word Cloud XModule.
 *
 *  Defines a constructor function which operates on a DOM element. Either show the user text inputs so
 *  he can enter words, or render his selected words along with the word cloud representing the top words.
 *
 *  @module WordCloudMain
 *
 *  @exports WordCloudMain
 *
 *  @external d3, $, RequireJS
 */

(function (requirejs, require, define) {
define('WordCloudMain', [], function () {

    /**
     * @function WordCloudMain
     *
     * This function will process all the attributes from the DOM element passed, taking all of
     * the configuration attributes. It will either then attach a callback handler for the click
     * event on the button in the case when the user needs to enter words, or it will call the
     * appropriate mehtod to generate and render a word cloud from user's enetered words along with
     * all of the other words.
     *
     * @constructor
     *
     * @param {jQuery} el DOM element where the word cloud will be processed and created.
     */
    var WordCloudMain = function (el) {
        var _this = this;

        this.wordCloudEl = $(el).find('.word_cloud');

        // Get the URL to which we will post the users words.
        this.ajax_url = this.wordCloudEl.data('ajax-url');

        // Dimensions of the box where the word cloud will be drawn.
        this.width = 635;
        this.height = 635;

        // Hide WordCloud container before Ajax request done
        this.wordCloudEl.hide();

        // Retriveing response from the server as an AJAX request. Attach a callback that will
        // be fired on server's response.
        $.postWithPrefix(
            _this.ajax_url + '/' + 'get_state', null,
            function (response) {
                if (response.status !== 'success') {
                    console.log('ERROR: ' + response.error);

                    return;
                }

                _this.configJson = response;
            }
        )
        .done(function () {
            // Show WordCloud container after Ajax request done
            _this.wordCloudEl.show();

            if (_this.configJson && _this.configJson.submitted) {
                _this.showWordCloud(_this.configJson);

                return;
            }
        });

        $(el).find('input.save').on('click', function () {
            _this.submitAnswer();
        });
    }; // End-of: var WordCloudMain = function (el) {

    /**
     * @function submitAnswer
     *
     * Callback to be executed when the user eneter his words. It will send user entries to the
     * server, and upon receiving correct response, will call the function to generate the
     * word cloud.
     */
    WordCloudMain.prototype.submitAnswer = function () {
        var _this = this,
            data = {'student_words': []};

        // Populate the data to be sent to the server with user's words.
        this.wordCloudEl.find('input.input-cloud').each(function (index, value) {
            data.student_words.push($(value).val());
        });

        // Send the data to the server as an AJAX request. Attach a callback that will
        // be fired on server's response.
        $.postWithPrefix(
            _this.ajax_url + '/' + 'submit', $.param(data),
            function (response) {
                if (response.status !== 'success') {
                    console.log('ERROR: ' + response.error);

                    return;
                }

                _this.showWordCloud(response);
            }
        );

    }; // End-of: WordCloudMain.prototype.submitAnswer = function () {

    /**
     * @function showWordCloud
     *
     * @param {object} response The response from the server that contains the user's entered words
     * along with all of the top words.
     *
     * This function will set up everything for d3 and launch the draw method. Among other things,
     * iw will determine maximum word size.
     */
    WordCloudMain.prototype.showWordCloud = function (response) {
        var words,
            _this = this,
            maxSize, minSize, scaleFactor, maxFontSize, minFontSize;

        this.wordCloudEl.find('.input_cloud_section').hide();

        words = response.top_words;
        maxSize = 0;
        minSize = 10000;
        scaleFactor = 1;
        maxFontSize = 200;
        minFontSize = 15;

        // Find the word with the maximum percentage. I.e. the most popular word.
        $.each(words, function (index, word) {
            if (word.size > maxSize) {
                maxSize = word.size;
            }
            if (word.size < minSize) {
                minSize = word.size;
            }
        });

        // Find the longest word, and calculate the scale appropriately. This is
        // required so that even long words fit into the drawing area.
        //
        // This is a fix for: if the word is very long and/or big, it is discarded by
        // for unknown reason.
        $.each(words, function (index, word) {
            var tempScaleFactor = 1.0,
                size = ((word.size / maxSize) * maxFontSize);

            if (size * 0.7 * word.text.length > _this.width) {
                tempScaleFactor = ((_this.width / word.text.length) / 0.7) / size;
            }

            if (scaleFactor > tempScaleFactor) {
                scaleFactor = tempScaleFactor;
            }
        });

        // Update the maximum font size based on the longest word.
        maxFontSize *= scaleFactor;

        // Generate the word cloud.
        d3.layout.cloud().size([this.width, this.height])
            .words(words)
            .rotate(function () {
                return Math.floor((Math.random() * 2)) * 90;
            })
            .font('Impact')
            .fontSize(function (d) {
                var size = (d.size / maxSize) * maxFontSize;

                size = size >= minFontSize ? size : minFontSize;

                return size;
            })
            .on('end', function (words, bounds) {
                // Draw the word cloud.
                _this.drawWordCloud(response, words, bounds);
            })
            .start();
    }; // End-of: WordCloudMain.prototype.showWordCloud = function (response) {

    /**
     * @function drawWordCloud
     *
     * This function will be called when d3 has finished initing the state for our word cloud,
     * and it is ready to hand off the process to the drawing routine. Basically set up everything
     * necessary for the actual drwing of the words.
     *
     * @param {object} response The response from the server that contains the user's entered words
     * along with all of the top words.
     *
     * @param {array} words An array of objects. Each object must have two properties. One property
     * is 'text' (the actual word), and the other property is 'size' which represents the number that the
     * word was enetered by the students.
     *
     * @param {array} bounds An array of two objects. First object is the top-left coordinates of the bounding
     * box where all of the words fir, second object is the bottom-right coordinates of the bounding box. Each
     * coordinate object contains two properties: 'x', and 'y'.
     */
    WordCloudMain.prototype.drawWordCloud = function (response, words, bounds) {
            // Color words in different colors.
        var fill = d3.scale.category20(),

            // Will be populated by words the user enetered.
            studentWordsKeys = [],

            // Comma separated string of user enetered words.
            studentWordsStr,

            // By default we do not scale.
            scale = 1,

            // Caсhing of DOM element
            cloudSectionEl = this.wordCloudEl.find('.result_cloud_section'),

            // Needed for caсhing of d3 group elements
            groupEl;

        // If bounding rectangle is given, scale based on the bounding box of all the words.
        if (bounds) {
            scale = 0.5 * Math.min(
                this.width / Math.abs(bounds[1].x - this.width / 2),
                this.width / Math.abs(bounds[0].x - this.width / 2),
                this.height / Math.abs(bounds[1].y - this.height / 2),
                this.height / Math.abs(bounds[0].y - this.height / 2)
            );
        }

        $.each(response.student_words, function (word, stat) {
            var percent = (response.display_student_percents) ? ' ' + (Math.round(100 * (stat / response.total_count))) + '%' : '';

            studentWordsKeys.push('<strong>' + word + '</strong>' + percent);
        });
        studentWordsStr = '' + studentWordsKeys.join(', ');

        cloudSectionEl
            .addClass('active')
            .find('.your_words').html(studentWordsStr)
            .end()
            .find('.total_num_words').html(response.total_count);

        $(cloudSectionEl.attr('id') + ' .word_cloud').empty();

        // Actual drawing of word cloud.
        groupEl = d3.select('#' + cloudSectionEl.attr('id') + ' .word_cloud').append('svg')
                .attr('width', this.width)
                .attr('height', this.height)
                .append('g')
                .attr('transform', 'translate(' + (0.5 * this.width) + ',' + (0.5 * this.height) + ')')
                .selectAll('text')
                .data(words)
                .enter().append('g');

        groupEl
            .append('title')
            .text(function (d) {
                var res = '';

                $.each(response.top_words, function(index, value){
                    if (value.text === d.text) {
                        res = value.percent + '%';

                        return;
                    }
                });

                return res;
            });

        groupEl
            .append('text')
            .style('font-size', function (d) {
                return d.size + 'px';
            })
            .style('font-family', 'Impact')
            .style('fill', function (d, i) {
                return fill(i);
            })
            .attr('text-anchor', 'middle')
            .attr('transform', function (d) {
                return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')scale(' + scale + ')';
            })
            .text(function (d) {
                return d.text;
            });
    }; // End-of: WordCloudMain.prototype.drawWordCloud = function (words, bounds) {

    return WordCloudMain;

}); // End-of: define('WordCloudMain', [], function () {
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define) {

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('Sliders', [], function () {
    return Sliders;

    function Sliders(gstId, state) {
        var c1, paramName, allParamNames, sliderDiv;

        allParamNames = state.getAllParameterNames();

        for (c1 = 0; c1 < allParamNames.length; c1 += 1) {
            paramName = allParamNames[c1];

            sliderDiv = $('#' + gstId + '_slider_' + paramName);

            if (sliderDiv.length === 1) {
                createSlider(sliderDiv, paramName);
            } else if (sliderDiv.length > 1) {
                console.log('ERROR: Found more than one slider for the parameter "' + paramName + '".');
                console.log('sliderDiv.length = ', sliderDiv.length);
            } // else {
            //     console.log('MESSAGE: Did not find a slider for the parameter "' + paramName + '".');
            // }
        }

        function createSlider(sliderDiv, paramName) {
            var paramObj;

            paramObj = state.getParamObj(paramName);

            // Check that the retrieval went OK.
            if (paramObj === undefined) {
                console.log('ERROR: Could not get a paramObj for parameter "' + paramName + '".');

                return;
            }

            // Create a jQuery UI slider from the slider DIV. We will set
            // starting parameters, and will also attach a handler to update
            // the 'state' on the 'slide' event.
            sliderDiv.slider({
                'min': paramObj.min,
                'max': paramObj.max,
                'value': paramObj.value,
                'step': paramObj.step
            });

            // Tell the parameter object stored in state that we have a slider
            // that is attached to it. Next time when the parameter changes, it
            // will also update the value of this slider.
            paramObj.sliderDiv = sliderDiv;

            // Atach callbacks to update the slider's parameter.
            paramObj.sliderDiv.on('slide', sliderOnSlide);
            paramObj.sliderDiv.on('slidechange', sliderOnChange);

            return;

            // Update the 'state' - i.e. set the value of the parameter this
            // slider is attached to to a new value.
            //
            // This will cause the plot to be redrawn each time after the user
            // drags the slider handle and releases it.
            function sliderOnSlide(event, ui) {
                // Last parameter passed to setParameterValue() will be 'true'
                // so that the function knows we are a slider, and it can
                // change the our value back in the case when the new value is
                // invalid for some reason.
                if (state.setParameterValue(paramName, ui.value, sliderDiv, true, 'slide') === undefined) {
                    console.log('ERROR: Could not update the parameter named "' + paramName + '" with the value "' + ui.value + '".');
                }
            }

            function sliderOnChange(event, ui) {
                if (state.setParameterValue(paramName, ui.value, sliderDiv, true, 'change') === undefined) {
                    console.log('ERROR: Could not update the parameter named "' + paramName + '" with the value "' + ui.value + '".');
                }
            }
        }
    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('Inputs', [], function () {
    return Inputs;

    function Inputs(gstId, gstClass, state) {
        var c1, paramName, allParamNames;

        allParamNames = state.getAllParameterNames();

        for (c1 = 0; c1 < allParamNames.length; c1 += 1) {
            $('#' + gstId).find('.' + gstClass + '_input').each(function (index, value) {
                var inputDiv, paramName;

                paramName = allParamNames[c1];
                inputDiv = $(value);

                if (paramName === inputDiv.data('var')) {
                    createInput(inputDiv, paramName);
                }
            });
        }

        return;

        function createInput(inputDiv, paramName) {
            var paramObj;

            paramObj = state.getParamObj(paramName);

            // Check that the retrieval went OK.
            if (paramObj === undefined) {
                console.log('ERROR: Could not get a paramObj for parameter "' + paramName + '".');

                return;
            }

            // Bind a function to the 'change' event. Whenever the user changes
            // the value of this text input, and presses 'enter' (or clicks
            // somewhere else on the page), this event will be triggered, and
            // our callback will be called.
            inputDiv.bind('change', inputOnChange);

            inputDiv.val(paramObj.value);

            // Lets style the input element nicely. We will use the button()
            // widget for this since there is no native widget for the text
            // input.
            inputDiv.button().css({
                'font': 'inherit',
                'color': 'inherit',
                'text-align': 'left',
                'outline': 'none',
                'cursor': 'text',
                'height': '15px'
            });

            // Tell the parameter object from state that we are attaching a
            // text input to it. Next time the parameter will be updated with
            // a new value, tis input will also be updated.
            paramObj.inputDivs.push(inputDiv);

            return;

            // Update the 'state' - i.e. set the value of the parameter this
            // input is attached to to a new value.
            //
            // This will cause the plot to be redrawn each time after the user
            // changes the value in the input. Note that he has to either press
            // 'Enter', or click somewhere else on the page in order for the
            // 'change' event to be tiggered.
            function inputOnChange(event) {
                var inputDiv;

                inputDiv = $(this);
                state.setParameterValue(paramName, inputDiv.val(), inputDiv);
            }
        }
    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

(function (define) {

define(
'video/00_sjson.js',
[],
function() {
"use strict";

    var Sjson = function (data) {
        var sjson = {
                start: data.start.concat(),
                end: data.end.concat(),
                text: data.text.concat()
            },
            module = {};

        var getter = function (propertyName) {
            return function () {
                return sjson[propertyName];
            };
        };

        var getStartTimes = getter('start');
        var getEndTimes = getter('end');
        var getCaptions = getter('text');

        var size = function () {
            return sjson.text.length;
        };

        var search = function (time) {
            var start = getStartTimes(),
                end = getEndTimes(),
                max = size() - 1,
                min = 0,
                index;

            if (time < start[min]) {
                return -1;
            }
            while (min < max) {
                index = Math.ceil((max + min) / 2);

                if (time < start[index]) {
                    max = index - 1;
                }

                if (time >= start[index]) {
                    min = index;
                }
            }

            if( time > end[min]){
                return -1;
            }

            return min;
        };

        return {
            getCaptions: getCaptions,
            getStartTimes: getStartTimes,
            getEndTimes: getEndTimes,
            getSize: size,
            search: search
        };
    };

    return Sjson;
});
}(RequireJS.define));


(function (define) {
define(
'video/00_iterator.js',
[],
function() {
"use strict";
    /**
     * Provides convenient way to work with iterable data.
     * @exports video/00_iterator.js
     * @constructor
     * @param {array} list Array to be iterated.
     */
    var Iterator = function (list) {
            this.list = list;
            this.index = 0;
            this.size = this.list.length;
            this.lastIndex = this.list.length - 1;
        };

    Iterator.prototype = {

        /**
         * Checks validity of provided index for the iterator.
         * @access protected
         * @param {numebr} index
         * @return {boolean}
         */
        _isValid: function (index) {
            return _.isNumber(index) && index < this.size && index >= 0;
        },

        /**
         * Returns next element.
         * @param {number} [index] Updates current position.
         * @return {any}
         */
        next: function (index) {
            if (!(this._isValid(index))) {
                index = this.index;
            }

            this.index = (index >= this.lastIndex) ? 0: index + 1;

            return this.list[this.index];
        },

        /**
         * Returns previous element.
         * @param {number} [index] Updates current position.
         * @return {any}
         */
        prev: function (index) {
            if (!(this._isValid(index))) {
                index = this.index;
            }

            this.index = (index < 1) ? this.lastIndex: index - 1;

            return this.list[this.index];
        },

        /**
         * Returns last element in the list.
         * @return {any}
         */
        last: function () {
            return this.list[this.lastIndex];
        },

        /**
         * Returns first element in the list.
         * @return {any}
         */
        first: function () {
            return this.list[0];
        },

        /**
         * Returns `true` if current position is last for the iterator.
         * @return {boolean}
         */
        isEnd: function () {
            return this.index === this.lastIndex;
        }
    };

    return Iterator;
});
}(RequireJS.define));


// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('Graph', [], function () {

    return Graph;

    function Graph(gstId, config, state) {
        var plotDiv, dataSeries, functions, xaxis, yaxis, numPoints, xrange,
            asymptotes, movingLabels, xTicksNames, yTicksNames, graphBarWidth, graphBarAlign;

        // We need plot configuration settings. Without them we can't continue.
        if ($.isPlainObject(config.plot) === false) {
            return;
        }

        // We must have a graph container DIV element available in order to
        // proceed.
        plotDiv = $('#' + gstId + '_plot');
        if (plotDiv.length === 0) {
            console.log('ERROR: Could not find the plot DIV with ID "' + gstId + '_plot".');

            return;
        }

        if (plotDiv.width() === 0) {
            plotDiv.width(300);
        }

        // Sometimes, when height is not explicitly set via CSS (or by some
        // other means), it is 0 pixels by default. When Flot will try to plot
        // a graph in this DIV with 0 height, then it will raise an error. To
        // prevent this, we will set it to be equal to the width.
        if (plotDiv.height() === 0) {
            plotDiv.height(plotDiv.width());
        }

        plotDiv.css('position', 'relative');

        // Configure some settings for the graph.
        if (setGraphXRange() === false) {
            console.log('ERROR: Could not configure the xrange. Will not continue.');

            return;
        }

        if (setGraphAxes() === false) {
            console.log('ERROR: Could not process configuration for the axes.');

            return;
        }

        graphBarWidth = 1;
        graphBarAlign = null;

        getBarWidth();
        getBarAlign();

        // Get the user defined functions. If there aren't any, don't do
        // anything else.
        createFunctions();

        if (functions.length === 0) {
            console.log('ERROR: No functions were specified, or something went wrong.');

            return;
        }

        if (createMarkingsFunctions() === false) {
            return;
        }
        if (createMovingLabelFunctions() === false) {
            return;
        }

        // Create the initial graph and plot it for the user to see.
        if (generateData() === true) {
            updatePlot();
        }

        // Bind an event. Whenever some constant changes, the graph will be
        // redrawn
        state.bindUpdatePlotEvent(plotDiv, onUpdatePlot);

        return;

        function getBarWidth() {
            if (config.plot.hasOwnProperty('bar_width') === false) {
                return;
            }

            if (typeof config.plot.bar_width !== 'string') {
                console.log('ERROR: The parameter config.plot.bar_width must be a string.');

                return;
            }

            if (isFinite(graphBarWidth = parseFloat(config.plot.bar_width)) === false) {
                console.log('ERROR: The parameter config.plot.bar_width is not a valid floating number.');
                graphBarWidth = 1;

                return;
            }

            return;
        }

        function getBarAlign() {
            if (config.plot.hasOwnProperty('bar_align') === false) {
                return;
            }

            if (typeof config.plot.bar_align !== 'string') {
                console.log('ERROR: The parameter config.plot.bar_align must be a string.');

                return;
            }

            if (
                (config.plot.bar_align.toLowerCase() !== 'left') &&
                (config.plot.bar_align.toLowerCase() !== 'center')
            ) {
                console.log('ERROR: Property config.plot.bar_align can be one of "left", or "center".');

                return;
            }

            graphBarAlign = config.plot.bar_align.toLowerCase();

            return;
        }

        function createMovingLabelFunctions() {
            var c1, returnStatus;

            returnStatus = true;
            movingLabels = [];

            if (config.plot.hasOwnProperty('moving_label') !== true) {
                returnStatus = true;
            } else if ($.isPlainObject(config.plot.moving_label) === true) {
                if (processMovingLabel(config.plot.moving_label) === false) {
                    returnStatus = false;
                }
            } else if ($.isArray(config.plot.moving_label) === true) {
                for (c1 = 0; c1 < config.plot.moving_label.length; c1++) {
                    if (processMovingLabel(config.plot.moving_label[c1]) === false) {
                        returnStatus = false;
                    }
                }
            }

            return returnStatus;
        }

        function processMovingLabel(obj) {
            var labelText, funcString, disableAutoReturn, paramNames, func,
                fontWeight, fontColor;

            if (obj.hasOwnProperty('@text') === false) {
                console.log('ERROR: You did not define a "text" attribute for the moving_label.');

                return false;
            }
            if (typeof obj['@text'] !== 'string') {
                console.log('ERROR: "text" attribute is not a string.');

                return false;
            }
            labelText = obj['@text'];

            if (obj.hasOwnProperty('#text') === false) {
                console.log('ERROR: moving_label is missing function declaration.');

                return false;
            }
            if (typeof obj['#text'] !== 'string') {
                console.log('ERROR: Function declaration is not a string.');

                return false;
            }
            funcString = obj['#text'];

            fontColor = 'black';
            if (
                (obj.hasOwnProperty('@color') === true) &&
                (typeof obj['@color'] === 'string')
            ) {
                fontColor = obj['@color'];
            }

            fontWeight = 'normal';
            if (
                (obj.hasOwnProperty('@weight') === true) &&
                (typeof obj['@weight'] === 'string')
            ) {
                if (
                    (obj['@weight'].toLowerCase() === 'normal') ||
                    (obj['@weight'].toLowerCase() === 'bold')
                ) {
                    fontWeight = obj['@weight'];
                } else {
                    console.log('ERROR: Moving label can have a weight property of "normal" or "bold".');
                }
            }

            disableAutoReturn = obj['@disable_auto_return'];

            funcString = $('<div>').html(funcString).text();

            if (
                (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                            (disableAutoReturn.toLowerCase() !== 'true')
                    )
            ) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    console.log(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            paramNames = state.getAllParameterNames();
            paramNames.push(funcString);

            try {
                func = Function.apply(null, paramNames);
            } catch (err) {
                console.log(
                    'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                );
                console.log('Error message: "' + err.message + '"');

                if (state.showDebugInfo) {
                    $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from the string "' + funcString + '".' + '</div>');
                    $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                }

                paramNames.pop();

                return false;
            }

            paramNames.pop();

            movingLabels.push({
                'labelText': labelText,
                'func': func,
                'el': null,
                'fontColor': fontColor,
                'fontWeight': fontWeight
            });

            return true;
        }

        function createMarkingsFunctions() {
            var c1, paramNames, returnStatus;

            returnStatus = true;

            asymptotes = [];
            paramNames = state.getAllParameterNames();

            if ($.isPlainObject(config.plot.asymptote)) {
                if (processAsymptote(config.plot.asymptote) === false) {
                    returnStatus = false;
                }
            } else if ($.isArray(config.plot.asymptote)) {
                for (c1 = 0; c1 < config.plot.asymptote.length; c1 += 1) {
                    if (processAsymptote(config.plot.asymptote[c1]) === false) {
                        returnStatus = false;
                    }
                }
            }

            return returnStatus;

            // Read configuration options for asymptotes, and store them as
            // an array of objects. Each object will have 3 properties:
            //
            //    - color: the color of the asymptote line
            //    - type: 'x' (vertical), or 'y' (horizontal)
            //    - func: the function that will generate the value at which
            //            the asymptote will be plotted; i.e. x = func(), or
            //            y = func(); for now only horizontal and vertical
            //            asymptotes are supported
            //
            // Since each asymptote can have a variable function - function
            // that relies on some parameter specified in the config - we will
            // generate each asymptote just before we draw the graph. See:
            //
            //     function updatePlot()
            //     function generateMarkings()
            //
            // Asymptotes are really thin rectangles implemented via the Flot's
            // markings option.
            function processAsymptote(asyObj) {
                var newAsyObj, funcString, func;

                newAsyObj = {};

                if (typeof asyObj['@type'] === 'string') {
                    if (asyObj['@type'].toLowerCase() === 'x') {
                        newAsyObj.type = 'x';
                    } else if (asyObj['@type'].toLowerCase() === 'y') {
                        newAsyObj.type = 'y';
                    } else {
                        console.log('ERROR: Attribute "type" for asymptote can be "x" or "y".');

                        return false;
                    }
                } else {
                    console.log('ERROR: Attribute "type" for asymptote is not specified.');

                    return false;
                }

                if (typeof asyObj['#text'] === 'string') {
                    funcString = asyObj['#text'];
                } else {
                    console.log('ERROR: Function body for asymptote is not specified.');

                    return false;
                }

                newAsyObj.color = '#000';
                if (typeof asyObj['@color'] === 'string') {
                    newAsyObj.color = asyObj['@color'];
                }

                newAsyObj.label = false;
                if (
                    (asyObj.hasOwnProperty('@label') === true) &&
                    (typeof asyObj['@label'] === 'string')
                ) {
                    newAsyObj.label = asyObj['@label'];
                }

                funcString = $('<div>').html(funcString).text();

                disableAutoReturn = asyObj['@disable_auto_return'];
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    if (funcString.search(/return/i) === -1) {
                        funcString = 'return ' + funcString;
                    }
                } else {
                    if (funcString.search(/return/i) === -1) {
                        console.log(
                            'ERROR: You have specified a JavaScript ' +
                            'function without a "return" statemnt. Your ' +
                            'function will return "undefined" by default.'
                        );
                    }
                }

                paramNames.push(funcString);

                try {
                    func = Function.apply(null, paramNames);
                } catch (err) {
                    console.log('ERROR: Asymptote function body could not be converted to function object.');
                    console.log('Error message: "".' + err.message);

                    return false;
                }

                paramNames.pop();

                newAsyObj.func = func;
                asymptotes.push(newAsyObj);

                return true;
            }
        }

        function setGraphAxes() {
            xaxis = {
                'tickFormatter': null
            };

            if (typeof config.plot['xticks'] === 'string') {
                if (processTicks(config.plot['xticks'], xaxis, 'xunits') === false) {
                    console.log('ERROR: Could not process the ticks for x-axis.');

                    return false;
                }
            } else {
                // console.log('MESSAGE: "xticks" were not specified. Using defaults.');

                return false;
            }

            yaxis = {
                'tickFormatter': null
            };
            if (typeof config.plot['yticks'] === 'string') {
                if (processTicks(config.plot['yticks'], yaxis, 'yunits') === false) {
                    console.log('ERROR: Could not process the ticks for y-axis.');

                    return false;
                }
            } else {
                // console.log('MESSAGE: "yticks" were not specified. Using defaults.');

                return false;
            }

            xTicksNames = null;
            yTicksNames = null;

            if (checkForTicksNames('x') === false) {
                return false;
            }

            if (checkForTicksNames('y') === false) {
                return false;
            }

            return true;

            //
            // function checkForTicksNames(axisName)
            //
            // The parameter "axisName" can be either "x" or "y" (string). Depending on it, the function
            // will set "xTicksNames" or "yTicksNames" private variable.
            //
            // This function does not return anything. It sets the private variable "xTicksNames" ("yTicksNames")
            // to the object converted by JSON.parse from the XML parameter "plot.xticks_names" ("plot.yticks_names").
            // If the "plot.xticks_names" ("plot.yticks_names") is missing or it is not a valid JSON string, then
            // "xTicksNames" ("yTicksNames") will be set to "null".
            //
            // Depending on the "xTicksNames" ("yTicksNames") being "null" or an object, the plot will either draw
            // number ticks, or use the names specified by the opbject.
            //
            function checkForTicksNames(axisName) {
                var tmpObj;

                if ((axisName !== 'x') && (axisName !== 'y')) {
                    // This is not an error. This funcion should simply stop executing.

                    return true;
                }

                if (
                    (config.plot.hasOwnProperty(axisName + 'ticks_names') === true) ||
                    (typeof config.plot[axisName + 'ticks_names'] === 'string')
                ) {
                    try {
                        tmpObj = JSON.parse(config.plot[axisName + 'ticks_names']);
                    } catch (err) {
                        console.log(
                            'ERROR: plot.' + axisName + 'ticks_names is not a valid JSON string.',
                            'Error message: "' + err.message + '".'
                        );

                        return false;
                    }

                    if (axisName === 'x') {
                        xTicksNames = tmpObj;
                        xaxis.tickFormatter = xAxisTickFormatter;
                    }
                    // At this point, we are certain that axisName = 'y'.
                    else {
                        yTicksNames = tmpObj;
                        yaxis.tickFormatter = yAxisTickFormatter;
                    }
                }
            }

            function processTicks(ticksStr, ticksObj, unitsType) {
                var ticksBlobs, tempFloat, tempTicks, c1, c2;

                // The 'ticks' setting is a string containing 3 floating-point
                // numbers.
                ticksBlobs = ticksStr.split(',');

                if (ticksBlobs.length !== 3) {
                    console.log('ERROR: Did not get 3 blobs from ticksStr = "' + ticksStr + '".');

                    return false;
                }

                tempFloat = parseFloat(ticksBlobs[0]);
                if (isNaN(tempFloat) === false) {
                    ticksObj.min = tempFloat;
                } else {
                    console.log('ERROR: Invalid "min". ticksBlobs[0] = ', ticksBlobs[0]);

                    return false;
                }

                tempFloat = parseFloat(ticksBlobs[1]);
                if (isNaN(tempFloat) === false) {
                    ticksObj.tickSize = tempFloat;
                } else {
                    console.log('ERROR: Invalid "tickSize". ticksBlobs[1] = ', ticksBlobs[1]);

                    return false;
                }

                tempFloat = parseFloat(ticksBlobs[2]);
                if (isNaN(tempFloat) === false) {
                    ticksObj.max = tempFloat;
                } else {
                    console.log('ERROR: Invalid "max". ticksBlobs[2] = ', ticksBlobs[2]);

                    return false;
                }

                // Is the starting tick to the left of the ending tick (on the
                // x-axis)? If not, set default starting and ending tick.
                if (ticksObj.min >= ticksObj.max) {
                    console.log('ERROR: Ticks min >= max.');

                    return false;
                }

                // Make sure the range makes sense - i.e. that there are at
                // least 3 ticks. If not, set a tickSize which will produce
                // 11 ticks. tickSize is the spacing between the ticks.
                if (ticksObj.tickSize > ticksObj.max - ticksObj.min) {
                    console.log('ERROR: tickSize > max - min.');

                    return false;
                }

                //  units: change last tick to units
                if (typeof config.plot[unitsType] === 'string') {
                    tempTicks = [];

                    for (c1 = ticksObj.min; c1 <= ticksObj.max; c1 += ticksObj.tickSize) {
                        c2 = roundToPrec(c1, ticksObj.tickSize);
                        tempTicks.push([c2, c2]);
                    }

                    tempTicks.pop();
                    tempTicks.push([
                        roundToPrec(ticksObj.max, ticksObj.tickSize),
                        config.plot[unitsType]
                    ]);

                    ticksObj.tickSize = null;
                    ticksObj.ticks = tempTicks;
                }

                return true;

                function roundToPrec(num, prec) {
                    var c1, tn1, tn2, digitsBefore, digitsAfter;

                    tn1 = Math.abs(num);
                    tn2 = Math.abs(prec);

                    // Find out number of digits BEFORE the decimal point.
                    c1 = 0;
                    tn1 = Math.abs(num);
                    while (tn1 >= 1) {
                        c1 += 1;

                        tn1 /= 10;
                    }
                    digitsBefore = c1;

                    // Find out number of digits AFTER the decimal point.
                    c1 = 0;
                    tn1 = Math.abs(num);
                    while (Math.round(tn1) !== tn1) {
                        c1 += 1;

                        tn1 *= 10;
                    }
                    digitsAfter = c1;

                    // For precision, find out number of digits AFTER the
                    // decimal point.
                    c1 = 0;
                    while (Math.round(tn2) !== tn2) {
                        c1 += 1;

                        tn2 *= 10;
                    }

                    // If precision is more than 1 (no digits after decimal
                    // points).
                    if (c1 === 0) {
                        return num;
                    }

                    // If the precision contains digits after the decimal
                    // point, we apply special rules.
                    else {
                        tn1 = Math.abs(num);

                        // if (digitsAfter > c1) {
                            tn1 = tn1.toFixed(c1);
                        // } else {
                        //     tn1 = tn1.toPrecision(digitsBefore + digitsAfter);
                        // }
                    }

                    if (num < 0) {
                        return -tn1;
                    }

                    return tn1;
                }
            }
        }

        function setGraphXRange() {
            var xRangeStr, xRangeBlobs, tempNum, allParamNames, funcString,
                disableAutoReturn;

            xrange = {};

            if ($.isPlainObject(config.plot.xrange) === false) {
                console.log(
                    'ERROR: Expected config.plot.xrange to be an object. ' +
                    'It is not.'
                );
                console.log('config.plot.xrange = ', config.plot.xrange);

                return false;
            }

            if (config.plot.xrange.hasOwnProperty('min') === false) {
                console.log(
                    'ERROR: Expected config.plot.xrange.min to be ' +
                    'present. It is not.'
                );

                return false;
            }

            disableAutoReturn = false;
            if (typeof config.plot.xrange.min === 'string') {
                funcString = config.plot.xrange.min;
            } else if (
                ($.isPlainObject(config.plot.xrange.min) === true) &&
                (config.plot.xrange.min.hasOwnProperty('#text') === true) &&
                (typeof config.plot.xrange.min['#text'] === 'string')
            ) {
                funcString = config.plot.xrange.min['#text'];

                disableAutoReturn =
                    config.plot.xrange.min['@disable_auto_return'];
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    disableAutoReturn = false;
                } else {
                    disableAutoReturn = true;
                }
            } else {
                console.log(
                    'ERROR: Could not get a function definition for ' +
                    'xrange.min property.'
                );

                return false;
            }

            funcString = $('<div>').html(funcString).text();

            if (disableAutoReturn === false) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    console.log(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            allParamNames = state.getAllParameterNames();

            allParamNames.push(funcString);
            try {
                xrange.min = Function.apply(null, allParamNames);
            } catch (err) {
                console.log(
                    'ERROR: could not create a function from the string "' +
                    funcString + '" for xrange.min.'
                );
                console.log('Error message: "' + err.message + '"');

                if (state.showDebugInfo) {
                    $('#' + gstId).html(
                        '<div style="color: red;">' + 'ERROR IN ' +
                        'XML: Could not create a function from the string "' +
                        funcString + '" for xrange.min.' + '</div>'
                    );
                    $('#' + gstId).append(
                        '<div style="color: red;">' + 'Error ' +
                        'message: "' + err.message + '".' + '</div>'
                    );
                }

                return false;
            }
            allParamNames.pop();

            if (config.plot.xrange.hasOwnProperty('max') === false) {
                console.log(
                    'ERROR: Expected config.plot.xrange.max to be ' +
                    'present. It is not.'
                );

                return false;
            }

            disableAutoReturn = false;
            if (typeof config.plot.xrange.max === 'string') {
                funcString = config.plot.xrange.max;
            } else if (
                ($.isPlainObject(config.plot.xrange.max) === true) &&
                (config.plot.xrange.max.hasOwnProperty('#text') === true) &&
                (typeof config.plot.xrange.max['#text'] === 'string')
            ) {
                funcString = config.plot.xrange.max['#text'];

                disableAutoReturn =
                    config.plot.xrange.max['@disable_auto_return'];
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    disableAutoReturn = false;
                } else {
                    disableAutoReturn = true;
                }
            } else {
                console.log(
                    'ERROR: Could not get a function definition for ' +
                    'xrange.max property.'
                );

                return false;
            }

            funcString = $('<div>').html(funcString).text();

            if (disableAutoReturn === false) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    console.log(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            allParamNames.push(funcString);
            try {
                xrange.max = Function.apply(null, allParamNames);
            } catch (err) {
                console.log(
                    'ERROR: could not create a function from the string "' +
                    funcString + '" for xrange.max.'
                );
                console.log('Error message: "' + err.message + '"');

                if (state.showDebugInfo) {
                    $('#' + gstId).html(
                        '<div style="color: red;">' + 'ERROR IN ' +
                        'XML: Could not create a function from the string "' +
                        funcString + '" for xrange.max.' + '</div>'
                    );
                    $('#' + gstId).append(
                        '<div style="color: red;">' + 'Error message: "' +
                        err.message + '".' + '</div>'
                    );
                }

                return false;
            }
            allParamNames.pop();

            tempNum = parseInt(config.plot.num_points, 10);
            if (isFinite(tempNum) === false) {
                tempNum = plotDiv.width() / 5.0;
            }

            if (
                (tempNum < 2) &&
                (tempNum > 1000)
            ) {
                console.log(
                    'ERROR: Number of points is outside the allowed range ' +
                    '[2, 1000]'
                );
                console.log('config.plot.num_points = ' + tempNum);

                return false;
            }

            numPoints = tempNum;

            return true;
        }

        function createFunctions() {
            var c1;

            functions = [];

            if (typeof config.functions === 'undefined') {
                console.log('ERROR: config.functions is undefined.');

                return;
            }

            if (typeof config.functions["function"] === 'string') {

                // If just one function string is present.
                addFunction(config.functions["function"]);

            } else if ($.isPlainObject(config.functions["function"]) === true) {

                // If a function is present, but it also has properties
                // defined.
                callAddFunction(config.functions["function"]);

            } else if ($.isArray(config.functions["function"])) {

                // If more than one function is defined.
                for (c1 = 0; c1 < config.functions["function"].length; c1 += 1) {

                    // For each definition, we must check if it is a simple
                    // string definition, or a complex one with properties.
                    if (typeof config.functions["function"][c1] === 'string') {

                        // Simple string.
                        addFunction(config.functions["function"][c1]);

                    } else if ($.isPlainObject(config.functions["function"][c1])) {

                        // Properties are present.
                        callAddFunction(config.functions["function"][c1]);

                    }
                }
            } else {
                console.log('ERROR: config.functions.function is of an unsupported type.');

                return;
            }

            return;

            // This function will reduce code duplication. We have to call
            // the function addFunction() several times passing object
            // properties as parameters. Rather than writing them out every
            // time, we will have a single place where it is done.
            function callAddFunction(obj) {
                if (
                    (obj.hasOwnProperty('@output')) &&
                    (typeof obj['@output'] === 'string')
                ) {

                    // If this function is meant to be calculated for an
                    // element then skip it.
                    if ((obj['@output'].toLowerCase() === 'element') ||
                        (obj['@output'].toLowerCase() === 'none')) {
                        return;
                    }

                    // If this function is meant to be calculated for a
                    // dynamic element in a label then skip it.
                    else if (obj['@output'].toLowerCase() === 'plot_label') {
                        return;
                    }

                    // It is an error if '@output' is not 'element',
                    // 'plot_label', or 'graph'. However, if the '@output'
                    // attribute is omitted, we will not have reached this.
                    else if (obj['@output'].toLowerCase() !== 'graph') {
                        console.log(
                            'ERROR: Function "output" attribute can be ' +
                            'either "element", "plot_label", "none" or "graph".'
                        );

                        return;
                    }

                }

                // The user did not specify an "output" attribute, or it is
                // "graph".
                addFunction(
                    obj['#text'],
                    obj['@color'],
                    obj['@line'],
                    obj['@dot'],
                    obj['@label'],
                    obj['@point_size'],
                    obj['@fill_area'],
                    obj['@bar'],
                    obj['@disable_auto_return']
                );
            }

            function addFunction(funcString, color, line, dot, label,
                pointSize, fillArea, bar, disableAutoReturn) {

                var newFunctionObject, func, paramNames, c1, rgxp;

                // The main requirement is function string. Without it we can't
                // create a function, and the series cannot be calculated.
                if (typeof funcString !== 'string') {
                    return;
                }

                // Make sure that any HTML entities that were escaped will be
                // unescaped. This is done because if a string with escaped
                // HTML entities is passed to the Function() constructor, it
                // will break.
                funcString = $('<div>').html(funcString).text();

                // If the user did not specifically turn off this feature,
                // check if the function string contains a 'return', and
                // prepend a 'return ' to the string if one, or more, is not
                // found.
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    if (funcString.search(/return/i) === -1) {
                        funcString = 'return ' + funcString;
                    }
                } else {
                    if (funcString.search(/return/i) === -1) {
                        console.log(
                            'ERROR: You have specified a JavaScript ' +
                            'function without a "return" statemnt. Your ' +
                            'function will return "undefined" by default.'
                        );
                    }
                }

                // Some defaults. If no options are set for the graph, we will
                // make sure that at least a line is drawn for a function.
                newFunctionObject = {
                    'line': true,
                    'dot': false,
                    'bars': false
                };

                // Get all of the parameter names defined by the user in the
                // XML.
                paramNames = state.getAllParameterNames();

                // The 'x' is always one of the function parameters.
                paramNames.push('x');

                // Must make sure that the function body also gets passed to
                // the Function constructor.
                paramNames.push(funcString);

                // Create the function from the function string, and all of the
                // available parameters AND the 'x' variable as it's parameters.
                // For this we will use the built-in Function object
                // constructor.
                //
                // If something goes wrong during this step, most
                // likely the user supplied an invalid JavaScript function body
                // string. In this case we will not proceed.
                try {
                    func = Function.apply(null, paramNames);
                } catch (err) {
                    console.log(
                        'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                    );
                    console.log('Error message: "' + err.message + '"');

                    if (state.showDebugInfo) {
                        $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from the string "' + funcString + '".' + '</div>');
                        $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                    }

                    paramNames.pop();
                    paramNames.pop();

                    return;
                }

                // Return the array back to original state. Remember that it is
                // a pointer to original array which is stored in state object.
                paramNames.pop();
                paramNames.pop();

                newFunctionObject['func'] = func;

                if (typeof color === 'string') {
                    newFunctionObject['color'] = color;
                }

                if (typeof line === 'string') {
                    if (line.toLowerCase() === 'true') {
                        newFunctionObject['line'] = true;
                    } else if (line.toLowerCase() === 'false') {
                        newFunctionObject['line'] = false;
                    }
                }

                if (typeof dot === 'string') {
                    if (dot.toLowerCase() === 'true') {
                        newFunctionObject['dot'] = true;
                    } else if (dot.toLowerCase() === 'false') {
                        newFunctionObject['dot'] = false;
                    }
                }

                if (typeof pointSize === 'string') {
                    newFunctionObject['pointSize'] = pointSize;
                }

                if (typeof bar === 'string') {
                    if (bar.toLowerCase() === 'true') {
                        newFunctionObject['bars'] = true;
                    } else if (bar.toLowerCase() === 'false') {
                        newFunctionObject['bars'] = false;
                    }
                }

                if (newFunctionObject['bars'] === true) {
                    newFunctionObject['line'] = false;
                    newFunctionObject['dot'] = false;
                    // To do: See if need to do anything here.
                } else if (
                    (newFunctionObject['dot'] === false) &&
                    (newFunctionObject['line'] === false)
                ) {
                    newFunctionObject['line'] = true;
                }

                if (newFunctionObject['line'] === true) {
                    if (typeof fillArea === 'string') {
                        if (fillArea.toLowerCase() === 'true') {
                            newFunctionObject['fillArea'] = true;
                        } else if (fillArea.toLowerCase() === 'false') {
                            newFunctionObject['fillArea'] = false;
                        } else {
                            console.log('ERROR: The attribute fill_area should be either "true" or "false".');
                            console.log('fill_area = "' + fillArea + '".');

                            return;
                        }
                    }
                }

                if (typeof label === 'string') {

                    newFunctionObject.specialLabel = false;
                    newFunctionObject.pldeHash = [];

                    // Let's check the label against all of the plde objects.
                    // plde is an abbreviation for Plot Label Dynamic Elements.
                    for (c1 = 0; c1 < state.plde.length; c1 += 1) {
                        rgxp = new RegExp(state.plde[c1].elId, 'g');

                        // If we find a dynamic element in the label, we will
                        // hash the current plde object, and indicate that this
                        // is a special label.
                        if (rgxp.test(label) === true) {
                            newFunctionObject.specialLabel = true;
                            newFunctionObject.pldeHash.push(state.plde[c1]);
                        }
                    }

                    newFunctionObject.label = label;
                } else {
                    newFunctionObject.label = false;
                }

                functions.push(newFunctionObject);
            }
        }

        // The callback that will be called whenever a constant changes (gets
        // updated via a slider or a text input).
        function onUpdatePlot(event) {
            if (generateData() === true) {
                updatePlot();
            }
        }

        function generateData() {
            var c0, c1, c3, functionObj, seriesObj, dataPoints, paramValues, x, y,
                start, end, step, numNotUndefined;

            paramValues = state.getAllParameterValues();

            dataSeries = [];

            for (c0 = 0; c0 < functions.length; c0 += 1) {
                functionObj = functions[c0];

                try {
                    start = xrange.min.apply(window, paramValues);
                } catch (err) {
                    console.log('ERROR: Could not determine xrange start.');
                    console.log('Error message: "' + err.message + '".');

                    if (state.showDebugInfo) {
                        $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not determine xrange start from defined function.' + '</div>');
                        $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                    }

                    return false;
                }
                try {
                    end = xrange.max.apply(window, paramValues);
                } catch (err) {
                    console.log('ERROR: Could not determine xrange end.');
                    console.log('Error message: "' + err.message + '".');

                    if (state.showDebugInfo) {
                        $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not determine xrange end from defined function.' + '</div>');
                        $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                    }

                    return false;
                }

                seriesObj = {};
                dataPoints = [];

                // For counting number of points added. In the end we will
                // compare this number to 'numPoints' specified in the config
                // JSON.
                c1 = 0;

                step = (end - start) / (numPoints - 1);

                // Generate the data points.
                for (x = start; x <= end; x += step) {

                    // Push the 'x' variable to the end of the parameter array.
                    paramValues.push(x);

                    // We call the user defined function, passing all of the
                    // available parameter values. Inside this function they
                    // will be accessible by their names.
                    try {
                        y = functionObj.func.apply(window, paramValues);
                    } catch (err) {
                        console.log('ERROR: Could not generate data.');
                        console.log('Error message: "' + err.message + '".');

                        if (state.showDebugInfo) {
                            $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not generate data from defined function.' + '</div>');
                            $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                        }

                        return false;
                    }

                    // Return the paramValues array to how it was before we
                    // added 'x' variable to the end of it.
                    paramValues.pop();

                    // Add the generated point to the data points set.
                    dataPoints.push([x, y]);

                    c1 += 1;

                }

                // If the last point did not get included because of rounding
                // of floating-point number addition, then we will include it
                // manually.
                if (c1 != numPoints) {
                    x = end;
                    paramValues.push(x);
                    try {
                        y = functionObj.func.apply(window, paramValues);
                    } catch (err) {
                        console.log('ERROR: Could not generate data.');
                        console.log('Error message: "' + err.message + '".');

                        if (state.showDebugInfo) {
                            $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not generate data from function.' + '</div>');
                            $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                        }

                        return false;
                    }
                    paramValues.pop();
                    dataPoints.push([x, y]);
                }

                // Put the entire data points set into the series object.
                seriesObj.data = dataPoints;

                // See if user defined a specific color for this function.
                if (functionObj.hasOwnProperty('color') === true) {
                    seriesObj.color = functionObj.color;
                }

                // See if a user defined a label for this function.
                if (functionObj.label !== false) {
                    if (functionObj.specialLabel === true) {
                        (function (c1) {
                            var tempLabel;

                            tempLabel = functionObj.label;

                            while (c1 < functionObj.pldeHash.length) {
                                tempLabel = tempLabel.replace(
                                    functionObj.pldeHash[c1].elId,
                                    functionObj.pldeHash[c1].func.apply(
                                        window,
                                        state.getAllParameterValues()
                                    )
                                );

                                c1 += 1;
                            }

                            seriesObj.label = tempLabel;
                        }(0));
                    } else {
                        seriesObj.label = functionObj.label;
                    }
                }

                // Should the data points be connected by a line?
                seriesObj.lines = {
                    'show': functionObj.line
                };

                if (functionObj.hasOwnProperty('fillArea') === true) {
                    seriesObj.lines.fill = functionObj.fillArea;
                }

                // Should each data point be represented by a point on the
                // graph?
                seriesObj.points = {
                    'show': functionObj.dot
                };

                seriesObj.bars = {
                    'show': functionObj.bars,
                    'barWidth': graphBarWidth
                };

                if (graphBarAlign !== null) {
                    seriesObj.bars.align = graphBarAlign;
                }

                if (functionObj.hasOwnProperty('pointSize')) {
                    seriesObj.points.radius = functionObj.pointSize;
                }

                // Add the newly created series object to the series set which
                // will be plotted by Flot.
                dataSeries.push(seriesObj);
            }

            if (graphBarAlign === null) {
                for (c0 = 0; c0 < numPoints; c0 += 1) {
                    // Number of points that have a value other than 'undefined' (undefined).
                    numNotUndefined = 0;

                    for (c1 = 0; c1 < dataSeries.length; c1 += 1) {
                        if (dataSeries[c1].bars.show === false) {
                            continue;
                        }

                        if (isFinite(parseInt(dataSeries[c1].data[c0][1])) === true) {
                            numNotUndefined += 1;
                        }
                    }

                    c3 = 0;
                    for (c1 = 0; c1 < dataSeries.length; c1 += 1) {
                        if (dataSeries[c1].bars.show === false) {
                            continue;
                        }

                        dataSeries[c1].data[c0][0] -= graphBarWidth * (0.5 * numNotUndefined - c3);

                        if (isFinite(parseInt(dataSeries[c1].data[c0][1])) === true) {
                            c3 += 1;
                        }
                    }
                }
            }

            for (c0 = 0; c0 < asymptotes.length; c0 += 1) {

                // If the user defined a label for this asympote, then the
                // property 'label' will be a string (in the other case it is
                // a boolean value 'false'). We will create an empty data set,
                // and add to it a label. This solution is a bit _wrong_ , but
                // it will have to do for now. Flot JS does not provide a way
                // to add labels to markings, and we use markings to generate
                // asymptotes.
                if (asymptotes[c0].label !== false) {
                    dataSeries.push({
                        'data': [],
                        'label': asymptotes[c0].label,
                        'color': asymptotes[c0].color
                    });
                }

            }

            return true;
        } // End-of: function generateData

        function updatePlot() {
            var paramValues, plotObj;

            paramValues = state.getAllParameterValues();

            if (xaxis.tickFormatter !== null) {
                xaxis.ticks = null;
            }

            if (yaxis.tickFormatter !== null) {
                yaxis.ticks = null;
            }

            // Tell Flot to draw the graph to our specification.
            plotObj = $.plot(
                plotDiv,
                dataSeries,
                {
                    'xaxis': xaxis,
                    'yaxis': yaxis,
                    'legend': {

                        // To show the legend or not. Note, even if 'show' is
                        // 'true', the legend will only show if labels are
                        // provided for at least one of the series that are
                        // going to be plotted.
                        'show': true,

                        // A floating point number in the range [0, 1]. The
                        // smaller the number, the more transparent will the
                        // legend background become.
                        'backgroundOpacity': 0

                    },
                    'grid': {
                        'markings': generateMarkings()
                    }
                }
            );

            updateMovingLabels();

            // The first time that the graph gets added to the page, the legend
            // is created from scratch. When it appears, MathJax works some
            // magic, and all of the specially marked TeX gets rendered nicely.
            // The next time when we update the graph, no such thing happens.
            // We must ask MathJax to typeset the legend again (well, we will
            // ask it to look at our entire graph DIV), the next time it's
            // worker queue is available.
            MathJax.Hub.Queue([
                'Typeset',
                MathJax.Hub,
                plotDiv.attr('id')
            ]);

            return;

            function updateMovingLabels() {
                var c1, labelCoord, pointOffset;

                for (c1 = 0; c1 < movingLabels.length; c1 += 1) {
                    if (movingLabels[c1].el === null) {
                        movingLabels[c1].el = $(
                            '<div>' +
                                movingLabels[c1].labelText +
                            '</div>'
                        );
                        movingLabels[c1].el.css('position', 'absolute');
                        movingLabels[c1].el.css('color', movingLabels[c1].fontColor);
                        movingLabels[c1].el.css('font-weight', movingLabels[c1].fontWeight);
                        movingLabels[c1].el.appendTo(plotDiv);

                        movingLabels[c1].elWidth = movingLabels[c1].el.width();
                        movingLabels[c1].elHeight = movingLabels[c1].el.height();
                    } else {
                        movingLabels[c1].el.detach();
                        movingLabels[c1].el.appendTo(plotDiv);
                    }

                    labelCoord = movingLabels[c1].func.apply(window, paramValues);

                    pointOffset = plotObj.pointOffset({'x': labelCoord.x, 'y': labelCoord.y});

                    movingLabels[c1].el.css('left', pointOffset.left - 0.5 * movingLabels[c1].elWidth);
                    movingLabels[c1].el.css('top', pointOffset.top - 0.5 * movingLabels[c1].elHeight);
                }
            }

            // Generate markings to represent asymptotes defined by the user.
            // See the following function for more details:
            //
            //     function processAsymptote()
            //
            function generateMarkings() {
                var c1, asymptote, markings, val;

                markings = [];

                for (c1 = 0; c1 < asymptotes.length; c1 += 1) {
                    asymptote = asymptotes[c1];

                    try {
                        val = asymptote.func.apply(window, paramValues);
                    } catch (err) {
                        console.log('ERROR: Could not generate value from asymptote function.');
                        console.log('Error message: ', err.message);

                        continue;
                    }

                    if (asymptote.type === 'x') {
                        markings.push({
                            'color': asymptote.color,
                            'lineWidth': 2,
                            'xaxis': {
                                'from': val,
                                'to': val
                            }
                        });
                    } else {
                        markings.push({
                            'color': asymptote.color,
                            'lineWidth': 2,
                            'yaxis': {
                                'from': val,
                                'to': val
                            }
                        });

                    }
                }

                return markings;
            }
        }

        function xAxisTickFormatter(val, axis) {
            if (xTicksNames.hasOwnProperty(val.toFixed(axis.tickDecimals)) === true) {
                return xTicksNames[val.toFixed(axis.tickDecimals)];
            }

            return '';
        }

        function yAxisTickFormatter(val, axis) {
            if (yTicksNames.hasOwnProperty(val.toFixed(axis.tickDecimals)) === true) {
                return yTicksNames[val.toFixed(axis.tickDecimals)];
            }

            return '';
        }
    }


});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('ElOutput', [], function () {

    return ElOutput;

    function ElOutput(config, state) {

        if ($.isPlainObject(config.functions["function"])) {
            processFuncObj(config.functions["function"]);
        } else if ($.isArray(config.functions["function"])) {
            (function (c1) {
                while (c1 < config.functions["function"].length) {
                    if ($.isPlainObject(config.functions["function"][c1])) {
                        processFuncObj(config.functions["function"][c1]);
                    }

                    c1 += 1;
                }
            }(0));
        }

        return;

        function processFuncObj(obj) {
            var paramNames, funcString, func, el, disableAutoReturn, updateOnEvent;

            // We are only interested in functions that are meant for output to an
            // element.
            if (
                (typeof obj['@output'] !== 'string') ||
                ((obj['@output'].toLowerCase() !== 'element') && (obj['@output'].toLowerCase() !== 'none'))
            ) {
                return;
            }

            if (typeof obj['@el_id'] !== 'string') {
                console.log('ERROR: You specified "output" as "element", but did not spify "el_id".');

                return;
            }

            if (typeof obj['#text'] !== 'string') {
                console.log('ERROR: Function body is not defined.');

                return;
            }

            updateOnEvent = 'slide';
            if (
                (obj.hasOwnProperty('@update_on') === true) &&
                (typeof obj['@update_on'] === 'string') &&
                ((obj['@update_on'].toLowerCase() === 'slide') || (obj['@update_on'].toLowerCase() === 'change'))
            ) {
                updateOnEvent = obj['@update_on'].toLowerCase();
            }

            disableAutoReturn = obj['@disable_auto_return'];

            funcString = obj['#text'];

            if (
                (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
            ) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    console.log(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            // Make sure that all HTML entities are converted to their proper
            // ASCII text equivalents.
            funcString = $('<div>').html(funcString).text();

            paramNames = state.getAllParameterNames();
            paramNames.push(funcString);

            try {
                func = Function.apply(null, paramNames);
            } catch (err) {
                console.log(
                    'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                );
                console.log('Error message: "' + err.message + '".');

                if (state.showDebugInfo) {
                    $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from string "' + funcString + '".' + '</div>');
                    $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                }

                paramNames.pop();

                return;
            }

            paramNames.pop();

            if (obj['@output'].toLowerCase() !== 'none') {
                el = $('#' + obj['@el_id']);

                if (el.length !== 1) {
                    console.log(
                        'ERROR: DOM element with ID "' + obj['@el_id'] + '" ' +
                        'not found. Dynamic element not created.'
                    );

                    return;
                }

                el.html(func.apply(window, state.getAllParameterValues()));
            } else {
                el = null;
                func.apply(window, state.getAllParameterValues());
            }

            state.addDynamicEl(el, func, obj['@el_id'], updateOnEvent);
        }

    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

/**
 * @file Initialize module works with the JSON config, and sets up various
 * settings, parameters, variables. After all setup actions are performed, it
 * invokes the video player to play the specified video. This module must be
 * invoked first. It provides several functions which do not fit in with other
 * modules.
 *
 * @external VideoPlayer
 *
 * @module Initialize
 */

(function (requirejs, require, define) {

define(
'video/01_initialize.js',
['video/03_video_player.js', 'video/00_video_storage.js', 'video/00_i18n.js'],
function (VideoPlayer, VideoStorage, i18n) {
    /**
     * @function
     *
     * Initialize module exports this function.
     *
     * @param {object} state The object containg the state of the video player.
     *     All other modules, their parameters, public variables, etc. are
     *     available via this object.
     * @param {DOM element} element Container of the entire Video DOM element.
     */
    var Initialize = function (state, element) {
        _makeFunctionsPublic(state);

        state.initialize(element)
            .done(function () {
                // On iPhones and iPods native controls are used.
                if (/iP(hone|od)/i.test(state.isTouch[0])) {
                    _hideWaitPlaceholder(state);
                    state.el.trigger('initialize', arguments);

                    return false;
                }

                _initializeModules(state, i18n)
                    .done(function () {
                        // On iPad ready state occurs just after start playing.
                        // We hide controls before video starts playing.
                        if (/iPad|Android/i.test(state.isTouch[0])) {
                            state.el.on('play', _.once(function() {
                                state.trigger('videoControl.show', null);
                            }));
                        } else {
                        // On PC show controls immediately.
                            state.trigger('videoControl.show', null);
                        }

                        _hideWaitPlaceholder(state);
                        state.el.trigger('initialize', arguments);
                    });
            });
    },

    methodsDict = {
        bindTo: bindTo,
        fetchMetadata: fetchMetadata,
        getCurrentLanguage: getCurrentLanguage,
        getDuration: getDuration,
        getPlayerMode: getPlayerMode,
        getVideoMetadata: getVideoMetadata,
        initialize: initialize,
        isHtml5Mode: isHtml5Mode,
        isFlashMode: isFlashMode,
        isYoutubeType: isYoutubeType,
        parseSpeed: parseSpeed,
        parseYoutubeStreams: parseYoutubeStreams,
        saveState: saveState,
        setPlayerMode: setPlayerMode,
        setSpeed: setSpeed,
        speedToString: speedToString,
        trigger: trigger,
        youtubeId: youtubeId
    },

        _youtubeApiDeferred = null,
        _oldOnYouTubeIframeAPIReady;

    Initialize.prototype = methodsDict;

    return Initialize;

    // ***************************************************************
    // Private functions start here. Private functions start with underscore.
    // ***************************************************************

    /**
     * @function _makeFunctionsPublic
     *
     * Functions which will be accessible via 'state' object. When called,
     * these functions will get the 'state'
     * object as a context.
     *
     * @param {object} state The object containg the state (properties,
     *     methods, modules) of the Video player.
     */
    function _makeFunctionsPublic(state) {
        bindTo(methodsDict, state, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _renderElements(state) {
        // Launch embedding of actual video content, or set it up so that it
        // will be done as soon as the appropriate video player (YouTube or
        // stand-alone HTML5) is loaded, and can handle embedding.
        //
        // Note that the loading of stand alone HTML5 player API is handled by
        // Require JS. At the time when we reach this code, the stand alone
        // HTML5 player is already loaded, so no further testing in that case
        // is required.
        var video, onYTApiReady, setupOnYouTubeIframeAPIReady;

        if (state.videoType === 'youtube') {
            state.youtubeApiAvailable = false;

            onYTApiReady = function () {
                console.log('[Video info]: YouTube API is available and is loaded.');

                video = VideoPlayer(state);

                state.modules.push(video);
                state.__dfd__.resolve();

                state.youtubeApiAvailable = true;
            };

            if (window.YT) {
                // If we have a Deferred object responsible for calling OnYouTubeIframeAPIReady
                // callbacks, make sure that they have all been called by trying to resolve the
                // Deferred object. Upon resolving, all the OnYouTubeIframeAPIReady will be
                // called. If the object has been already resolved, the callbacks will not
                // be called a second time.
                if (_youtubeApiDeferred) {
                    _youtubeApiDeferred.resolve();
                }

                window.YT.ready(function () {
                    onYTApiReady();
                });
            } else {
                // There is only one global variable window.onYouTubeIframeAPIReady which
                // is supposed to be a function that will be called by the YouTube API
                // when it finished initializing. This function will update this global function
                // so that it resolves our Deferred object, which will call all of the
                // OnYouTubeIframeAPIReady callbacks.
                //
                // If this global function is already defined, we store it first, and make
                // sure that it gets executed when our Deferred object is resolved.
                setupOnYouTubeIframeAPIReady = function () {
                    _oldOnYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || undefined;

                    window.onYouTubeIframeAPIReady = function () {
                        window.onYouTubeIframeAPIReady.resolve();
                    };

                    window.onYouTubeIframeAPIReady.resolve = _youtubeApiDeferred.resolve;
                    window.onYouTubeIframeAPIReady.done = _youtubeApiDeferred.done;

                    if (_oldOnYouTubeIframeAPIReady) {
                        window.onYouTubeIframeAPIReady.done(_oldOnYouTubeIframeAPIReady);
                    }
                };

                // If a Deferred object hasn't been created yet, create one now. It will
                // be responsible for calling OnYouTubeIframeAPIReady callbacks once the
                // YouTube API loads. After creating the Deferred object, load the YouTube
                // API.
                if (!_youtubeApiDeferred) {
                    _youtubeApiDeferred = $.Deferred();
                    setupOnYouTubeIframeAPIReady();
                    _loadYoutubeApi(state);
                } else if (!window.onYouTubeIframeAPIReady || !window.onYouTubeIframeAPIReady.done) {
                    // The Deferred object could have been already defined in a previous
                    // initialization of the video module. However, since then the global variable
                    // window.onYouTubeIframeAPIReady could have been overwritten. If so,
                    // we should set it up again.
                    setupOnYouTubeIframeAPIReady();
                }

                // Attach a callback to our Deferred object to be called once the
                // YouTube API loads.
                window.onYouTubeIframeAPIReady.done(function () {
                    window.YT.ready(function () {
                        onYTApiReady();
                    });
                });
            }
        } else {
            video = VideoPlayer(state);

            state.modules.push(video);
            state.__dfd__.resolve();
        }
    }

    function _loadYoutubeApi(state) {
        console.log('[Video info]: YouTube API is not loaded. Will try to load...');

        window.setTimeout(function () {
            // If YouTube API will load OK, it will run `onYouTubeIframeAPIReady`
            // callback, which will set `state.youtubeApiAvailable` to `true`.
            // If something goes wrong at this stage, `state.youtubeApiAvailable` is
            // `false`.
            _reportToServer(state, state.youtubeApiAvailable);
        }, state.config.ytTestTimeout);

        $.getScript(document.location.protocol + '//' + state.config.ytApiUrl);
    }

    function _reportToServer(state, youtubeIsAvailable) {
        if (!youtubeIsAvailable) {
            console.log('[Video info]: YouTube API is not available.');
        }

        state.saveState(true, { youtube_is_available: youtubeIsAvailable });
    }

    // function _configureCaptions(state)
    //     Configure displaying of captions.
    //
    //     Option
    //         this.config.showCaptions = true | false
    //
    //     Defines whether or not captions are shown on first viewing.
    //
    //     Option
    //          this.hide_captions = true | false
    //
    //     represents the user's choice of having the subtitles shown or
    //     hidden. This choice is stored in cookies.
    function _configureCaptions(state) {
        if (state.config.showCaptions) {
            state.hide_captions = ($.cookie('hide_captions') === 'true');
        } else {
            state.hide_captions = true;

            $.cookie('hide_captions', state.hide_captions, {
                expires: 3650,
                path: '/'
            });

            state.el.addClass('closed');
        }
    }

    // function _parseYouTubeIDs(state)
    //     The function parse YouTube stream ID's.
    //     @return
    //         false: We don't have YouTube video IDs to work with; most likely
    //             we have HTML5 video sources.
    //         true: Parsing of YouTube video IDs went OK, and we can proceed
    //             onwards to play YouTube videos.
    function _parseYouTubeIDs(state) {
        if (state.parseYoutubeStreams(state.config.streams)) {
            state.videoType = 'youtube';

            return true;
        }

        console.log(
            '[Video info]: Youtube Video IDs are incorrect or absent.'
        );

        return false;
    }

    // function _prepareHTML5Video(state)
    // The function prepare HTML5 video, parse HTML5
    // video sources etc.
    function _prepareHTML5Video(state) {
        state.speeds = ['0.75', '1.0', '1.25', '1.50'];
        // If none of the supported video formats can be played and there is no
        // short-hand video links, than hide the spinner and show error message.
        if (!state.config.sources.length) {
            _hideWaitPlaceholder(state);
            state.el
                .find('.video-player div')
                    .addClass('hidden')
                .end()
                .find('.video-player h3')
                    .removeClass('hidden');

            return false;
        }

        state.videoType = 'html5';

        if (!state.config.sub || !state.config.sub.length) {
            state.config.sub = '';
            state.config.showCaptions = false;
        }
        state.setSpeed(state.speed);

        return true;
    }

    function _hideWaitPlaceholder(state) {
        state.el
            .addClass('is-initialized')
            .find('.spinner')
            .attr({
                'aria-hidden': 'true',
                'tabindex': -1
            });
    }

    function _setConfigurations(state) {
        _configureCaptions(state);
        state.setPlayerMode(state.config.mode);
        // Possible value are: 'visible', 'hiding', and 'invisible'.
        state.controlState = 'visible';
        state.controlHideTimeout = null;
        state.captionState = 'invisible';
        state.captionHideTimeout = null;
    }

    function _initializeModules(state, i18n) {
        var dfd = $.Deferred(),
            modulesList = $.map(state.modules, function(module) {
                if ($.isFunction(module)) {
                    return module(state, i18n);
                } else if ($.isPlainObject(module)) {
                    return module;
                }
        });

        $.when.apply(null, modulesList)
            .done(dfd.resolve);

        return dfd.promise();
    }

    function _getConfiguration(data, storage) {
            var isBoolean = function (value) {
                    var regExp = /^true$/i;
                    return regExp.test(value.toString());
                },
                // List of keys that will be extracted form the configuration.
                extractKeys = [],
                // Compatibility keys used to change names of some parameters in
                // the final configuration.
                compatKeys = {
                    'start': 'startTime',
                    'end': 'endTime'
                },
                // Conversions used to pre-process some configuration data.
                conversions = {
                    'showCaptions': isBoolean,
                    'autoplay': isBoolean,
                    'autohideHtml5': isBoolean,
                    'savedVideoPosition': function (value) {
                        return storage.getItem('savedVideoPosition', true) ||
                            Number(value) ||
                            0;
                    },
                    'watchTimes': function (value) {
                        return storage.getItem('watchTimes', true) ||
                            Number(value) ||
                            0;
                    },
                    'speed': function (value) {
                        return storage.getItem('speed', true) || value;
                     },
                    'generalSpeed': function (value) {
                        return storage.getItem('general_speed') ||
                            value ||
                            '1.0';
                     },
                    'transcriptLanguage': function (value) {
                        return storage.getItem('language') ||
                            value ||
                            'en';
                     },
                    'ytTestTimeout': function (value) {
                        value = parseInt(value, 10);

                        if (!isFinite(value)) {
                            value = 1500;
                        }

                        return value;
                    },
                    'startTime': function (value) {
                        value = parseInt(value, 10);

                        if (!isFinite(value) || value < 0) {
                            return 0;
                        }

                        return value;
                    },
                    'endTime': function (value) {
                        value = parseInt(value, 10);

                        if (!isFinite(value) || value === 0) {
                            return null;
                        }

                        return value;
                     }
                },
                config = {};
            $.ajax({
                url: data.getStateUrl,
                type: 'POST',
                async: false,
                dataType: 'json',
                success: function(response){
                    var _data = {
                        savedVideoPosition: response["saved_video_position"],
                        watchTimes: response["watch_times"],
                        speed: response["speed"],
                        local_path: response["local_path"]
                    };
                    $.extend(data, _data);
                }
            });
            $.each(data, function(option, value) {
                // Extract option that is in `extractKeys`.
                if ($.inArray(option, extractKeys) !== -1) {
                    return;
                }

                // Change option name to key that is in `compatKeys`.
                if (compatKeys[option]) {
                    option = compatKeys[option];
                }

                // Pre-process data.
                if (conversions[option]) {
                    if ($.isFunction(conversions[option])) {
                        value = conversions[option].call(this, value);
                    } else {
                        throw new TypeError(option + ' is not a function.');
                    }
                }
                config[option] = value;
            });
            return config;
        }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************


    // function bindTo(methodsDict, obj, context, rewrite)
    // Creates a new function with specific context and assigns it to the provided
    // object.
    function bindTo(methodsDict, obj, context, rewrite) {
        $.each(methodsDict, function(name, method) {
            if (_.isFunction(method)) {

                if (_.isUndefined(rewrite)) {
                    rewrite = true;
                }

                if (_.isUndefined(obj[name]) || rewrite) {
                    obj[name] = _.bind(method, context);
                }
            }
        });
    }

    // function initialize(element)
    // The function set initial configuration and preparation.

    function initialize(element) {
        var self = this,
            el = $(element).find('.video'),
            container = el.find('.video-wrapper'),
            id = el.attr('id').replace(/video_/, ''),
            __dfd__ = $.Deferred(),
            isTouch = onTouchBasedDevice() || '',
            storage = VideoStorage('VideoState', id);

        if (isTouch) {
            el.addClass('is-touch');
        }

        $.extend(this, {
            __dfd__: __dfd__,
            el: el,
            container: container,
            id: id,
            isFullScreen: false,
            isTouch: isTouch,
            storage: storage
        });

        console.log(
            '[Video info]: Initializing video with id "' + id + '".'
        );

        // We store all settings passed to us by the server in one place. These
        // are "read only", so don't modify them. All variable content lives in
        // 'state' object.
        // jQuery .data() return object with keys in lower camelCase format.
        this.config = $.extend({}, _getConfiguration(el.data(), storage), {
            element: element,
            fadeOutTimeout:     1000,
            fadeOutDelay:   2000,
            captionsFreezeTime: 10000,
            mode: $.cookie('edX_video_player_mode'),
            // Available HD qualities will only be accessible once the video has
            // been played once, via player.getAvailableQualityLevels.
            availableHDQualities: [],
            isQualityControl: false     // 用于记录切换高清标清视频的状态
        });

        this.config.sourceLow = Base64.decode(this.config.sourceLow);
        this.config.sourceHigh = Base64.decode(this.config.sourceHigh);

        if (this.config.endTime < this.config.startTime) {
            this.config.endTime = null;
        }

        this.lang = this.config.transcriptLanguage;
        this.speed = this.speedToString(
            this.config.speed || this.config.generalSpeed
        );

        if (!(_parseYouTubeIDs(this))) {

            // If we do not have YouTube ID's, try parsing HTML5 video sources.
            if (!_prepareHTML5Video(this)) {

                __dfd__.reject();
                // Non-YouTube sources were not found either.
                return __dfd__.promise();
            }

            console.log('[Video info]: Start player in HTML5 mode.');

            _setConfigurations(this);
            _renderElements(this);
        } else {
            if (!this.youtubeXhr) {
                this.youtubeXhr = this.getVideoMetadata();
            }

            this.youtubeXhr
                .always(function (json, status) {
                    var err = $.isPlainObject(json.error) ||
                                (
                                    status !== 'success' &&
                                    status !== 'notmodified'
                                );
                    if (err) {
                        console.log(
                            '[Video info]: YouTube returned an error for ' +
                            'video with id "' + id + '".'
                        );

                        // When the youtube link doesn't work for any reason
                        // (for example, the great firewall in china) any
                        // alternate sources should automatically play.
                        if (!_prepareHTML5Video(self)) {
                            console.log(
                                '[Video info]: Continue loading ' +
                                'YouTube video.'
                            );

                            // Non-YouTube sources were not found either.

                            el.find('.video-player div')
                                .removeClass('hidden');
                            el.find('.video-player h3')
                                .addClass('hidden');

                            // If in reality the timeout was to short, try to
                            // continue loading the YouTube video anyways.
                            self.fetchMetadata();
                            self.parseSpeed();
                        } else {
                            console.log(
                                '[Video info]: Change player mode to HTML5.'
                            );

                            // In-browser HTML5 player does not support quality
                            // control.
                            el.find('a.quality_control').hide();
                        }
                    } else {
                        console.log(
                            '[Video info]: Start player in YouTube mode.'
                        );

                        self.fetchMetadata();
                        self.parseSpeed();
                    }

                    _setConfigurations(self);
                    _renderElements(self);
                });
        }

        return __dfd__.promise();
    }

    // function parseYoutubeStreams(state, youtubeStreams)
    //
    //     Take a string in the form:
    //         "iCawTYPtehk:0.75,KgpclqP-LBA:1.0,9-2670d5nvU:1.5"
    //     parse it, and make it available via the 'state' object. If we are
    //     not given a string, or it's length is zero, then we return false.
    //
    //     @return
    //         false: We don't have YouTube video IDs to work with; most likely
    //             we have HTML5 video sources.
    //         true: Parsing of YouTube video IDs went OK, and we can proceed
    //             onwards to play YouTube videos.
    function parseYoutubeStreams(youtubeStreams) {
        var _this;

        if (
            typeof youtubeStreams === 'undefined' ||
            youtubeStreams.length === 0
        ) {
            return false;
        }

        _this = this;
        this.videos = {};

        $.each(youtubeStreams.split(/,/), function (index, video) {
            var speed;

            video = video.split(/:/);
            speed = _this.speedToString(video[0]);

            _this.videos[speed] = video[1];
        });

        return _.isString(this.videos['1.0']);
    }

    // function fetchMetadata()
    //
    //     When dealing with YouTube videos, we must fetch meta data that has
    //     certain key facts not available while the video is loading. For
    //     example the length of the video can be determined from the meta
    //     data.
    function fetchMetadata() {
        var _this = this,
            metadataXHRs = [];

        this.metadata = {};

        $.each(this.videos, function (speed, url) {
            var xhr = _this.getVideoMetadata(url, function (data) {
                if (data.data) {
                    _this.metadata[data.data.id] = data.data;
                }
            });

            metadataXHRs.push(xhr);
        });

        $.when.apply(this, metadataXHRs).done(function () {
            _this.el.trigger('metadata_received');

            // Not only do we trigger the "metadata_received" event, we also
            // set a flag to notify that metadata has been received. This
            // allows for code that will miss the "metadata_received" event
            // to know that metadata has been received. This is important in
            // cases when some code will subscribe to the "metadata_received"
            // event after it has been triggered.
            _this.youtubeMetadataReceived = true;

        });
    }

    // function parseSpeed()
    //
    //     Create a separate array of available speeds.
    function parseSpeed() {
        this.speeds = ($.map(this.videos, function (url, speed) {
            return speed;
        })).sort();
    }

    function setSpeed(newSpeed, updateStorage) {
        // Possible speeds for each player type.
        // HTML5 =          [0.75, 1, 1.25, 1.5]
        // Youtube Flash =  [0.75, 1, 1.25, 1.5]
        // Youtube HTML5 =  [0.25, 0.5, 1, 1.5, 2]
        var map = {
                '0.25': '0.75', // Youtube HTML5 -> HTML5 or Youtube Flash
                '0.50': '0.75', // Youtube HTML5 -> HTML5 or Youtube Flash
                '0.75': '0.50', // HTML5 or Youtube Flash -> Youtube HTML5
                '1.25': '1.50', // HTML5 or Youtube Flash -> Youtube HTML5
                '2.0': '1.50'   // Youtube HTML5 -> HTML5 or Youtube Flash
            };

        if (_.contains(this.speeds, newSpeed)) {
            this.speed = newSpeed;
        } else {
            newSpeed = map[newSpeed];
            this.speed = _.contains(this.speeds, newSpeed) ? newSpeed : '1.0';
        }

        if (updateStorage) {
            this.storage.setItem('speed', this.speed, true);
            this.storage.setItem('general_speed', this.speed);
        }
    }

    function getVideoMetadata(url, callback) {
        var successHandler, xhr;

        if (typeof url !== 'string') {
            url = this.videos['1.0'] || '';
        }
        successHandler = ($.isFunction(callback)) ? callback : null;
        xhr = $.ajax({
            url: [
                document.location.protocol, '//', this.config.ytTestUrl, url,
                '?v=2&alt=jsonc'
            ].join(''),
            dataType: 'jsonp',
            timeout: this.config.ytTestTimeout,
            success: successHandler
        });

        return xhr;
    }

    function saveState(async, data) {

        if (!($.isPlainObject(data))) {
            data = {
                saved_video_position: this.videoPlayer.currentTime
            };
        }

        if (data.speed) {
            this.storage.setItem('speed', data.speed, true);
        }
        if (data.hasOwnProperty('watch_times')){
            this.storage.setItem('watchTimes', data.watchTimes, true);
        }

        if (data.hasOwnProperty('saved_video_position')) {
            this.storage.setItem('savedVideoPosition', data.saved_video_position, true);

            data.saved_video_position = Time.formatFull(data.saved_video_position);
        }

        $.ajax({
            url: this.config.saveStateUrl,
            type: 'POST',
            async: async ? true : false,
            dataType: 'json',
            data: data,
        });
    }

    function youtubeId(speed) {
        var currentSpeed = this.isFlashMode() ? this.speed : '1.0';

        return  this.videos[speed] ||
                this.videos[currentSpeed] ||
                this.videos['1.0'];
    }

    function getDuration() {
        try {
            return this.metadata[this.youtubeId()].duration;
        } catch (err) {
            return this.metadata[this.youtubeId('1.0')].duration;
        }
    }

    /**
     * Sets player mode.
     *
     * @param {string} mode Mode to set for the video player if it is supported.
     *                      Otherwise, `html5` is used by default.
     */
    function setPlayerMode(mode) {
        var supportedModes = ['html5', 'flash'];

        mode = _.contains(supportedModes, mode) ? mode : 'html5';
        this.currentPlayerMode = mode;
    }

    /**
     * Returns current player mode.
     *
     * @return {string} Returns string that describes player mode
     */
    function getPlayerMode() {
        return this.currentPlayerMode;
    }

    /**
     * Checks if current player mode is Flash.
     *
     * @return {boolean} Returns `true` if current mode is `flash`, otherwise
     *                   it returns `false`
     */
    function isFlashMode() {
        return this.getPlayerMode() === 'flash';
    }

    /**
     * Checks if current player mode is Html5.
     *
     * @return {boolean} Returns `true` if current mode is `html5`, otherwise
     *                   it returns `false`
     */
    function isHtml5Mode() {
        return this.getPlayerMode() === 'html5';
    }

    function isYoutubeType() {
        return this.videoType === 'youtube';
    }

    function speedToString(speed) {
        return parseFloat(speed).toFixed(2).replace(/\.00$/, '.0');
    }

    function getCurrentLanguage() {
        var keys = _.keys(this.config.transcriptLanguages);

        if (keys.length) {
            if (!_.contains(keys, this.lang)) {
                if (_.contains(keys, 'en')) {
                    this.lang = 'en';
                } else {
                    this.lang = keys.pop();
                }
            }
        } else {
            return null;
        }

        return this.lang;
    }

    /*
     * The trigger() function will assume that the @objChain is a complete
     * chain with a method (function) at the end. It will call this function.
     * So for example, when trigger() is called like so:
     *
     *     state.trigger('videoPlayer.pause', {'param1': 10});
     *
     * Then trigger() will execute:
     *
     *     state.videoPlayer.pause({'param1': 10});
     */
    function trigger(objChain) {
        var extraParameters = Array.prototype.slice.call(arguments, 1),
            i, tmpObj, chain;

        // Remember that 'this' is the 'state' object.
        tmpObj = this;
        chain = objChain.split('.');

        // At the end of the loop the variable 'tmpObj' will either be the
        // correct object/function to trigger/invoke. If the 'chain' chain of
        // object is incorrect (one of the link is non-existent), then the loop
        // will immediately exit.
        while (chain.length) {
            i = chain.shift();

            if (tmpObj.hasOwnProperty(i)) {
                tmpObj = tmpObj[i];
            } else {
                // An incorrect object chain was specified.

                return false;
            }
        }

        tmpObj.apply(this, extraParameters);

        return true;
    }
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

/*
 * 025_focus_grabber.js
 *
 * Purpose: Provide a way to focus on autohidden Video controls.
 *
 *
 * Because in HTML player mode we have a feature of autohiding controls on
 * mouse inactivity, sometimes focus is lost from the currently selected
 * control. What's more, when all controls are autohidden, we can't get to any
 * of them because by default browser does not place hidden elements on the
 * focus chain.
 *
 * To get around this minor annoyance, this module will manage 2 placeholder
 * elements that will be invisible to the user's eye, but visible to the
 * browser. This will allow for a sneaky stealing of focus and placing it where
 * we need (on hidden controls).
 *
 * This code has been moved to a separate module because it provides a concrete
 * block of functionality that can be turned on (off).
 */

/*
 * "If you want to climb a mountain, begin at the top."
 *
 * ~ Zen saying
 */

(function (requirejs, require, define) {

// FocusGrabber module.
define(
'video/025_focus_grabber.js',
[],
function () {
    return function (state) {
        var dfd = $.Deferred();

        state.focusGrabber = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);

        dfd.resolve();
        return dfd.promise();
    };


    // Private functions.

    function _makeFunctionsPublic(state) {
        var methodsDict = {
            disableFocusGrabber: disableFocusGrabber,
            enableFocusGrabber: enableFocusGrabber,
            onFocus: onFocus
        };

        state.bindTo(methodsDict, state.focusGrabber, state);
    }

    function _renderElements(state) {
        state.focusGrabber.elFirst = state.el.find('.focus_grabber.first');
        state.focusGrabber.elLast = state.el.find('.focus_grabber.last');

        // From the start, the Focus Grabber must be disabled so that
        // tabbing (switching focus) does not land the user on one of the
        // placeholder elements (elFirst, elLast).
        state.focusGrabber.disableFocusGrabber();
    }

    function _bindHandlers(state) {
        state.focusGrabber.elFirst.on('focus', state.focusGrabber.onFocus);
        state.focusGrabber.elLast.on('focus', state.focusGrabber.onFocus);

        // When the video container element receives programmatic focus, then
        // on un-focus ('blur' event) we should trigger a 'mousemove' event so
        // as to reveal autohidden controls.
        state.el.on('blur', function () {
            state.el.trigger('mousemove');
        });
    }


    // Public functions.

    function enableFocusGrabber() {
        var tabIndex;

        // When the Focus Grabber is being enabled, there are two different
        // scenarios:
        //
        //     1.) Currently focused element was inside the video player.
        //     2.) Currently focused element was somewhere else on the page.
        //
        // In the first case we must make sure that the video player doesn't
        // loose focus, even though the controls are autohidden.
        if ($(document.activeElement).parents().hasClass('video')) {
            tabIndex = -1;
        } else {
            tabIndex = 0;
        }

        this.focusGrabber.elFirst.attr('tabindex', tabIndex);
        this.focusGrabber.elLast.attr('tabindex', tabIndex);

        // Don't loose focus. We are inside video player on some control, but
        // because we can't remain focused on a hidden element, we will shift
        // focus to the main video element.
        //
        // Once the main element will receive the un-focus ('blur') event, a
        // 'mousemove' event will be triggered, and the video controls will
        // receive focus once again.
        if (tabIndex === -1) {
            this.el.focus();

            this.focusGrabber.elFirst.attr('tabindex', 0);
            this.focusGrabber.elLast.attr('tabindex', 0);
        }
    }

    function disableFocusGrabber() {
        // Only programmatic focusing on these elements will be available.
        // We don't want the user to focus on them (for example with the 'Tab'
        // key).
        this.focusGrabber.elFirst.attr('tabindex', -1);
        this.focusGrabber.elLast.attr('tabindex', -1);
    }

    function onFocus(event, params) {
        // Once the Focus Grabber placeholder elements will gain focus, we will
        // trigger 'mousemove' event so that the autohidden controls will
        // become visible.
        this.el.trigger('mousemove');

        this.focusGrabber.disableFocusGrabber();
    }
});
}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('GLabelElOutput', [], function () {
    return GLabelElOutput;

    function GLabelElOutput(config, state) {
        if ($.isPlainObject(config.functions["function"])) {
            processFuncObj(config.functions["function"]);
        } else if ($.isArray(config.functions["function"])) {
            (function (c1) {
                while (c1 < config.functions["function"].length) {
                    if ($.isPlainObject(config.functions["function"][c1])) {
                        processFuncObj(config.functions["function"][c1]);
                    }

                    c1 += 1;
                }
            }(0));
        }

        return;

        function processFuncObj(obj) {
            var paramNames, funcString, func, disableAutoReturn;

            // We are only interested in functions that are meant for output to an
            // element.
            if (
                (typeof obj['@output'] !== 'string') ||
                (obj['@output'].toLowerCase() !== 'plot_label')
            ) {
                return;
            }

            if (typeof obj['@el_id'] !== 'string') {
                console.log('ERROR: You specified "output" as "plot_label", but did not spify "el_id".');

                return;
            }

            if (typeof obj['#text'] !== 'string') {
                console.log('ERROR: Function body is not defined.');

                return;
            }

            disableAutoReturn = obj['@disable_auto_return'];

            funcString = obj['#text'];

            if (
                (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
            ) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    console.log(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            // Make sure that all HTML entities are converted to their proper
            // ASCII text equivalents.
            funcString = $('<div>').html(funcString).text();

            paramNames = state.getAllParameterNames();
            paramNames.push(funcString);

            try {
                func = Function.apply(null, paramNames);
            } catch (err) {
                console.log(
                    'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                );
                console.log('Error message: "' + err.message + '".');

                if (state.showDebugInfo) {
                    $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from string "' + funcString + '".' + '</div>');
                    $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                }

                paramNames.pop();

                return;
            }

            paramNames.pop();

            state.plde.push({
                'elId': obj['@el_id'],
                'func': func
            });
        }

    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

/*
 * We will add a function that will be called for all GraphicalSliderTool
 * xmodule module instances. It must be available globally by design of
 * xmodule.
 */
window.GraphicalSliderTool = function (el) {
    // All the work will be performed by the GstMain module. We will get access
    // to it, and all it's dependencies, via Require JS. Currently Require JS
    // is namespaced and is available via a global object RequireJS.
    RequireJS.require(['GstMain'], function (GstMain) {
        // The GstMain module expects the DOM ID of a Graphical Slider Tool
        // element. Since we are given a <section> element which might in
        // theory contain multiple graphical_slider_tool <div> elements (each
        // with a unique DOM ID), we will iterate over all children, and for
        // each match, we will call GstMain module.
        $(el).children('.graphical_slider_tool').each(function (index, value) {
            JavascriptLoader.executeModuleScripts($(value), function(){
                GstMain($(value).attr('id'));
            });
        });
    });
};

/**
 * @file HTML5 video player module. Provides methods to control the in-browser
 * HTML5 video player.
 *
 * The goal was to write this module so that it closely resembles the YouTube
 * API. The main reason for this is because initially the edX video player
 * supported only YouTube videos. When HTML5 support was added, for greater
 * compatibility, and to reduce the amount of code that needed to be modified,
 * it was decided to write a similar API as the one provided by YouTube.
 *
 * @external RequireJS
 *
 * @module HTML5Video
 */

(function (requirejs, require, define) {

define(
'video/02_html5_video.js',
[],
function () {
    var HTML5Video = {};

    HTML5Video.Player = (function () {
        Player.prototype.callStateChangeCallback = function () {
            if ($.isFunction(this.config.events.onStateChange)) {
                this.config.events.onStateChange({
                    data: this.playerState
                });
            }
        };

        Player.prototype.pauseVideo = function () {
            this.video.pause();
        };

        Player.prototype.seekTo = function (value) {
            if (
                typeof value === 'number' &&
                value <= this.video.duration &&
                value >= 0
            ) {
                this.video.currentTime = value;
            }
        };

        Player.prototype.setVolume = function (value) {
            if (typeof value === 'number' && value <= 100 && value >= 0) {
                this.video.volume = value * 0.01;
            }
        };

        Player.prototype.getCurrentTime = function () {
            return this.video.currentTime;
        };

        Player.prototype.playVideo = function () {
            this.video.play();
        };

        Player.prototype.getPlayerState = function () {
            return this.playerState;
        };

        Player.prototype.getVolume = function () {
            return this.video.volume;
        };

        Player.prototype.getDuration = function () {
            if (isNaN(this.video.duration)) {
                return 0;
            }

            return this.video.duration;
        };

        Player.prototype.setPlaybackRate = function (value) {
            var newSpeed;

            newSpeed = parseFloat(value);

            if (isFinite(newSpeed)) {
                if (this.video.playbackRate !== value) {
                    this.video.playbackRate = value;
                }
            }
        };

        Player.prototype.getAvailablePlaybackRates = function () {
            return [0.75, 1.0, 1.25, 1.5];
        };

        Player.prototype._getLogs = function () {
            return this.logs;
        };

        Player.prototype.showErrorMessage = function () {
            this.el
                .find('.video-player div')
                    .addClass('hidden')
                .end()
                .find('.video-player h3')
                    .removeClass('hidden')
                .end()
                    .addClass('is-initialized')
                .find('.spinner')
                    .attr({
                        'aria-hidden': 'true',
                        'tabindex': -1
                    });
        };

        return Player;

        /*
         * Constructor function for HTML5 Video player.
         *
         * @param {String|Object} el A DOM element where the HTML5 player will
         * be inserted (as returned by jQuery(selector) function), or a
         * selector string which will be used to select an element. This is a
         * required parameter.
         *
         * @param config - An object whose properties will be used as
         * configuration options for the HTML5 video player. This is an
         * optional parameter. In the case if this parameter is missing, or
         * some of the config object's properties are missing, defaults will be
         * used. The available options (and their defaults) are as
         * follows:
         *
         *     config = {
         *
         *        videoSources: [],   // An array with properties being video
         *                            // sources. The property name is the
         *                            // video format of the source. Supported
         *                            // video formats are: 'mp4', 'webm', and
         *                            // 'ogg'.
         *
         *          events: {         // Object's properties identify the
         *                            // events that the API fires, and the
         *                            // functions (event listeners) that the
         *                            // API will call when those events occur.
         *                            // If value is null, or property is not
         *                            // specified, then no callback will be
         *                            // called for that event.
         *
         *              onReady: null,
         *              onStateChange: null
         *          }
         *     }
         */
        function Player(el, config) {
            var isTouch = onTouchBasedDevice() || '',
                sourceList, _this, errorMessage, lastSource;

            this.logs = [];
            // Initially we assume that el is a DOM element. If jQuery selector
            // fails to select something, we assume that el is an ID of a DOM
            // element. We try to select by ID. If jQuery fails this time, we
            // return. Nothing breaks because the player 'onReady' event will
            // never be fired.

            this.el = $(el);
            if (this.el.length === 0) {
                this.el = $('#' + el);

                if (this.el.length === 0) {
                    errorMessage = gettext('VideoPlayer: Element corresponding to the given selector was not found.');
                    if (window.console && console.log) {
                        console.log(errorMessage);
                    } else {
                        throw new Error(errorMessage);
                    }
                    return;
                }
            }

            // A simple test to see that the 'config' is a normal object.
            if ($.isPlainObject(config)) {
                this.config = config;
            } else {
                return;
            }

            // We should have at least one video source. Otherwise there is no
            // point to continue.
            if (!config.videoSources && !config.videoSources.length) {
                return;
            }


            // Will be used in inner functions to point to the current object.
            _this = this;

            // Create HTML markup for individual sources of the HTML5 <video>
            // element.
            sourceList = $.map(config.videoSources, function (source) {
               return [
                    '<source ',
                        'src="', Base64.decode(source),
            // Following hack allows to open the same video twice
            // https://code.google.com/p/chromium/issues/detail?id=31014
            // Check whether the url already has a '?' inside, and if so,
            // use '&' instead of '?' to prevent breaking the url's integrity.
            //            (source.indexOf('?') === -1 ? '?' : '&'),
            //            (new Date()).getTime(),
                   '" />'
                ].join('');
            });


            // Create HTML markup for the <video> element, populating it with
            // sources from previous step. Because of problems with creating
            // video element via jquery (http://bugs.jquery.com/ticket/9174) we
            // create it using native JS.
            this.video = document.createElement('video');

            errorMessage = [
                gettext('This browser cannot play .mp4, .ogg, or .webm files.'),
                gettext('Try using a different browser, such as Google Chrome.')
            ].join('');
            this.video.innerHTML = sourceList.join('') + errorMessage;

            // Get the jQuery object, and set the player state to UNSTARTED.
            // The player state is used by other parts of the VideoPlayer to
            // determine what the video is currently doing.
            this.videoEl = $(this.video);
            this.videoEl.attr('oncontextmenu', 'return false;');  // 禁止在视频上使用鼠标右键
            var video_ = this.videoEl;
            var config_ = config;
            if(config.loadLocalSource == 1){
                try{
                    var file_name = Base64.decode(config_.videoSources[0]).split('/')[Base64.decode(config_.videoSources[0]).split('/').length-1];
                    var path = config_.newSource.split('://')[1].substring(config_.newSource.split('://')[1].indexOf('/')+1);
                    var xhr = $.ajax({
                        url:config.vilidateService + '?filepath=' + path + file_name,
                        dataType:'jsonp',
                        data:'',
                        jsonp:'callback',
                        timeout:1000,
                        success:function(result) {
                            if(result.status == 200){
                                console.log('vilidate success and file was found');
                                new_source = config_.newSource + file_name;
                                video_.attr('src', new_source);
                            }else{
                                console.log('file was not found');
                            }
                        },
                        error:function(result){
                            xhr.abort();
                            console.log('---vilidate failed---');
                        }
                    });
                }catch (e){
                    console.log(e.message);
                }

            }else{
                if(config_.local_path){
                    try{
                        var file_name = Base64.decode(config_.videoSources[0]).split('/')[Base64.decode(config_.videoSources[0]).split('/').length-1];
                        var path = config_.local_path.split('://')[1].substring(config_.local_path.split('://')[1].indexOf('/')+1);
                        var vilidate_path = 'http://'+config_.local_path.split('://')[1].split('/')[0] + ':9000/Service/verify';
                        console.log(vilidate_path);

                        var xhr = $.ajax({
                            url: vilidate_path + '?filepath=' + path + file_name,
                            dataType:'jsonp',
                            data:'',
                            jsonp:'callback',
                            timeout:1000,
                            success:function(result) {
                                if(result.status == 200){
                                    console.log('vilidate success and file was found');
                                    new_source = config_.local_path + file_name;
                                    video_.attr('src', new_source);
                                }else{
                                    console.log('file was not found');
                                }
                            },
                            error:function(result){
                                xhr.abort();
                                console.log('---vilidate failed---');
                            }
                        });
                    }catch (e){
                        console.log(e.message);
                    }
                }else{
                    this.videoEl.attr('src', Base64.decode(config.videoSources[0]));
                }
            }

            if( $('#html5_poster_picture') != undefined ){
                var poster_pic_val = $('#html5_poster_picture').val();
                if(poster_pic_val != undefined && poster_pic_val.length > 0){
                    this.videoEl.attr('poster', poster_pic_val);
                }
            }

            lastSource = this.videoEl.find('source').last();
            lastSource.on('error', this.showErrorMessage.bind(this));

            if (/iP(hone|od)/i.test(isTouch[0])) {
                this.videoEl.prop('controls', true);
            }

            this.playerState = HTML5Video.PlayerState.UNSTARTED;

            // Attach a 'click' event on the <video> element. It will cause the
            // video to pause/play.
            this.videoEl.on('click', function (event) {
                var PlayerState = HTML5Video.PlayerState;

                if (_this.playerState === PlayerState.PLAYING) {
                    _this.pauseVideo();
                    _this.playerState = PlayerState.PAUSED;
                    _this.callStateChangeCallback();
                } else {
                    _this.playVideo();
                    _this.playerState = PlayerState.PLAYING;
                    _this.callStateChangeCallback();
                }
            });

            var events = ['loadstart', 'progress', 'suspend', 'abort', 'error',
                'emptied', 'stalled', 'play', 'pause', 'loadedmetadata',
                'loadeddata', 'waiting', 'playing', 'canplay', 'canplaythrough',
                'seeking', 'seeked', 'timeupdate', 'ended', 'ratechange',
                'durationchange', 'volumechange'
            ];

            this.debug = false;
            $.each(events, function(index, eventName) {
                _this.video.addEventListener(eventName, function () {
                    _this.logs.push({
                        'event name': eventName,
                        'state': _this.playerState
                    });

                    if (_this.debug) {
                        console.log(
                            'event name:', eventName,
                            'state:', _this.playerState,
                            'readyState:', _this.video.readyState,
                            'networkState:', _this.video.networkState
                        );
                    }

                    el.trigger('html5:' + eventName, arguments);
                });
            });

            // When the <video> tag has been processed by the browser, and it
            // is ready for playback, notify other parts of the VideoPlayer,
            // and initially pause the video.
            this.video.addEventListener('loadedmetadata', function () {
                _this.playerState = HTML5Video.PlayerState.PAUSED;
                if ($.isFunction(_this.config.events.onReady)) {
                    _this.config.events.onReady(null);
                }
            }, false);

            // Register the 'play' event.
            this.video.addEventListener('play', function () {
                _this.playerState = HTML5Video.PlayerState.BUFFERING;
                _this.callStateChangeCallback();
            }, false);

            this.video.addEventListener('playing', function () {
                _this.playerState = HTML5Video.PlayerState.PLAYING;
                _this.callStateChangeCallback();
            }, false);

            // Register the 'pause' event.
            this.video.addEventListener('pause', function () {
                _this.playerState = HTML5Video.PlayerState.PAUSED;
                _this.callStateChangeCallback();
            }, false);

            // Register the 'ended' event.
            this.video.addEventListener('ended', function () {
                _this.playerState = HTML5Video.PlayerState.ENDED;
                _this.callStateChangeCallback();
            }, false);

            // Place the <video> element on the page.
            this.videoEl.appendTo(this.el.find('.video-player div'));

            //console.log("加载视频结束, 当前视频播放时间为"+this.videoPlayer.currentTime);
        }
    }());

    // The YouTube API presents several constants which describe the player's
    // state at a given moment. HTML5Video API will copy these constants so
    // that code which uses both the YouTube API and this API doesn't have to
    // change.
    HTML5Video.PlayerState = {
        UNSTARTED: -1,
        ENDED: 0,
        PLAYING: 1,
        PAUSED: 2,
        BUFFERING: 3,
        CUED: 5
    };

    // HTML5Video object - what this module exports.
    return HTML5Video;
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (requirejs, require, define) {

// VideoPlayer module.
define(
'video/03_video_player.js',
['video/02_html5_video.js', 'video/00_resizer.js'],
function (HTML5Video, Resizer) {
    var dfd = $.Deferred(),
        VideoPlayer = function (state) {
            state.videoPlayer = {};
            _makeFunctionsPublic(state);
            _initialize(state);
            // No callbacks to DOM events (click, mousemove, etc.).

            return dfd.promise();
        },
        methodsDict = {
            duration: duration,
            //handlePlaybackQualityChange: handlePlaybackQualityChange,

            // Added for finer graded seeking control.
            // Please see:
            //     https://developers.google.com/youtube/js_api_reference#Events
            isBuffering: isBuffering,
            // https://developers.google.com/youtube/js_api_reference#cueVideoById
            isCued: isCued,

            isEnded: isEnded,
            isPlaying: isPlaying,
            isPaused: isPaused,
            isUnstarted: isUnstarted,
            log: log,
            onCaptionSeek: onSeek,
            onEnded: onEnded,
            onPause: onPause,
            onPlay: onPlay,
            runTimer: runTimer,
            stopTimer: stopTimer,
            onPlaybackQualityChange: onPlaybackQualityChange,
            onReady: onReady,
            onSlideSeek: onSeek,
            onSpeedChange: onSpeedChange,
            onStateChange: onStateChange,
            onUnstarted: onUnstarted,
            onVolumeChange: onVolumeChange,
            pause: pause,
            play: play,
            seekTo: seekTo,
            moveForward: moveForward,
            moveBack: moveBack,
            suspended: suspended,
            recover: recover,
            setPlaybackRate: setPlaybackRate,
            update: update,
            figureOutStartEndTime: figureOutStartEndTime,
            figureOutStartingTime: figureOutStartingTime,
            updatePlayTime: updatePlayTime
        };

    VideoPlayer.prototype = methodsDict;

    // VideoPlayer() function - what this module "exports".
    return VideoPlayer;

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called,
    //     these functions will get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        var debouncedF = _.debounce(
            function (params) {
                return onSeek.call(this, params);
            }.bind(state),
            300
        );

        state.bindTo(methodsDict, state.videoPlayer, state);

        state.videoPlayer.onSlideSeek = debouncedF;
        state.videoPlayer.onCaptionSeek = debouncedF;
    }

    // function _initialize(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _initialize(state) {
        var youTubeId, player;

        // The function is called just once to apply pre-defined configurations
        // by student before video starts playing. Waits until the video's
        // metadata is loaded, which normally happens just after the video
        // starts playing. Just after that configurations can be applied.
        state.videoPlayer.ready = _.once(function () {
            $(window).on('unload', state.saveState);
            $(window).on('layerPop', state.videoPlayer.recover);
            $(window).on('layerPush', state.videoPlayer.suspended);

            if (!state.isFlashMode() && state.speed != '1.0') {
                state.videoPlayer.setPlaybackRate(state.speed);
            }
        });

        if (state.isYoutubeType()) {
            state.videoPlayer.PlayerState = YT.PlayerState;
            state.videoPlayer.PlayerState.UNSTARTED = -1;
        } else {
            state.videoPlayer.PlayerState = HTML5Video.PlayerState;
        }

        state.videoPlayer.currentTime = 0;

        state.videoPlayer.goToStartTime = true;
        state.videoPlayer.stopAtEndTime = true;
        state.videoPlayer.isSuspended = false;

        state.videoPlayer.playerVars = {
            controls: 0,
            wmode: 'transparent',
            rel: 0,
            showinfo: 0,
            enablejsapi: 1,
            modestbranding: 1
        };

        if (!state.isFlashMode()) {
            state.videoPlayer.playerVars.html5 = 1;
        }

        // There is a bug which prevents YouTube API to correctly set the speed
        // to 1.0 from another speed in Firefox when in HTML5 mode. There is a
        // fix which basically reloads the video at speed 1.0 when this change
        // is requested (instead of simply requesting a speed change to 1.0).
        // This has to be done only when the video is being watched in Firefox.
        // We need to figure out what browser is currently executing this code.
        //
        // TODO: Check the status of
        // http://code.google.com/p/gdata-issues/issues/detail?id=4654
        // When the YouTube team fixes the API bug, we can remove this
        // temporary bug fix.
        state.browserIsFirefox = navigator.userAgent
            .toLowerCase().indexOf('firefox') > -1;

        if (state.videoType === 'html5') {
            state.videoPlayer.player = new HTML5Video.Player(state.el, {
                playerVars:   state.videoPlayer.playerVars,
                videoSources: state.config.sources,
                loadLocalSource: state.config.loadLocalSource,
                oldSource: state.config.oldSource,
                newSource: state.config.newSource,
                vilidateService: state.config.vilidateService,
                local_path: state.config.local_path,
                events: {
                    onReady:       state.videoPlayer.onReady,
                    onStateChange: state.videoPlayer.onStateChange
                }
            });

            player = state.videoEl = state.videoPlayer.player.videoEl;

            player[0].addEventListener('loadedmetadata', function () {
                var videoWidth = player[0].videoWidth || player.width(),
                    videoHeight = player[0].videoHeight || player.height();

                _resize(state, videoWidth, videoHeight);

                //_updateVcrAndRegion(state);
            }, false);

        } else {
            youTubeId = state.youtubeId();

            state.videoPlayer.player = new YT.Player(state.id, {
                playerVars: state.videoPlayer.playerVars,
                videoId: youTubeId,
                events: {
                    onReady: state.videoPlayer.onReady,
                    onStateChange: state.videoPlayer.onStateChange,
                    onPlaybackQualityChange: state.videoPlayer
                        .onPlaybackQualityChange
                }
            });

            state.el.on('initialize', function () {
                var player = state.videoEl = state.el.find('iframe'),
                    videoWidth = player.attr('width') || player.width(),
                    videoHeight = player.attr('height') || player.height();

                _resize(state, videoWidth, videoHeight);
                //_updateVcrAndRegion(state, true);
            });
        }
        state.el.addClass('is-unstarted');
        if (state.isTouch) {
            dfd.resolve();
        }
    }

    function _updateVcrAndRegion(state, isYoutube) {
        var update = function (state) {
            var duration = state.videoPlayer.duration(),
                time;

            time = state.videoPlayer.figureOutStartingTime(duration);

            // Update the VCR.
            state.trigger(
                'videoControl.updateVcrVidTime',
                {
                    time: time,
                    duration: duration
                }
            );

            // Update the time slider.
            state.trigger(
                'videoProgressSlider.updateStartEndTimeRegion',
                {
                    duration: duration
                }
            );
            state.trigger(
                'videoProgressSlider.updatePlayTime',
                {
                    time: time,
                    duration: duration
                }
            );
        };

        // After initialization, update the VCR with total time.
        // At this point only the metadata duration is available (not
        // very precise), but it is better than having 00:00:00 for
        // total time.
        if (state.youtubeMetadataReceived || !isYoutube) {
            // Metadata was already received, and is available.
            update(state);
        } else {
            // We wait for metadata to arrive, before we request the update
            // of the VCR video time, and of the start-end time region.
            // Metadata contains duration of the video.
            state.el.on('metadata_received', function () {
                update(state);
            });
        }
    }

    function _resize(state, videoWidth, videoHeight) {
        state.resizer = new Resizer({
                element: state.videoEl,
                elementRatio: videoWidth/videoHeight,
                container: state.container
            })
            .callbacks.once(function() {
                state.el.trigger('caption:resize');
            })
            .setMode('width');

        // Update captions size when controls becomes visible on iPad or Android
        if (/iPad|Android/i.test(state.isTouch[0])) {
            state.el.on('controls:show', function () {
                state.el.trigger('caption:resize');
            });
        }

        $(window).on('resize', _.debounce(function () {
            state.trigger('videoControl.updateControlsHeight', null);
            state.el.trigger('caption:resize');
            state.resizer.align();
        }, 100));
    }

    // function _restartUsingFlash(state)
    //
    //     When we are about to play a YouTube video in HTML5 mode and discover
    //     that we only have one available playback rate, we will switch to
    //     Flash mode. In Flash speed switching is done by reloading videos
    //     recorded at different frame rates.
    function _restartUsingFlash(state) {
        // Remove from the page current iFrame with HTML5 video.
        state.videoPlayer.player.destroy();

        state.setPlayerMode('flash');

        console.log('[Video info]: Changing YouTube player mode to "flash".');

        // Removed configuration option that requests the HTML5 mode.
        delete state.videoPlayer.playerVars.html5;

        // Request for the creation of a new Flash player
        state.videoPlayer.player = new YT.Player(state.id, {
            playerVars: state.videoPlayer.playerVars,
            videoId: state.youtubeId(),
            events: {
                onReady: state.videoPlayer.onReady,
                onStateChange: state.videoPlayer.onStateChange,
                onPlaybackQualityChange: state.videoPlayer
                    .onPlaybackQualityChange
            }
        });

        _updateVcrAndRegion(state, true);
        state.el.trigger('caption:fetch');
        state.resizer.setElement(state.el.find('iframe')).align();
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function pause() {
        if (this.videoPlayer.player.pauseVideo) {
            this.videoPlayer.player.pauseVideo();
        }
    }

    function play() {
        if (this.videoPlayer.player.playVideo) {
            if (this.videoPlayer.isEnded()) {
                // When the video will start playing again from the start, the
                // start-time and end-time will come back into effect.
                this.videoPlayer.goToStartTime = true;
                this.videoPlayer.stopAtEndTime = true;
            }
            this.videoPlayer.player.playVideo();
        }
        this.videoPlayer.isSuspended = false;
    }

    // This function gets the video's current play position in time
    // (currentTime) and its duration.
    // It is called at a regular interval when the video is playing.
    function update(time) {
        this.videoPlayer.currentTime = time || this.videoPlayer.player.getCurrentTime();

        if (isFinite(this.videoPlayer.currentTime)) {
            this.videoPlayer.updatePlayTime(this.videoPlayer.currentTime);

            // We need to pause the video if current time is smaller (or equal)
            // than end-time. Also, we must make sure that this is only done
            // once per video playing from start to end.
            if (
                this.videoPlayer.stopAtEndTime &&
                this.videoPlayer.endTime !== null &&
                this.videoPlayer.endTime <= this.videoPlayer.currentTime
            ) {
                this.videoPlayer.stopAtEndTime = false;

                this.videoPlayer.pause();

                this.trigger('videoProgressSlider.notifyThroughHandleEnd', {
                    end: true
                });
            }
        }
    }

    function suspended(){
        if (this.videoPlayer.isPlaying()) {
            this.videoPlayer.pause();
            this.videoPlayer.isSuspended = true;
        }
    }

    function recover(){
        if (this.videoPlayer.isSuspended && this.videoPlayer.isPaused()) {
            this.videoPlayer.play();
        }
    }

    function setPlaybackRate(newSpeed) {
        var duration = this.videoPlayer.duration(),
            time = this.videoPlayer.currentTime,
            methodName, youtubeId;

        if (
            this.isHtml5Mode() &&
            !(
                this.browserIsFirefox &&
                newSpeed === '1.0' &&
                this.isYoutubeType()
            )
        ) {
            this.videoPlayer.player.setPlaybackRate(newSpeed);
        } else {
            // We request the reloading of the video in the case when YouTube
            // is in Flash player mode, or when we are in Firefox, and the new
            // speed is 1.0. The second case is necessary to avoid the bug
            // where in Firefox speed switching to 1.0 in HTML5 player mode is
            // handled incorrectly by YouTube API.
            methodName = 'cueVideoById';
            youtubeId = this.youtubeId(newSpeed);

            if (this.videoPlayer.isPlaying()) {
                methodName = 'loadVideoById';
            }

            this.videoPlayer.player[methodName](youtubeId, time);

            // We need to call play() explicitly because after the call
            // to functions cueVideoById() followed by seekTo() the video
            // is in a PAUSED state.
            //
            // Why? This is how the YouTube API is implemented.
            this.videoPlayer.updatePlayTime(time);
            if (time > 0 && this.isFlashMode()) {
                this.videoPlayer.seekTo(time);
                this.trigger(
                    'videoProgressSlider.updateStartEndTimeRegion',
                    {
                        duration: duration
                    }
                );
            }
        }
    }

    function onSpeedChange(newSpeed) {
        var time = this.videoPlayer.currentTime;

        if (this.isFlashMode()) {
            this.videoPlayer.currentTime = Time.convert(
                time,
                parseFloat(this.speed),
                newSpeed
            );
        }

        newSpeed = parseFloat(newSpeed).toFixed(2).replace(/\.00$/, '.0');

        this.videoPlayer.log(
            'speed_change_video',
            {
                current_time: time,
                old_speed: this.speed,
                new_speed: newSpeed
            }
        );

        this.setSpeed(newSpeed, true);
        this.videoPlayer.setPlaybackRate(newSpeed);
        this.saveState(true, { speed: newSpeed });
    }

    // Every 200 ms, if the video is playing, we call the function update, via
    // clearInterval. This interval is called updateInterval.
    // It is created on a onPlay event. Cleared on a onPause event.
    // Reinitialized on a onSeek event.
    function onSeek(params) {
        var time = params.time,
            type = params.type,
            oldTime = this.videoPlayer.currentTime;

        // After the user seeks, the video will start playing from
        // the sought point, and stop playing at the end.
        this.videoPlayer.goToStartTime = false;
        if (time > this.videoPlayer.endTime || this.videoPlayer.endTime === null) {
            this.videoPlayer.stopAtEndTime = false;
        }

        this.videoPlayer.seekTo(time);
        this.videoPlayer.log(
            'seek_video',
            {
                old_time: oldTime,
                new_time: time,
                type: type
            }
        );
    }

    function seekTo(time) {
        var duration = this.videoPlayer.duration();

        if ((typeof time !== 'number') || (time > duration) || (time < 0)) {
            return false;
        }

        this.el.off('play.seek');

        if (this.videoPlayer.isPlaying()) {
            this.videoPlayer.stopTimer();
        } else {
            this.videoPlayer.currentTime = time;
        }
        var isUnplayed = this.videoPlayer.isUnstarted() ||
                         this.videoPlayer.isCued();

        // Use `cueVideoById` method for youtube video that is not played before.
        if (isUnplayed && this.isYoutubeType()) {
            this.videoPlayer.player.cueVideoById(this.youtubeId(), time);
        } else {
            // Youtube video cannot be rewinded during bufferization, so wait to
            // finish bufferization and then rewind the video.
            if (this.isYoutubeType() && this.videoPlayer.isBuffering()) {
                this.el.on('play.seek', function () {
                    this.videoPlayer.player.seekTo(time, true);
                }.bind(this));
            } else {
                // Otherwise, just seek the video
                this.videoPlayer.player.seekTo(time, true);
            }
        }

        this.videoPlayer.updatePlayTime(time, true);
        this.el.trigger('seek', arguments);
    }

    function moveForward() {
        var currentTime = this.videoPlayer.currentTime;
        var time = currentTime + 30,
            duration = this.videoPlayer.duration();
        if (time > duration){
            time = duration;
        }
        this.videoPlayer.seekTo(time);
        this.videoPlayer.log(
            'move_forward',
            {
                new_time: time
            }
        );
    }

    function moveBack() {
        var currentTime = this.videoPlayer.currentTime;
        var time = currentTime - 30;
        if (time < 0){
            time = 0;
        }
        this.videoPlayer.seekTo(time);
        this.videoPlayer.log(
            'move_back',
            {
                new_time: time
            }
        );
    }

    function runTimer() {
        if (!this.videoPlayer.updateInterval) {
            this.videoPlayer.updateInterval = window.setInterval(
                this.videoPlayer.update, 200
            );

            this.videoPlayer.update();
        }
    }

    function stopTimer() {
        window.clearInterval(this.videoPlayer.updateInterval);
        delete this.videoPlayer.updateInterval;
    }

    function onEnded() {
        var time = this.videoPlayer.duration();
        this.videoPlayer.log(
            'stop_video',
            {
                currentTime: this.videoPlayer.currentTime
            }
        );

        this.trigger('videoControl.pause', null);
        this.trigger('videoProgressSlider.notifyThroughHandleEnd', {
            end: true
        });

        if (this.videoPlayer.skipOnEndedStartEndReset) {
            this.videoPlayer.skipOnEndedStartEndReset = undefined;
        }

        // Sometimes `onEnded` events fires when `currentTime` not equal
        // `duration`. In this case, slider doesn't reach the end point of
        // timeline.
        this.videoPlayer.updatePlayTime(time);

        this.el.trigger('ended', arguments);
    }

    function onPause() {
        this.videoPlayer.log(
            'pause_video',
            {
                currentTime: this.videoPlayer.currentTime
            }
        );

        this.videoPlayer.stopTimer();
        this.trigger('videoControl.pause', null);
        this.saveState(true);
        this.el.trigger('pause', arguments);
    }

    function onPlay() {
        var duration = this.videoPlayer.duration(),
            last_time = this.videoPlayer.currentTime,
            data = {};
        if (last_time === 0){
            var saved_video_position = this.config.savedVideoPosition;
            if(saved_video_position < duration){
                last_time = saved_video_position;
            }
        }else{
            if(typeof last_time === 'number' &&  parseInt(last_time) === parseInt(duration)){
                last_time = 0;
            }
        }
        data['saved_video_position'] = last_time;
        if(this.el.hasClass('is-unstarted')){
            var time = this.videoPlayer.figureOutStartingTime(duration);
            if (time > 0 && this.videoPlayer.goToStartTime) {
                this.videoPlayer.seekTo(time);
            }
            this.el.removeClass('is-unstarted');
            data['watch_times'] = this.config.watchTimes+1;
        }
        this.saveState(true, data);
        // 重置切换高清标清状态标记
        if (this.config.isQualityControl == true){
            //this.videoPlayer.seekTo(this.config.savedVideoPosition);
            this.videoPlayer.currentTime = this.config.savedVideoPosition;
            this.config.isQualityControl = false;
        }

        this.videoPlayer.log(
            'play_video',
            {
                currentTime: this.videoPlayer.currentTime
            }
        );

        this.videoPlayer.runTimer();
        this.trigger('videoControl.play', null);
        this.trigger('videoProgressSlider.notifyThroughHandleEnd', {
            end: false
        });

        this.videoPlayer.ready();

        this.el.trigger('play', arguments);
    }

    function onUnstarted() { }

    function handlePlaybackQualityChange(value) {
    //    this.videoPlayer.player.setPlaybackQuality(value);
    }

    function onPlaybackQualityChange() {
        var quality;

        quality = this.videoPlayer.player.getPlaybackQuality();

        this.trigger('videoQualityControl.onQualityChange', quality);

        this.el.trigger('qualitychange', arguments);
    }

    function onReady() {
        var _this = this,
            availablePlaybackRates, baseSpeedSubs,
            player, videoWidth, videoHeight;

        dfd.resolve();

        this.el.on('speedchange', function (event, speed) {
            _this.videoPlayer.onSpeedChange(speed);
        });

        this.el.on('volumechange volumechange:silent', function (event, volume) {
            _this.videoPlayer.onVolumeChange(volume);
        });

        availablePlaybackRates = this.videoPlayer.player
                                    .getAvailablePlaybackRates();

        // Because of problems with muting sound outside of range 0.25 and
        // 5.0, we should filter our available playback rates.
        // Issues:
        //   https://code.google.com/p/chromium/issues/detail?id=264341
        //   https://bugzilla.mozilla.org/show_bug.cgi?id=840745
        //   https://developer.mozilla.org/en-US/docs/DOM/HTMLMediaElement

        availablePlaybackRates = _.filter(
            availablePlaybackRates,
            function (item) {
                var speed = Number(item);
                return speed > 0.25 && speed <= 5;
            }
        );

        // Because of a recent change in the YouTube API (not documented), sometimes
        // HTML5 mode loads after Flash mode has been loaded. In this case we have
        // multiple speeds available but the variable `this.currentPlayerMode` is
        // set to "flash". This is impossible because in Flash mode we can have
        // only one speed available. Therefore we must execute the following code
        // block if we have multiple speeds or if `this.currentPlayerMode` is set to
        // "html5". If any of the two conditions are true, we then set the variable
        // `this.currentPlayerMode` to "html5".
        //
        // For more information, please see the PR that introduced this change:
        //     https://github.com/edx/edx-platform/pull/2841
        if (
            (this.isHtml5Mode() || availablePlaybackRates.length > 1) &&
            this.isYoutubeType()
        ) {
            if (availablePlaybackRates.length === 1 && !this.isTouch) {
                // This condition is needed in cases when Firefox version is
                // less than 20. In those versions HTML5 playback could only
                // happen at 1 speed (no speed changing). Therefore, in this
                // case, we need to switch back to Flash.
                //
                // This might also happen in other browsers, therefore when we
                // have 1 speed available, we fall back to Flash.

                _restartUsingFlash(this);
                return false;
            } else if (availablePlaybackRates.length > 1) {
                this.setPlayerMode('html5');

                // We need to synchronize available frame rates with the ones
                // that the user specified.

                baseSpeedSubs = this.videos['1.0'];
                // this.videos is a dictionary containing various frame rates
                // and their associated subs.

                // First clear the dictionary.
                $.each(this.videos, function (index, value) {
                    delete _this.videos[index];
                });
                this.speeds = [];
                // Recreate it with the supplied frame rates.
                $.each(availablePlaybackRates, function (index, value) {
                    var key = value.toFixed(2).replace(/\.00$/, '.0');

                    _this.videos[key] = baseSpeedSubs;
                    _this.speeds.push(key);
                });

                this.setSpeed(this.speed);
                this.el.trigger('speed:render', [this.speeds, this.speed]);
            }
        }

        if (this.isFlashMode()) {
            this.setSpeed(this.speed);
            this.el.trigger('speed:set', [this.speed]);
        }

        if (this.isHtml5Mode()) {
            this.videoPlayer.player.setPlaybackRate(this.speed);
        }

        if(!this.el.hasClass('is-unstarted')) {
            var duration = this.videoPlayer.duration(),
                time = this.videoPlayer.figureOutStartingTime(duration);
            if (time > 0) {
                this.videoPlayer.seekTo(time);
            }
        }
        this.el.trigger('ready', arguments);
    }

    function onStateChange(event) {
        this.el.removeClass([
            'is-playing', 'is-paused', 'is-buffered',
            'is-ended', 'is-cued'
        ].join(' '));

        switch (event.data) {
            case this.videoPlayer.PlayerState.UNSTARTED:
                this.el.addClass('is-unstarted');
                this.videoPlayer.onUnstarted();
                break;
            case this.videoPlayer.PlayerState.PLAYING:
                this.el.addClass('is-playing');
                this.videoPlayer.onPlay();
                break;
            case this.videoPlayer.PlayerState.PAUSED:
                this.el.addClass('is-paused');
                this.videoPlayer.onPause();
                break;
            case this.videoPlayer.PlayerState.BUFFERING:
                this.el.addClass('is-buffered');
                this.el.trigger('buffering');
                break;
            case this.videoPlayer.PlayerState.ENDED:
                this.el.addClass('is-ended');
                this.videoPlayer.onEnded();
                break;
            case this.videoPlayer.PlayerState.CUED:
                this.el.addClass('is-cued');
                if (this.isFlashMode()) {
                    this.videoPlayer.play();
                }
                break;
        }
    }

    function figureOutStartEndTime(duration) {
        var videoPlayer = this.videoPlayer;

        videoPlayer.startTime = this.config.startTime;
        if (videoPlayer.startTime >= duration) {
            videoPlayer.startTime = 0;
        } else if (this.isFlashMode()) {
            videoPlayer.startTime /= Number(this.speed);
        }

        videoPlayer.endTime = this.config.endTime;
        if (
            videoPlayer.endTime <= videoPlayer.startTime ||
            videoPlayer.endTime >= duration
        ) {
            videoPlayer.stopAtEndTime = false;
            videoPlayer.endTime = null;
        } else if (this.isFlashMode()) {
            videoPlayer.endTime /= Number(this.speed);
        }
    }

    function figureOutStartingTime(duration) {
        var savedVideoPosition = this.config.savedVideoPosition,

            // Default starting time is 0. This is the case when
            // there is not start-time, no previously saved position,
            // or one (or both) of those values is incorrect.
            time = 0,

            startTime, endTime;

        this.videoPlayer.figureOutStartEndTime(duration);

        startTime = this.videoPlayer.startTime;
        endTime   = this.videoPlayer.endTime;

        if (startTime > 0) {
            if (
                startTime < savedVideoPosition &&
                (endTime > savedVideoPosition || endTime === null) &&

                // We do not want to jump to the end of the video.
                // We subtract 1 from the duration for a 1 second
                // safety net.
                savedVideoPosition < duration - 1
            ) {
                time = savedVideoPosition;
            } else {
                time = startTime;
            }
        } else if (
            savedVideoPosition > 0 &&
            (endTime > savedVideoPosition || endTime === null) &&

            // We do not want to jump to the end of the video.
            // We subtract 1 from the duration for a 1 second
            // safety net.
            savedVideoPosition < duration - 1
        ) {
            time = savedVideoPosition;
        }

        return time;
    }

    function updatePlayTime(time, skip_seek) {
        var videoPlayer = this.videoPlayer,
            duration = this.videoPlayer.duration(),
            youTubeId;

        this.trigger(
            'videoProgressSlider.updatePlayTime',
            {
                time: time,
                duration: duration
            }
        );

        this.trigger(
            'videoControl.updateVcrVidTime',
            {
                time: time,
                duration: duration
            }
        );

        this.el.trigger('caption:update', [time]);
    }

    function isEnded() {
        var playerState = this.videoPlayer.player.getPlayerState(),
            ENDED = this.videoPlayer.PlayerState.ENDED;

        return playerState === ENDED;
    }

    function isPlaying() {
        var playerState = this.videoPlayer.player.getPlayerState();

        return playerState === this.videoPlayer.PlayerState.PLAYING;
    }

    function isPaused() {
        var playerState = this.videoPlayer.player.getPlayerState();

        return playerState === this.videoPlayer.PlayerState.PAUSED;
    }

    function isBuffering() {
        var playerState = this.videoPlayer.player.getPlayerState();

        return playerState === this.videoPlayer.PlayerState.BUFFERING;
    }

    function isCued() {
        var playerState = this.videoPlayer.player.getPlayerState();

        return playerState === this.videoPlayer.PlayerState.CUED;
    }

    function isUnstarted() {
        var playerState = this.videoPlayer.player.getPlayerState();

        return playerState === this.videoPlayer.PlayerState.UNSTARTED;
    }

    /*
     * Return the duration of the video in seconds.
     *
     * First, try to use the native player API call to get the duration.
     * If the value returned by the native function is not valid, resort to
     * the value stored in the metadata for the video. Note that the metadata
     * is available only for YouTube videos.
     *
     * IMPORTANT! It has been observed that sometimes, after initial playback
     * of the video, when operations "pause" and "play" are performed (in that
     * sequence), the function will start returning a slightly different value.
     *
     * For example: While playing for the first time, the function returns 31.
     * After pausing the video and then resuming once more, the function will
     * start returning 31.950656.
     *
     * This instability is internal to the player API (or browser internals).
     */
    function duration() {
        var dur;

        // Sometimes the YouTube API doesn't finish instantiating all of it's
        // methods, but the execution point arrives here.
        //
        // This happens when you have start-time and end-time set, and click "Edit"
        // in Studio, and then "Save". The Video editor dialog closes, the
        // video reloads, but the start-end range is not visible.
        if (this.videoPlayer.player.getDuration) {
            dur = this.videoPlayer.player.getDuration();
        }

        // For YouTube videos, before the video starts playing, the API
        // function player.getDuration() will return 0. This means that the VCR
        // will show total time as 0 when the page just loads (before the user
        // clicks the Play button).
        //
        // We can do betterin a case when dur is 0 (or less than 0). We can ask
        // the getDuration() function for total time, which will query the
        // metadata for a duration.
        //
        // Be careful! Often the metadata duration is not very precise. It
        // might differ by one or two seconds against the actual time as will
        // be reported later on by the player.getDuration() API function.
        if (!isFinite(dur) || dur <= 0) {
            if (this.isYoutubeType()) {
                dur = this.getDuration();
            }
        }

        // Just in case the metadata is garbled, or something went wrong, we
        // have a final check.
        if (!isFinite(dur) || dur <= 0) {
            dur = 0;
        }

        return Math.floor(dur);
    }

    function log(eventName, data) {
        var logInfo;

        // Default parameters that always get logged.
        logInfo = {
            id:   this.id
        };

        // If extra parameters were passed to the log.
        if (data) {
            $.each(data, function (paramName, value) {
                logInfo[paramName] = value;
            });
        }

        if (this.isYoutubeType()) {
            logInfo.code = this.youtubeId();
        } else {
            logInfo.code = 'html5';
        }

        Logger.log(eventName, logInfo);
    }

    function onVolumeChange(volume) {
        this.videoPlayer.player.setVolume(volume);
    }
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (requirejs, require, define) {

// VideoAccessibleMenu module.
define(
'video/035_video_accessible_menu.js',
[],
function () {

    // VideoAccessibleMenu() function - what this module "exports".
    return function (state) {
        var dfd = $.Deferred();

        if (state.el.find('li.video-tracks') === 0) {
            dfd.resolve();
            return dfd.promise();
        }

        state.videoAccessibleMenu = {
            value: state.storage.getItem('transcript_download_format')
        };

        _initialize(state);
        dfd.resolve();
        return dfd.promise();
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    function _initialize(state) {
        _makeFunctionsPublic(state);
        _renderElements(state);
        _addAriaAttributes(state);
        _bindHandlers(state);
    }

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called,
    //     these functions will get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        var methodsDict = {
            changeFileType: changeFileType,
            setValue: setValue
        };

        state.bindTo(methodsDict, state.videoAccessibleMenu, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _renderElements(state) {

        // For the  time being, we assume that the menu structure is present in
        // the template HTML. In the future accessible menu plugin, everything
        // inside <div class='menu-container'></div> will be generated in this
        // file.
        var container = state.el.find('li.video-tracks>div.a11y-menu-container'),
            button = container.children('a.a11y-menu-button'),
            menuList = container.children('ol.a11y-menu-list'),
            menuItems = menuList.children('li.a11y-menu-item'),
            menuItemsLinks = menuItems.children('a.a11y-menu-item-link'),
            value = (function (val, activeElement) {
                return val || activeElement.find('a').data('value') || 'srt';
            }(state.videoAccessibleMenu.value, menuItems.filter('.active'))),
            msg = '.' + value;

        $.extend(state.videoAccessibleMenu, {
            container: container,
            button: button,
            menuList: menuList,
            menuItems: menuItems,
            menuItemsLinks: menuItemsLinks
        });

        if (value) {
            state.videoAccessibleMenu.setValue(value);
            button.text(gettext(msg));
        }
    }

    function _addAriaAttributes(state) {
        var menu = state.videoAccessibleMenu;

        menu.button.attr({
            'role': 'button',
            'aria-disabled': 'false'
        });

        menu.menuList.attr('role', 'menu');

        menu.menuItemsLinks.each(function(){
            $(this).attr({
                'role': 'menuitem',
                'aria-disabled': 'false'
            });
        });
    }

    // Get previous element in array or cyles back to the last if it is the
    // first.
    function _previousMenuItemLink(links, index) {
        return $(links.eq(index < 1 ? links.length - 1 : index - 1));
    }

    // Get next element in array or cyles back to the first if it is the last.
    function _nextMenuItemLink(links, index) {
        return $(links.eq(index >= links.length - 1 ? 0 : index + 1));
    }

    function _menuItemsLinksFocused(menu) {
        return menu.menuItemsLinks.is(':focus');
    }

    function _openMenu(menu, without_handler) {
        // When menu items have focus, the menu stays open on
        // mouseleave. A _closeMenuHandler is added to the window
        // element to have clicks close the menu when they happen
        // outside of it. We namespace the click event to easily remove it (and
        // only it) in _closeMenu.
        menu.container.addClass('open');
        menu.button.text('...');
        if (!without_handler) {
            $(window).on('click.currentMenu', _closeMenuHandler.bind(menu));
        }

        // @TODO: onOpen callback
    }

    function _closeMenu(menu, without_handler) {
        // Remove the previously added clickHandler from window element.
        var msg = '.' + menu.value;

        menu.container.removeClass('open');
        menu.button.text(gettext(msg));
        if (!without_handler) {
            $(window).off('click.currentMenu');
        }

        // @TODO: onClose callback
    }

    function _openMenuHandler(event) {
        _openMenu(this, true);

        return false;
    }

    function _closeMenuHandler(event) {
        // Only close the menu if no menu item link has focus or `click` event.
        if (!_menuItemsLinksFocused(this) || event.type == 'click') {
            _closeMenu(this, true);
        }

        return false;
    }

    function _toggleMenuHandler(event) {
        if (this.container.hasClass('open')) {
            _closeMenu(this, true);
        } else {
            _openMenu(this, true);
        }

        return false;
    }

    // Various event handlers. They all return false to stop propagation and
    // prevent default behavior.
    function _clickHandler(event) {
        var target = $(event.currentTarget);

        this.changeFileType.call(this, event);
        _closeMenu(this, true);

        return false;
    }

    function _keyDownHandler(event) {
        var KEY = $.ui.keyCode,
            keyCode = event.keyCode,
            target = $(event.currentTarget),
            index;

        if (target.is('a.a11y-menu-item-link')) {

            index = target.parent().index();

            switch (keyCode) {
                // Scroll up menu, wrapping at the top. Keep menu open.
                case KEY.UP:
                    _previousMenuItemLink(this.menuItemsLinks, index).focus();
                    break;
                // Scroll down  menu, wrapping at the bottom. Keep menu
                // open.
                case KEY.DOWN:
                    _nextMenuItemLink(this.menuItemsLinks, index).focus();
                    break;
                // Close menu.
                case KEY.TAB:
                    _closeMenu(this);
                    // TODO
                    // What has to happen here? In speed menu, tabbing backward
                    // will give focus to Play/Pause button and tabbing
                    // forward to Volume button.
                    break;
                // Close menu, give focus to button and change
                // file type.
                case KEY.ENTER:
                case KEY.SPACE:
                    this.button.focus();
                    this.changeFileType.call(this, event);
                    _closeMenu(this);
                    break;
                // Close menu and give focus to speed control.
                case KEY.ESCAPE:
                    _closeMenu(this);
                    this.button.focus();
                    break;
            }
            return false;
        }
        else {
            switch(keyCode) {
                // Open menu and focus on last element of list above it.
                case KEY.ENTER:
                case KEY.SPACE:
                case KEY.UP:
                    _openMenu(this);
                    this.menuItemsLinks.last().focus();
                    break;
                // Close menu.
                case KEY.ESCAPE:
                    _closeMenu(this);
                    break;
            }
            // We do not stop propagation and default behavior on a TAB
            // keypress.
            return event.keyCode === KEY.TAB;
        }
    }

    /**
     * @desc Bind any necessary function callbacks to DOM events (click,
     *     mousemove, etc.).
     *
     * @type {function}
     * @access private
     *
     * @param {object} state The object containg the state of the video player.
     *     All other modules, their parameters, public variables, etc. are
     *     available via this object.
     *
     * @this {object} The global window object.
     *
     * @returns {undefined}
     */
    function _bindHandlers(state) {
        var menu = state.videoAccessibleMenu;

        // Attach various events handlers to menu container.
        menu.container.on({
            'mouseenter': _openMenuHandler.bind(menu),
            'mouseleave': _closeMenuHandler.bind(menu),
            'click': _toggleMenuHandler.bind(menu),
            'keydown': _keyDownHandler.bind(menu)
        });

        // Attach click and keydown event handlers to individual menu items.
        menu.menuItems
            .on('click', 'a.a11y-menu-item-link', _clickHandler.bind(menu))
            .on('keydown', 'a.a11y-menu-item-link', _keyDownHandler.bind(menu));
    }

    function setValue(value) {
        var menu = this.videoAccessibleMenu;

        menu.value = value;
        menu.menuItems
            .removeClass('active')
            .find("a[data-value='" + value + "']")
            .parent()
            .addClass('active');
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function changeFileType(event) {
        var fileType = $(event.currentTarget).data('value');

        this.videoAccessibleMenu.setValue(fileType);
        this.saveState(true, {'transcript_download_format': fileType});
        this.storage.setItem('transcript_download_format', fileType);
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (requirejs, require, define) {

// VideoControl module.
define(
'video/04_video_control.js',
[],
function () {

    // VideoControl() function - what this module "exports".
    return function (state) {
        var dfd = $.Deferred();

        state.videoControl = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);

        dfd.resolve();
        return dfd.promise();
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        var methodsDict = {
            exitFullScreen: exitFullScreen,
            hideControls: hideControls,
            hidePlayPlaceholder: hidePlayPlaceholder,
            pause: pause,
            play: play,
            show: show,
            showControls: showControls,
            showPlayPlaceholder: showPlayPlaceholder,
            toggleFullScreen: toggleFullScreen,
            togglePlayback: togglePlayback,
            updateControlsHeight: updateControlsHeight,
            updateVcrVidTime: updateVcrVidTime
        };

        state.bindTo(methodsDict, state.videoControl, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their initial configuration. Also
    //     make the created DOM elements available via the 'state' object. Much easier to work this
    //     way - you don't have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoControl.el = state.el.find('.video-controls');
        // state.videoControl.el.append(el);

        state.videoControl.sliderEl            = state.videoControl.el.find('.slider');
        state.videoControl.playPauseEl         = state.videoControl.el.find('.video_control');
        state.videoControl.playPlaceholder     = state.el.find('.btn-play');
        state.videoControl.secondaryControlsEl = state.videoControl.el.find('.secondary-controls');
        state.videoControl.fullScreenEl        = state.videoControl.el.find('.add-fullscreen');

        state.videoControl.vidCTimeEl          = state.videoControl.el.find('.vidtime_currenttime');
        state.videoControl.vidTimeDurationEl   = state.videoControl.el.find('.vidtime_duration');

        state.videoControl.fullScreenState = false;
        state.videoControl.pause();

        if (state.isTouch && state.videoType === 'html5') {
            state.videoControl.showPlayPlaceholder();
        }

        if ((state.videoType === 'html5') && (state.config.autohideHtml5)) {
            state.videoControl.fadeOutTimeout = state.config.fadeOutTimeout;
            state.videoControl.fadeOutDelay = state.config.fadeOutDelay;

            state.videoControl.el.addClass('html5');
            if(state.videoControl.fullScreenState){
                state.controlHideTimeout = setTimeout(state.videoControl.hideControls, state.videoControl.fadeOutDelay);
            }
        }

        // ARIA
        // Let screen readers know that this anchor, representing the slider
        // handle, behaves as a slider named 'video slider'.
        state.videoControl.sliderEl.find('.ui-slider-handle').attr({
            'role': 'slider',
            'title': gettext('Video slider')
        });

        state.videoControl.updateControlsHeight();
    }

    // function _bindHandlers(state)
    //
    //     Bind any necessary function callbacks to DOM events (click, mousemove, etc.).
    function _bindHandlers(state) {
        state.videoControl.playPauseEl.on('click', state.videoControl.togglePlayback);
        state.videoControl.fullScreenEl.on('click', state.videoControl.toggleFullScreen);
        state.el.on('fullscreen', function (event, isFullScreen) {
            var height = state.videoControl.updateControlsHeight();

            if (isFullScreen) {
                state.resizer
                    .delta
                    .substract(height, 'height')
                    .setMode('both');

            } else {
                state.resizer
                    .delta
                    .reset()
                    .setMode('width');
            }
        });

        $(document).on('keyup', state.videoControl.exitFullScreen);

        if ((state.videoType === 'html5') && (state.config.autohideHtml5)) {
            state.el.on('mousemove', state.videoControl.showControls);
            state.el.on('keydown', state.videoControl.showControls);
        }
        state.el.on('keydown', function(event){
            var e = event||window.event,
                key = $.ui.keyCode;
            if(e.keyCode === key.SPACE){
                state.videoControl.togglePlayback(event);
            } else if(e.keyCode === key.LEFT){
                state.trigger('videoPlayer.moveBack', null);
            } else if(e.keyCode === key.RIGHT){
                state.trigger('videoPlayer.moveForward', null);
            }
        });

        // The state.previousFocus is used in video_speed_control to track
        // the element that had the focus before it.
        state.videoControl.playPauseEl.on('blur', function () {
            state.previousFocus = 'playPause';
        });

        if (/iPad|Android/i.test(state.isTouch[0])) {
            state.videoControl.playPlaceholder
                .on('click', function () {
                    state.trigger('videoPlayer.play', null);
                });
        }
    }
    function _getControlsHeight(control) {
        return control.el.height() + 0.5 * control.sliderEl.height();
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function updateControlsHeight () {
        this.videoControl.height = _getControlsHeight(this.videoControl);

        return this.videoControl.height;
    }

    function show() {
        this.videoControl.el.removeClass('is-hidden');
        this.el.trigger('controls:show', arguments);
    }

    function showControls(event) {
        if (!this.controlShowLock) {

            this.controlShowLock = true;

            if (!this.videoControl.fullScreenState) {
                if (this.controlState === 'invisible') {
                    this.videoControl.el.css('margin-bottom', '0px');
                    this.controlState = 'visible';
                } else if (this.controlState === 'hiding') {
                    this.videoControl.el.stop(true, false).css('margin-bottom', '0px');
                    this.controlState = 'visible';
                } else if (this.controlState === 'visible') {
                    clearTimeout(this.controlHideTimeout);
                }
                this.controlShowLock = false;
                return;
            }

            if (this.controlState === 'invisible') {
                this.videoControl.el.animate({marginBottom:'0px'}, this.videoControl.fadeOutTimeout);
                this.controlState = 'visible';
            } else if (this.controlState === 'hiding') {
                this.videoControl.el.stop(true, false).animate({marginBottom:'0px'}, this.videoControl.fadeOutTimeout);
                this.controlState = 'visible';
            } else if (this.controlState === 'visible') {
                clearTimeout(this.controlHideTimeout);
            }

            if(this.videoControl.isPlaying){
                this.controlHideTimeout = setTimeout(this.videoControl.hideControls, this.videoControl.fadeOutDelay);
            }
            this.controlShowLock = false;
        }
    }

    function hideControls() {
        var _this;

        this.controlHideTimeout = null;

        if (!this.videoControl.fullScreenState) {
            return;
        }

        this.controlState = 'hiding';

        _this = this;

        this.videoControl.el.animate({marginBottom:'-34px'}, this.videoControl.fadeOutTimeout, function () {
            _this.controlState = 'invisible';

            // If the focus was on the video control or the volume control,
            // then we must make sure to close these dialogs. Otherwise, after
            // next autofocus, these dialogs will be open, but the focus will
            // not be on them.
            _this.videoVolumeControl.el.removeClass('open');
            _this.videoSpeedControl.el.removeClass('open');

            _this.focusGrabber.enableFocusGrabber();
        });
    }

    function showPlayPlaceholder(event) {
        this.videoControl.playPlaceholder
            .removeClass('is-hidden')
            .attr({
                'aria-hidden': 'false',
                'tabindex': 0
            });
    }

    function hidePlayPlaceholder(event) {
        this.videoControl.playPlaceholder
            .addClass('is-hidden')
            .attr({
                'aria-hidden': 'true',
                'tabindex': -1
            });
    }

    function play() {
        this.videoControl.isPlaying = true;
        this.videoControl.playPauseEl
            .removeClass('play')
            .addClass('pause')
            .attr('title', gettext('Pause'));

        if (/iPad|Android/i.test(this.isTouch[0]) && this.videoType === 'html5') {
            this.videoControl.hidePlayPlaceholder();
        }
    }

    function pause() {
        this.videoControl.isPlaying = false;
        this.videoControl.playPauseEl
            .removeClass('pause')
            .addClass('play')
            .attr('title', gettext('Play'));

        if (/iPad|Android/i.test(this.isTouch[0]) && this.videoType === 'html5') {
            this.videoControl.showPlayPlaceholder();
        }
    }

    function togglePlayback(event) {
        event.preventDefault();

        if (this.videoControl.isPlaying) {
            this.trigger('videoPlayer.pause', null);
        } else {
            this.trigger('videoPlayer.play', null);
        }
    }

    function toggleFullScreen(event) {
        event.preventDefault();
        var fullScreenObj = $('#video_'+this.id+' div.tc-wrapper');
        var fullScreenClassNameEl = this.el.add(document.documentElement),
            win = $(window),
            text, fullScreenStyle, sliderStyle;

        if (this.videoControl.fullScreenState) {
            this.videoControl.fullScreenState = this.isFullScreen = false;
            fullScreenClassNameEl.removeClass('video-fullscreen');
            fullScreenStyle = 'background-position: -235px center';
            sliderStyle     = 'top: 12px';
            text = gettext('Fill browser');

            this.videoControl.showControls(event);
            //显示右侧字幕
            this.videoCaption.hideCaptionsSide(false);

            if(document.exitFullscreen) {
                document.exitFullscreen();
            } else if(document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if(document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }

            win.scrollTop(this.scrollPos);
        } else {
            this.scrollPos = win.scrollTop();
            win.scrollTop(0);
            this.videoControl.fullScreenState = this.isFullScreen = true;
            fullScreenClassNameEl.addClass('video-fullscreen');
            fullScreenStyle = 'background-position: -272px center';
            sliderStyle     = 'top: 15px';
            text = gettext('Exit full browser');

            //隐藏右侧字幕
            this.videoCaption.hideCaptionsSide(true)

            // 进入全屏
            if(document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if(document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if(document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if(document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        }

        this.videoControl.sliderEl.attr('style', sliderStyle);
        this.videoControl.fullScreenEl
            .attr('title', text)
            .attr('style', fullScreenStyle)
            .text(text);

        this.el.trigger('fullscreen', [this.isFullScreen]);
    }

    function exitFullScreen(event) {
        if ((this.isFullScreen) && (event.keyCode === 27)) {
            this.videoControl.toggleFullScreen(event);
        }
    }

    function updateVcrVidTime(params) {
        this.videoControl.vidCTimeEl.html(Time.format(params.time));
        this.videoControl.vidTimeDurationEl.html(Time.format(params.duration));
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (requirejs, require, define) {

// VideoQualityControl module.
define(
'video/05_video_quality_control.js',
[],
function () {

    // VideoQualityControl() function - what this module "exports".
    return function (state) {
        var dfd = $.Deferred();

        // Changing quality for now only works for YouTube videos.
//        if (state.videoType !== 'youtube') {
//            state.el.find('a.quality-control').remove();
//            return;
//        }

        state.videoQualityControl = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);

        dfd.resolve();
        return dfd.promise();
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        var methodsDict = {
            fetchAvailableQualities: fetchAvailableQualities,
            onQualityChange: onQualityChange,
            showQualityControl: showQualityControl,
            toggleQuality: toggleQuality
        };

        state.bindTo(methodsDict, state.videoQualityControl, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their initial configuration. Also
    //     make the created DOM elements available via the 'state' object. Much easier to work this
    //     way - you don't have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoQualityControl.el = state.el.find('a.quality-control');

        state.videoQualityControl.el.show();
        state.videoQualityControl.quality = 'large';
    }

    // function _bindHandlers(state)
    //
    //     Bind any necessary function callbacks to DOM events (click, mousemove, etc.).
    function _bindHandlers(state) {
        if(state.config.sourceHigh){
            state.el.find('a.quality-control.is-sd').on('click',
                state.videoQualityControl.toggleQuality);
        }
        if(state.config.sourceLow){
            state.el.find('a.quality-control.is-hd').on('click',
                state.videoQualityControl.toggleQuality);
        }

        state.el.on('play', _.once(function () {
            state.videoQualityControl.fetchAvailableQualities();
        }));
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    /*
     * @desc Shows quality control. This function will only be called if HD
     *       qualities are available.
     *
     * @public
     */
    function showQualityControl() {
        this.videoQualityControl.el.removeClass('is-hidden');
    }

    // This function can only be called once as _.once has been used.
    /*
     * @desc Get the available qualities from YouTube API. Possible values are:
             ['highres', 'hd1080', 'hd720', 'large', 'medium', 'small'].
             HD are: ['highres', 'hd1080', 'hd720'].
     *
     * @public
     */
    function fetchAvailableQualities() {
//        var qualities = this.videoPlayer.player.getAvailableQualityLevels();
//
//        this.config.availableHDQualities = _.intersection(
//            qualities, ['highres', 'hd1080', 'hd720']
//        );
        this.config.availableHDQualities = ['highres', 'hd1080', 'hd720', 'large', 'medium', 'small']

        // HD qualities are available, show video quality control.
        if (this.config.availableHDQualities.length > 0) {
            this.trigger('videoQualityControl.showQualityControl');
        }
        // On initialization, force the video quality to be 'large' instead of
        // 'default'. Otherwise, the player will sometimes switch to HD
        // automatically, for example when the iframe resizes itself.
        this.trigger('videoPlayer.handlePlaybackQualityChange',
            this.videoQualityControl.quality
        );
    }

    function onQualityChange(value) {
        var controlStateStr;
        this.videoQualityControl.quality = value;

        if (_.contains(this.config.availableHDQualities, value)) {
            controlStateStr = gettext('HD on');
            this.videoQualityControl.el
                .removeClass('is-sd')
                .addClass('is-hd')
                .attr('title', controlStateStr)
                .text(controlStateStr);
        } else {
            controlStateStr = gettext('HD off');
            this.videoQualityControl.el
                .removeClass('is-hd')
                .addClass('is-sd')
                .attr('title', controlStateStr)
                .text(controlStateStr);

        }
    }

    // This function toggles the quality of video only if HD qualities are
    // available.
    function toggleQuality(event) {
        //////////////////
        var controlStateStr;
        var currentTime = this.videoPlayer.currentTime;
        var player = this;
        var video_ = this.videoEl.eq(0);
        var config_ = this.config;
        if ($(event.currentTarget).attr('role') == 'HD') {
            // --> 设置高清
            controlStateStr = gettext('高清');
            var firstObj = this.videoQualityControl.el.eq(0);
            firstObj.removeClass('is-sd')
                .addClass('is-hd')
                .attr('title', controlStateStr)
                .text(controlStateStr);

            this.config.savedVideoPosition = currentTime;  // 保存当前视频播放进度
            this.config.isQualityControl = true;
            this.saveState(true, {saved_video_position: currentTime});
            if(this.config.loadLocalSource == 1){
                try{
                    var file_name = config_.sourceHigh.split('/')[config_.sourceHigh.split('/').length-1];
                    var path = config_.newSource.split('//')[1].substring(config_.newSource.split('//')[1].indexOf('/')+1);
                    var xhr = $.ajax({
                        url:config_.vilidateService + '?filepath=' + path + file_name,
                        dataType:'jsonp',
                        data:'',
                        jsonp:'callback',
                        timeout:1000,
                        success:function(result) {
                            if(result.status == 200){
                                console.log('vilidate success and file was found');
                                new_source = config_.newSource + file_name;
                                video_.attr('src', new_source);
                            }else{
                                console.log('file was not found');
                                video_.attr('src', config_.sourceHigh);
                            }
                        },
                        error:function(result){
                            xhr.abort();
                            console.log('---vilidate failed---');
                            video_.attr('src', config_.sourceHigh);
                            player.trigger('videoPlayer.play', null);
                        }
                    });
                }catch (e){
                    console.log(e.message);
                    video_.attr('src', config_.sourceHigh);
                }
            }else{
                if(config_.local_path){
                    try{
                        var file_name = config_.sourceHigh.split('/')[config_.sourceHigh.split('/').length-1];
                        var path = config_.local_path.split('://')[1].substring(config_.local_path.split('://')[1].indexOf('/')+1);
                        var vilidate_path = 'http://'+config_.local_path.split('://')[1].split('/')[0] + ':9000/Service/verify';
                        console.log(vilidate_path);

                        var xhr = $.ajax({
                            url: vilidate_path + '?filepath=' + path + file_name,
                            dataType:'jsonp',
                            data:'',
                            jsonp:'callback',
                            timeout:1000,
                            success:function(result) {
                                if(result.status == 200){
                                    console.log('vilidate success and file was found');
                                    new_source = config_.local_path + file_name;
                                    video_.attr('src', new_source);
                                }else{
                                    console.log('file was not found');
                                    video_.attr('src', config_.sourceHigh);
                                }
                            },
                            error:function(result){
                                xhr.abort();
                                console.log('---vilidate failed---');
                                video_.attr('src', config_.sourceHigh);
                                player.trigger('videoPlayer.play', null);
                            }
                        });
                    }catch (e){
                        console.log(e.message);
                        video_.attr('src', config_.sourceHigh);
                    }
                }else{
                    video_.attr('src', config_.sourceHigh);
                }
            }
        } else {
            // --> 设置标清
            controlStateStr = gettext('标清');
            var firstObj = this.videoQualityControl.el.eq(0);
            firstObj.removeClass('is-hd')
                .addClass('is-sd')
                .attr('title', controlStateStr)
                .text(controlStateStr);

            this.config.savedVideoPosition = currentTime;  // 保存当前视频播放进度
            this.config.isQualityControl = true;
            this.saveState(true, {saved_video_position: currentTime});
            if(this.config.loadLocalSource == 1){
                try{
                    var file_name = config_.sourceLow.split('/')[config_.sourceLow.split('/').length-1];
                    var path = config_.newSource.split('://')[1].substring(config_.newSource.split('://')[1].indexOf('/')+1);
                    var xhr = $.ajax({
                        url:config_.vilidateService + '?filepath=' + path + file_name,
                        dataType:'jsonp',
                        data:'',
                        jsonp:'callback',
                        timeout:1000,
                        success:function(result) {
                            if(result.status == 200){
                                console.log('vilidate success and file was found');
                                new_source = config_.newSource + file_name;
                                video_.attr('src', new_source);
                            }else{
                                console.log('file was not found');
                                video_.attr('src', config_.sourceLow);
                            }
                        },
                        error:function(result){
                            xhr.abort();
                            console.log('---vilidate failed---');
                            video_.attr('src', config_.sourceLow);
                            player.trigger('videoPlayer.play', null);
                        }
                    });
                }catch (e){
                    console.log(e.message);
                    video_.attr('src', config_.sourceLow);
                }
            }else{
                if(config_.local_path){
                    try{
                        var file_name = config_.sourceLow.split('/')[config_.sourceLow.split('/').length-1];
                        var path = config_.local_path.split('://')[1].substring(config_.local_path.split('://')[1].indexOf('/')+1);
                        var vilidate_path = 'http://'+config_.local_path.split('://')[1].split('/')[0] + ':9000/Service/verify';
                        console.log(vilidate_path);

                        var xhr = $.ajax({
                            url: vilidate_path + '?filepath=' + path + file_name,
                            dataType:'jsonp',
                            data:'',
                            jsonp:'callback',
                            timeout:1000,
                            success:function(result) {
                                if(result.status == 200){
                                    console.log('vilidate success and file was found');
                                    new_source = config_.local_path + file_name;
                                    video_.attr('src', new_source);
                                }else{
                                    console.log('file was not found');
                                    video_.attr('src', config_.sourceLow);
                                }
                            },
                            error:function(result){
                                xhr.abort();
                                console.log('---vilidate failed---');
                                video_.attr('src', config_.sourceLow);
                                player.trigger('videoPlayer.play', null);
                            }
                        });
                    }catch (e){
                        console.log(e.message);
                        video_.attr('src', config_.sourceLow);
                    }
                }else{
                    video_.attr('src', config_.sourceLow);
                }
            }

        }
        this.trigger('videoPlayer.play', null);

        var newQuality, value = this.videoQualityControl.quality,
            isHD = _.contains(this.config.availableHDQualities, value);

        event.preventDefault();
        this.videoQualityControl.quality = value;

        newQuality = isHD ? 'large' : 'highres';

        this.trigger('videoPlayer.handlePlaybackQualityChange', newQuality);
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (requirejs, require, define) {

/*
"This is as true in everyday life as it is in battle: we are given one life
and the decision is ours whether to wait for circumstances to make up our
mind, or whether to act, and in acting, to live."
— Omar N. Bradley
 */

// VideoProgressSlider module.
define(
'video/06_video_progress_slider.js',
[],
function () {
    // VideoProgressSlider() function - what this module "exports".
    return function (state) {
        var dfd = $.Deferred();

        state.videoProgressSlider = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        // No callbacks to DOM events (click, mousemove, etc.).

        dfd.resolve();
        return dfd.promise();
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called,
    //     these functions will get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        var methodsDict = {
            buildSlider: buildSlider,
            getRangeParams: getRangeParams,
            onSlide: onSlide,
            onStop: onStop,
            updatePlayTime: updatePlayTime,
            updateStartEndTimeRegion: updateStartEndTimeRegion,
            notifyThroughHandleEnd: notifyThroughHandleEnd,
            getTimeDescription: getTimeDescription
        };

        state.bindTo(methodsDict, state.videoProgressSlider, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoProgressSlider.el = state.videoControl.sliderEl;

        state.videoProgressSlider.buildSlider();
        _buildHandle(state);
    }

    function _buildHandle(state) {
        state.videoProgressSlider.handle = state.videoProgressSlider.el
            .find('.ui-slider-handle');

        // ARIA
        // We just want the knob to be selectable with keyboard
        state.videoProgressSlider.el.attr('tabindex', -1);
        // Let screen readers know that this anchor, representing the slider
        // handle, behaves as a slider named 'video position'.
        state.videoProgressSlider.handle.attr({
            'role': 'slider',
            'title': gettext('Video position'),
            'aria-disabled': false,
            'aria-valuetext': getTimeDescription(state.videoProgressSlider
                .slider.slider('option', 'value'))
        });
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function buildSlider() {
        this.videoProgressSlider.slider = this.videoProgressSlider.el
            .slider({
                range: 'min',
                max: 100,
                min: 0,
                slide: this.videoProgressSlider.onSlide,
                stop: this.videoProgressSlider.onStop
            });

        this.videoProgressSlider.sliderProgress = this.videoProgressSlider
            .slider
            .find('.ui-slider-range.ui-widget-header.ui-slider-range-min');
    }

    // Rebuild the slider start-end range (if it doesn't take up the
    // whole slider). Remember that endTime === null means the end-time
    // is set to the end of video by default.
    function updateStartEndTimeRegion(params) {
        var left, width, start, end, duration, rangeParams;

        // We must have a duration in order to determine the area of range.
        // It also must be non-zero.
        if (!params.duration) {
            return;
        } else {
            duration = params.duration;
        }

        start = this.config.startTime;
        end = this.config.endTime;

        if (start > duration) {
            start = 0;
        } else if (this.isFlashMode()) {
            start /= Number(this.speed);
        }

        // If end is set to null, or it is greater than the duration of the
        // video, then we set it to the end of the video.
        if (end === null || end > duration) {
            end = duration;
        } else if (this.isFlashMode()) {
            end /= Number(this.speed);
        }

        // Don't build a range if it takes up the whole slider.
        if (start === 0 && end === duration) {
            return;
        }

        // Because JavaScript has weird rounding rules when a series of
        // mathematical operations are performed in a single statement, we will
        // split everything up into smaller statements.
        //
        // This will ensure that visually, the start-end range aligns nicely
        // with actual starting and ending point of the video.

        rangeParams = getRangeParams(start, end, duration);

        if (!this.videoProgressSlider.sliderRange) {
            this.videoProgressSlider.sliderRange = $('<div />', {
                    'class': 'ui-slider-range ' +
                             'ui-widget-header ' +
                             'ui-corner-all ' +
                             'slider-range'
                })
                .css({
                    left: rangeParams.left,
                    width: rangeParams.width
                });

            this.videoProgressSlider.sliderProgress
                .after(this.videoProgressSlider.sliderRange);
        } else {
            this.videoProgressSlider.sliderRange
                .css(rangeParams);
        }
    }

    function getRangeParams(startTime, endTime, duration) {
        var step = 100 / duration,
            left = startTime * step,
            width = endTime * step - left;

        return {
            left: left + '%',
            width: width + '%'
        };
    }

    function onSlide(event, ui) {
        var percent = ui.value,
            duration = this.videoPlayer.duration(),
            time = parseInt(percent*duration/100);

        this.videoProgressSlider.frozen = true;

        // Remember the seek to value so that we don't repeat ourselves on the
        // 'stop' slider event.
        this.videoProgressSlider.lastSeekValue = time;

        this.trigger(
            'videoControl.updateVcrVidTime',
            {
                time: time,
                duration: duration
            }
        );

        this.trigger(
            'videoPlayer.onSlideSeek',
            {'type': 'onSlideSeek', 'time': time}
        );

        // ARIA
        this.videoProgressSlider.handle.attr(
            'aria-valuetext', getTimeDescription(this.videoPlayer.currentTime)
        );
    }

    function onStop(event, ui) {
        var _this = this,
            percent = ui.value,
            duration = this.videoPlayer.duration(),
            time = parseInt(percent*duration/100);

        this.videoProgressSlider.frozen = true;

        // Only perform a seek if we haven't made a seek for the new slider value.
        // This is necessary so that if the user only clicks on the slider, without
        // dragging it, then only one seek is made, even when a 'slide' and a 'stop'
        // events are triggered on the slider.
        if (this.videoProgressSlider.lastSeekValue !== time) {
            this.trigger(
                'videoPlayer.onSlideSeek',
                {'type': 'onSlideSeek', 'time': time}
            );
        }

        // ARIA
        this.videoProgressSlider.handle.attr(
            'aria-valuetext', getTimeDescription(this.videoPlayer.currentTime)
        );

        setTimeout(function() {
            _this.videoProgressSlider.frozen = false;
        }, 200);
    }

    function updatePlayTime(params) {
        var time = Math.floor(params.time),
            duration = Math.floor(params.duration);

        if (
            this.videoProgressSlider.slider &&
            !this.videoProgressSlider.frozen
        ) {
            this.videoProgressSlider.slider
                .slider('option', 'value', parseInt(time/duration*100));
        }
    }

    // When the video stops playing (either because the end was reached, or
    // because endTime was reached), the screen reader must be notified that
    // the video is no longer playing. We do this by a little trick. Setting
    // the title attribute of the slider know to "video ended", and focusing
    // on it. The screen reader will read the attr text.
    //
    // The user can then tab his way forward, landing on the next control
    // element, the Play button.
    //
    // @param params  -  object with property `end`. If set to true, the
    //                   function must set the title attribute to
    //                   `video ended`;
    //                   if set to false, the function must reset the attr to
    //                   it's original state.
    //
    // This function will be triggered from VideoPlayer methods onEnded(),
    // onPlay(), and update() (update method handles endTime).
    function notifyThroughHandleEnd(params) {
        if (params.end) {
            this.videoProgressSlider.handle
                .attr('title', gettext('Video ended'))
                .focus();
        } else {
            this.videoProgressSlider.handle
                .attr('title', gettext('Video position'));
        }
    }

    // Returns a string describing the current time of video in
    // `%d hours %d minutes %d seconds` format.
    function getTimeDescription(time) {
        var seconds = Math.floor(time),
            minutes = Math.floor(seconds / 60),
            hours = Math.floor(minutes / 60),
            i18n = function (value, word) {
                var msg;

                switch(word) {
                    case 'hour':
                        msg = ngettext('%(value)s hour', '%(value)s hours', value);
                        break;
                    case 'minute':
                        msg = ngettext('%(value)s minute', '%(value)s minutes', value);
                        break;
                    case 'second':
                        msg = ngettext('%(value)s second', '%(value)s seconds', value);
                        break;
                }
                return interpolate(msg, {'value': value}, true);
            };

        seconds = seconds % 60;
        minutes = minutes % 60;

        if (hours) {
            return  i18n(hours, 'hour') + ' ' +
                    i18n(minutes, 'minute') + ' ' +
                    i18n(seconds, 'second');
        } else if (minutes) {
            return  i18n(minutes, 'minute') + ' ' +
                    i18n(seconds, 'second');
        }

        return i18n(seconds, 'second');
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function(define) {
'use strict';
// VideoVolumeControl module.
define(
'video/07_video_volume_control.js', [],
function() {
    /**
     * Video volume control module.
     * @exports video/07_video_volume_control.js
     * @constructor
     * @param {Object} state The object containing the state of the video
     * @param {Object} i18n The object containing strings with translations.
     * @return {jquery Promise}
     */
    var VolumeControl = function(state, i18n) {
        if (!(this instanceof VolumeControl)) {
            return new VolumeControl(state, i18n);
        }

        this.state = state;
        this.state.videoVolumeControl = this;
        this.i18n = i18n;
        this.initialize();

        return $.Deferred().resolve().promise();
    };

    VolumeControl.prototype = {
        /** Minimum value for the volume slider. */
        min: 0,
        /** Maximum value for the volume slider. */
        max: 100,
        /** Step to increase/decrease volume level via keyboard. */
        step: 20,

        /** Initializes the module. */
        initialize: function() {
            var volume;

            this.el = this.state.el.find('.volume');

            if (this.state.isTouch) {
                // iOS doesn't support volume change
                this.el.remove();
                return false;
            }
            // Youtube iframe react on key buttons and has his own handlers.
            // So, we disallow focusing on iframe.
            this.state.el.find('iframe').attr('tabindex', -1);
            this.button = this.el.children('a');
            this.cookie = new CookieManager(this.min, this.max);
            this.a11y = new Accessibility(
                this.button, this.min, this.max, this.i18n
            );
            volume = this.cookie.getVolume();
            this.storedVolume = this.max;

            this.render();
            this.bindHandlers();
            this.setVolume(volume, true, false);
            this.checkMuteButtonStatus(volume);
        },

        /**
         * Creates any necessary DOM elements, attach them, and set their,
         * initial configuration.
         */
        render: function() {
            var container = this.el.find('.volume-slider');

            this.volumeSlider = container.slider({
                orientation: 'vertical',
                range: 'min',
                min: this.min,
                max: this.max,
                slide: this.onSlideHandler.bind(this)
            });

            // We provide an independent behavior to adjust volume level.
            // Therefore, we do not need redundant focusing on slider in TAB
            // order.
            container.find('a').attr('tabindex', -1);
        },

        /** Bind any necessary function callbacks to DOM events. */
        bindHandlers: function() {
            this.state.el.on({
                'keydown': this.keyDownHandler.bind(this),
                'play': _.once(this.updateVolumeSilently.bind(this)),
                'volumechange': this.onVolumeChangeHandler.bind(this)
            });
            this.el.on({
                'mouseenter': this.openMenu.bind(this),
                'mouseleave': this.closeMenu.bind(this)
            });
            this.button.on({
                'click': false,
                'mousedown': this.toggleMuteHandler.bind(this),
                'keydown': this.keyDownButtonHandler.bind(this),
                'focus': this.openMenu.bind(this),
                'blur': this.closeMenu.bind(this)
            });
        },

        /**
         * Updates volume level without updating view and triggering
         * `volumechange` event.
         */
        updateVolumeSilently: function() {
            this.state.el.trigger(
                'volumechange:silent', [this.getVolume()]
            );
        },

        /**
         * Returns current volume level.
         * @return {Number}
         */
        getVolume: function() {
            return this.volume;
        },

        /**
         * Sets current volume level.
         * @param {Number} volume Suggested volume level
         * @param {Boolean} [silent] Sets the new volume level without
         * triggering `volumechange` event and updating the cookie.
         * @param {Boolean} [withoutSlider] Disables updating the slider.
         */
        setVolume: function(volume, silent, withoutSlider) {
            if (volume === this.getVolume()) {
                return false;
            }

            this.volume = volume;
            this.a11y.update(this.getVolume());

            if (!withoutSlider) {
                this.updateSliderView(this.getVolume());
            }

            if (!silent) {
                this.cookie.setVolume(this.getVolume());
                this.state.el.trigger('volumechange', [this.getVolume()]);
            }
        },

        /** Increases current volume level using previously defined step. */
        increaseVolume: function() {
            var volume = Math.min(this.getVolume() + this.step, this.max);

            this.setVolume(volume, false, false);
        },

        /** Decreases current volume level using previously defined step. */
        decreaseVolume: function() {
            var volume = Math.max(this.getVolume() - this.step, this.min);

            this.setVolume(volume, false, false);
        },

        /** Updates volume slider view. */
        updateSliderView: function (volume) {
            this.volumeSlider.slider('value', volume);
        },

        /**
         * Mutes or unmutes volume.
         * @param {Number} muteStatus Flag to mute/unmute volume.
         */
        mute: function(muteStatus) {
            var volume;

            this.updateMuteButtonView(muteStatus);

            if (muteStatus) {
                this.storedVolume = this.getVolume() || this.max;
            }

            volume = muteStatus ? 0 : this.storedVolume;
            this.setVolume(volume, false, false);
        },

        /**
         * Returns current volume state (is it muted or not?).
         * @return {Boolean}
         */
        getMuteStatus: function () {
            return this.getVolume() === 0;
        },

        /**
         * Updates the volume button view.
         * @param {Boolean} isMuted Flag to use muted or unmuted view.
         */
        updateMuteButtonView: function(isMuted) {
            var action = isMuted ? 'addClass' : 'removeClass';

            this.el[action]('is-muted');
        },

        /** Toggles the state of the volume button. */
        toggleMute: function() {
            this.mute(!this.getMuteStatus());
        },

        /**
         * Checks and updates the state of the volume button relatively to
         * volume level.
         * @param {Number} volume Volume level.
         */
        checkMuteButtonStatus: function (volume) {
            if (volume <= this.min) {
                this.updateMuteButtonView(true);
                this.state.el.off('volumechange.is-muted');
                this.state.el.on('volumechange.is-muted', _.once(function () {
                     this.updateMuteButtonView(false);
                }.bind(this)));
            }
        },

        /** Opens volume menu. */
        openMenu: function() {
            this.el.addClass('is-opened');
        },

        /** Closes speed menu. */
        closeMenu: function() {
            this.el.removeClass('is-opened');
        },

        /**
         * Keydown event handler for the video container.
         * @param {jquery Event} event
         */
        keyDownHandler: function(event) {
            // ALT key is used to change (alternate) the function of
            // other pressed keys. In this case, do nothing.
            if (event.altKey) {
                return true;
            }

            if ($(event.target).hasClass('ui-slider-handle')) {
                return true;
            }

            var KEY = $.ui.keyCode,
                keyCode = event.keyCode;

            switch (keyCode) {
                case KEY.UP:
                    // Shift + Arrows keyboard shortcut might be used by
                    // screen readers. In this case, do nothing.
                    if (event.shiftKey) {
                        return true;
                    }

                    this.increaseVolume();
                    return false;
                case KEY.DOWN:
                    // Shift + Arrows keyboard shortcut might be used by
                    // screen readers. In this case, do nothing.
                    if (event.shiftKey) {
                        return true;
                    }

                    this.decreaseVolume();
                    return false;
            }

            return true;
        },

        /**
         * Keydown event handler for the volume button.
         * @param {jquery Event} event
         */
         keyDownButtonHandler: function(event) {
            // ALT key is used to change (alternate) the function of
            // other pressed keys. In this case, do nothing.
            if (event.altKey) {
                return true;
            }

            var KEY = $.ui.keyCode,
                keyCode = event.keyCode;

            switch (keyCode) {
                case KEY.ENTER:
                case KEY.SPACE:
                    this.toggleMute();

                    return false;
            }

            return true;
        },

        /**
         * onSlide callback for the video slider.
         * @param {jquery Event} event
         * @param {jqueryuiSlider ui} ui
         */
        onSlideHandler: function(event, ui) {
            this.setVolume(ui.value, false, true);
        },

        /**
         * Mousedown event handler for the volume button.
         * @param {jquery Event} event
         */
        toggleMuteHandler: function(event) {
            this.toggleMute();
            event.preventDefault();
        },

        /**
         * Volumechange event handler.
         * @param {jquery Event} event
         * @param {Number} volume Volume level.
         */
        onVolumeChangeHandler: function(event, volume) {
            this.checkMuteButtonStatus(volume);
        }
    };

    /**
     * Module responsible for the accessibility of volume controls.
     * @constructor
     * @private
     * @param {jquery $} button The volume button.
     * @param {Number} min Minimum value for the volume slider.
     * @param {Number} max Maximum value for the volume slider.
     * @param {Object} i18n The object containing strings with translations.
     */
    var Accessibility = function (button, min, max, i18n) {
        this.min = min;
        this.max = max;
        this.button = button;
        this.i18n = i18n;

        this.initialize();
    };

    Accessibility.prototype = {
        /** Initializes the module. */
        initialize: function() {
            this.liveRegion = $('<div />', {
                'class':  'sr video-live-region',
                'role': 'status',
                'aria-hidden': 'false',
                'aria-live': 'polite',
                'aria-atomic': 'false'
            });

            this.button.after(this.liveRegion);
        },

        /**
         * Updates text of the live region.
         * @param {Number} volume Volume level.
         */
        update: function(volume) {
            this.liveRegion.text([
                this.getVolumeDescription(volume),
                this.i18n['Volume'] + '.'
            ].join(' '));
        },

        /**
         * Returns a string describing the level of volume.
         * @param {Number} volume Volume level.
         */
        getVolumeDescription: function(volume) {
            if (volume === 0) {
                return this.i18n['Muted'];
            } else if (volume <= 20) {
                return this.i18n['Very low'];
            } else if (volume <= 40) {
                return this.i18n['Low'];
            } else if (volume <= 60) {
                return this.i18n['Average'];
            } else if (volume <= 80) {
                return this.i18n['Loud'];
            } else if (volume <= 99) {
                return this.i18n['Very loud'];
            }

            return this.i18n['Maximum'];
        }
    };

    /**
     * Module responsible for the work with volume cookie.
     * @constructor
     * @private
     * @param {Number} min Minimum value for the volume slider.
     * @param {Number} max Maximum value for the volume slider.
     */
    var CookieManager = function (min, max) {
        this.min = min;
        this.max = max;
        this.cookieName = 'video_player_volume_level';
    };

    CookieManager.prototype = {
        /**
         * Returns volume level from the cookie.
         * @return {Number} Volume level.
         */
        getVolume: function() {
            var volume = parseInt($.cookie(this.cookieName), 10);

            if (_.isFinite(volume)) {
                volume = Math.max(volume, this.min);
                volume = Math.min(volume, this.max);
            } else {
                volume = this.max;
            }

            return volume;
        },

        /**
         * Updates volume cookie.
         * @param {Number} volume Volume level.
         */
        setVolume: function(value) {
            $.cookie(this.cookieName, value, {
                expires: 3650,
                path: '/'
            });
        }
    };

    return VolumeControl;
});
}(RequireJS.define));

(function (requirejs, require, define) {
define(
'video/08_video_speed_control.js',
['video/00_iterator.js'],
function (Iterator) {
    "use strict";
    /**
     * Video speed control module.
     * @exports video/08_video_speed_control.js
     * @constructor
     * @param {object} state The object containing the state of the video player.
     * @return {jquery Promise}
     */
    var SpeedControl = function (state) {
        if (!(this instanceof SpeedControl)) {
            return new SpeedControl(state);
        }

        this.state = state;
        this.state.videoSpeedControl = this;
        this.initialize();

        return $.Deferred().resolve().promise();
    };

    SpeedControl.prototype = {
        /** Initializes the module. */
        initialize: function () {
            var state = this.state;

            this.el = state.el.find('.speeds');
            this.speedsContainer = this.el.find('.video-speeds');
            this.speedButton = this.el.find('.speed-button');

            if (!this.isPlaybackRatesSupported(state)) {
                this.el.remove();
                console.log(
                    '[Video info]: playbackRate is not supported.'
                );

                return false;
            }

            this.render(state.speeds, state.speed);
            this.bindHandlers();

            return true;
        },

        /**
         * Creates any necessary DOM elements, attach them, and set their,
         * initial configuration.
         * @param {array} speeds List of speeds available for the player.
         * @param {string|number} currentSpeed Current speed for the player.
         */
        render: function (speeds, currentSpeed) {
            var self = this,
                speedsContainer = this.speedsContainer,
                reversedSpeeds = speeds.concat().reverse(),
                speedsList = $.map(reversedSpeeds, function (speed, index) {
                    return [
                        '<li data-speed="', speed, '" role="presentation">',
                            '<a class="speed-link" href="#" role="menuitem" tabindex="-1">',
                                speed, 'x',
                            '</a>',
                        '</li>'
                    ].join('');
                });

            speedsContainer.html(speedsList.join(''));
            this.speedLinks = new Iterator(speedsContainer.find('.speed-link'));
            this.setSpeed(currentSpeed, true, true);
        },

        /**
         * Bind any necessary function callbacks to DOM events (click,
         * mousemove, etc.).
         */
        bindHandlers: function () {
            var self = this;

            // Attach various events handlers to the speed menu button.
            this.el.on({
                'mouseenter': this.mouseEnterHandler.bind(this),
                'mouseleave': this.mouseLeaveHandler.bind(this),
                'click': this.clickMenuHandler.bind(this),
                'keydown': this.keyDownMenuHandler.bind(this)
            });

            // Attach click and keydown event handlers to the individual speed
            // entries.
            this.speedsContainer.on({
                click: this.clickLinkHandler.bind(this),
                keydown: this.keyDownLinkHandler.bind(this)
            }, 'a.speed-link');

            this.state.el.on({
                'speed:set': function (event, speed) {
                    self.setSpeed(speed, true);
                },
                'speed:render': function (event, speeds, currentSpeed) {
                    self.render(speeds, currentSpeed);
                }
            });
        },

        /**
         * Check if playbackRate supports by browser. If browser supports, 1.0
         * should be returned by playbackRate property. In this case, function
         * return True. Otherwise, False will be returned.
         * iOS doesn't support speed change.
         * @param {object} state The object containing the state of the video
         * player.
         * @return {boolean}
         *   true: Browser support playbackRate functionality.
         *   false: Browser doesn't support playbackRate functionality.
         */
        isPlaybackRatesSupported: function (state) {
            var isHtml5 = state.videoType === 'html5',
                isTouch = state.isTouch,
                video = document.createElement('video');

            return !isTouch || (isHtml5 && !Boolean(video.playbackRate));
        },

        /**
         * Opens speed menu.
         * @param {boolean} [bindEvent] Click event will be attached on window.
         */
        openMenu: function (bindEvent) {
            // When speed entries have focus, the menu stays open on
            // mouseleave. A clickHandler is added to the window
            // element to have clicks close the menu when they happen
            // outside of it.
            if (bindEvent) {
                $(window).on('click.speedMenu', this.clickMenuHandler.bind(this));
            }

            this.el.addClass('is-opened');
            this.speedButton.attr('tabindex', -1);
        },

        /**
         * Closes speed menu.
         * @param {boolean} [unBindEvent] Click event will be detached from window.
         */
        closeMenu: function (unBindEvent) {
            // Remove the previously added clickHandler from window element.
            if (unBindEvent) {
                $(window).off('click.speedMenu');
            }

            this.el.removeClass('is-opened');
            this.speedButton.attr('tabindex', 0);
        },

        /**
         * Sets new current speed for the speed control and triggers `speedchange`
         * event if needed.
         * @param {string|number} speed Speed to be set.
         * @param {boolean} [silent] Sets the new speed without triggering
         * `speedchange` event.
         * @param {boolean} [forceUpdate] Updates the speed even if it's
         * not differs from current speed.
         */
        setSpeed: function (speed, silent, forceUpdate) {
            if (speed !== this.currentSpeed || forceUpdate) {
                this.speedsContainer
                    .find('li')
                    .removeClass('is-active')
                    .siblings("li[data-speed='" + speed + "']")
                    .addClass('is-active');

                this.speedButton.find('.value').html(speed + 'x');
                this.currentSpeed = speed;

                if (!silent) {
                    this.el.trigger('speedchange', [speed]);
                }
            }
        },

        /**
         * Click event handler for the menu.
         * @param {jquery Event} event
         */
        clickMenuHandler: function (event) {
            this.closeMenu();

            return false;
        },

        /**
         * Click event handler for speed links.
         * @param {jquery Event} event
         */
        clickLinkHandler: function (event) {
            var speed = $(event.currentTarget).parent().data('speed');

            this.closeMenu();
            this.setSpeed(this.state.speedToString(speed));

            return false;
        },

        /**
         * Mouseenter event handler for the menu.
         * @param {jquery Event} event
         */
        mouseEnterHandler: function (event) {
            this.openMenu();

            return false;
        },

        /**
         * Mouseleave event handler for the menu.
         * @param {jquery Event} event
         */
        mouseLeaveHandler: function (event) {
            // Only close the menu is no speed entry has focus.
            if (!this.speedLinks.list.is(':focus')) {
                this.closeMenu();
            }
                    
            return false;
        },

        /**
         * Keydown event handler for the menu.
         * @param {jquery Event} event
         */
        keyDownMenuHandler: function (event) {
            var KEY = $.ui.keyCode,
                keyCode = event.keyCode;

            switch(keyCode) {
                // Open menu and focus on last element of list above it.
                case KEY.ENTER:
                case KEY.SPACE:
                case KEY.UP:
                    this.openMenu(true);
                    this.speedLinks.last().focus();
                    break;
                // Close menu.
                case KEY.ESCAPE:
                    this.closeMenu(true);
                    break;
            }
            // We do not stop propagation and default behavior on a TAB
            // keypress.
            return event.keyCode === KEY.TAB;
        },

        /**
         * Keydown event handler for speed links.
         * @param {jquery Event} event
         */
        keyDownLinkHandler: function (event) {
            // ALT key is used to change (alternate) the function of
            // other pressed keys. In this, do nothing.
            if (event.altKey) {
                return true;
            }

            var KEY = $.ui.keyCode,
                self = this,
                parent = $(event.currentTarget).parent(),
                index = parent.index(),
                speed = parent.data('speed');

            switch (event.keyCode) {
                // Close menu.
                case KEY.TAB:
                    // Closes menu after 25ms delay to change `tabindex` after
                    // finishing default behavior.
                    setTimeout(function () {
                        self.closeMenu(true);
                    }, 25);

                    return true;
                // Close menu and give focus to speed control.
                case KEY.ESCAPE:
                    this.closeMenu(true);
                    this.speedButton.focus();

                    return false;
                // Scroll up menu, wrapping at the top. Keep menu open.
                case KEY.UP:
                    // Shift + Arrows keyboard shortcut might be used by
                    // screen readers. In this, do nothing.
                    if (event.shiftKey) {
                        return true;
                    }

                    this.speedLinks.prev(index).focus();
                    return false;
                // Scroll down  menu, wrapping at the bottom. Keep menu
                // open.
                case KEY.DOWN:
                    // Shift + Arrows keyboard shortcut might be used by
                    // screen readers. In this, do nothing.
                    if (event.shiftKey) {
                        return true;
                    }

                    this.speedLinks.next(index).focus();
                    return false;
                // Close menu, give focus to speed control and change
                // speed.
                case KEY.ENTER:
                case KEY.SPACE:
                    this.closeMenu(true);
                    this.speedButton.focus();
                    this.setSpeed(this.state.speedToString(speed));

                    return false;
            }

            return true;
        }
    };

    return SpeedControl;
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (define) {

// VideoCaption module.
define(
'video/09_video_caption.js',
['video/00_sjson.js', 'video/00_async_process.js'],
function (Sjson, AsyncProcess) {
    /**
     * @desc VideoCaption module exports a function.
     *
     * @type {function}
     * @access public
     *
     * @param {object} state - The object containing the state of the video
     *     player. All other modules, their parameters, public variables, etc.
     *     are available via this object.
     *
     * @this {object} The global window object.
     *
     * @returns {jquery Promise}
     */
    var VideoCaption = function (state) {
        if (!(this instanceof VideoCaption)) {
            return new VideoCaption(state);
        }

        this.state = state;
        this.state.videoCaption = this;
        this.renderElements();

        return $.Deferred().resolve().promise();
    };

    VideoCaption.prototype = {
        /**
        * @desc Initiate rendering of elements, and set their initial configuration.
        *
        */
        renderElements: function () {
            var state = this.state,
                languages = this.state.config.transcriptLanguages;

            this.loaded = false;
            this.subtitlesEl = state.el.find('ol.subtitles');
            this.container = state.el.find('.lang');
            this.hideSubtitlesEl = state.el.find('a.hide-subtitles');
            this.hideSubtitlesSideEl = state.el.find('a.hide-subtitles-side');
            this.hideSubtitlesBottomEl = state.el.find('a.hide-subtitles-bottom');
            this.subtitlesBottomEl = state.el.find('div.subtitles-bottom');

            //隐藏字幕
            if (_.keys(languages).length) {
                this.renderLanguageMenu(languages);

                if (!this.fetchCaption() || !state.config.showCaptions) {
                    this.hideCaptions(true);
                    this.hideSubtitlesEl.hide();
                    this.hideBottomCaptions(true);
                }
            } else {
                this.hideCaptions(true, false);
                this.hideSubtitlesEl.hide();
                this.hideBottomCaptions(true);
            }
        },

        /**
        * @desc Bind any necessary function callbacks to DOM events (click,
        *     mousemove, etc.).
        *
        */
        bindHandlers: function () {
            var self = this,
                state = this.state,
                events = [
                    'mouseover', 'mouseout', 'mousedown', 'click', 'focus', 'blur',
                    'keydown'
                ].join(' ');

            // Change context to VideoCaption of event handlers using `bind`.
            this.hideSubtitlesSideEl.on('click', this.toggle.bind(this));
            this.hideSubtitlesBottomEl.on('click', this.toggleBottom.bind(this))
            this.subtitlesEl
                .on({
                    mouseenter: this.onMouseEnter.bind(this),
                    mouseleave: this.onMouseLeave.bind(this),
                    mousemove: this.onMovement.bind(this),
                    mousewheel: this.onMovement.bind(this),
                    DOMMouseScroll: this.onMovement.bind(this)
                })
                .on(events, 'li[data-index]', function (event) {
                    switch (event.type) {
                        case 'mouseover':
                        case 'mouseout':
                            self.captionMouseOverOut(event);
                            break;
                        case 'mousedown':
                            self.captionMouseDown(event);
                            break;
                        case 'click':
                            self.captionClick(event);
                            break;
                        case 'focusin':
                            self.captionFocus(event);
                            break;
                        case 'focusout':
                            self.captionBlur(event);
                            break;
                        case 'keydown':
                            self.captionKeyDown(event);
                            break;
                    }
                });

            if (this.showLanguageMenu) {
                this.container.on({
                    mouseenter: this.onContainerMouseEnter,
                    mouseleave: this.onContainerMouseLeave
                });
            }

            state.el
                .on({
                    'caption:fetch': this.fetchCaption.bind(this),
                    'caption:resize': this.onResize.bind(this),
                    'caption:update': function (event, time) {
                        self.updatePlayTime(time);
                    },
                    'ended': this.pause.bind(this),
                    'fullscreen': this.onResize.bind(this),
                    'pause': this.pause.bind(this),
                    'play': this.play.bind(this)
                });

        },

        /**
        * @desc Opens language menu.
        *
        * @param {jquery Event} event
        */
        onContainerMouseEnter: function (event) {
            event.preventDefault();

            $(event.currentTarget).addClass('is-opened');
        },

        /**
        * @desc Closes language menu.
        *
        * @param {jquery Event} event
        */
        onContainerMouseLeave: function (event) {
            event.preventDefault();

            $(event.currentTarget).removeClass('is-opened');
        },

        /**
        * @desc Freezes moving of captions when mouse is over them.
        *
        * @param {jquery Event} event
        */
        onMouseEnter: function (event) {
            if (this.frozen) {
                clearTimeout(this.frozen);
            }

            this.frozen = setTimeout(
                this.onMouseLeave,
                this.state.config.captionsFreezeTime
            );
        },

        /**
        * @desc Unfreezes moving of captions when mouse go out.
        *
        * @param {jquery Event} event
        */
        onMouseLeave: function (event) {
            if (this.frozen) {
                clearTimeout(this.frozen);
            }

            this.frozen = null;

            if (this.playing) {
                this.scrollCaption();
            }
        },

        /**
        * @desc Freezes moving of captions when mouse is moving over them.
        *
        * @param {jquery Event} event
        */
        onMovement: function (event) {
            this.onMouseEnter();
        },

        /**
        * @desc Fetch the caption file specified by the user. Upon successful
        *     receipt of the file, the captions will be rendered.
        *
        * @returns {boolean}
        *     true: The user specified a caption file. NOTE: if an error happens
        *         while the specified file is being retrieved (for example the
        *         file is missing on the server), this function will still return
        *         true.
        *     false: No caption file was specified, or an empty string was
        *         specified for the Youtube type player.
        */
        fetchCaption: function () {
            var self = this,
                state = this.state,
                language = state.getCurrentLanguage(),
                data, youtubeId;

            if (this.loaded) {
                this.hideCaptions(false);
            } else {
                this.hideCaptions(state.hide_captions, false);
            }

            if (this.fetchXHR && this.fetchXHR.abort) {
                this.fetchXHR.abort();
            }

            if (state.videoType === 'youtube') {
                youtubeId = state.youtubeId('1.0');

                if (!youtubeId) {
                    return false;
                }

                data = {
                    videoId: youtubeId
                };
            }

            state.el.removeClass('is-captions-rendered');
            // Fetch the captions file. If no file was specified, or if an error
            // occurred, then we hide the captions panel, and the "CC" button
            this.fetchXHR = $.ajaxWithPrefix({
                url: state.config.transcriptTranslationUrl + '/' + language,
                notifyOnError: false,
                data: data,
                success: function (sjson) {
                    self.sjson = new Sjson(sjson);

                    var start = self.sjson.getStartTimes(),
                        end = self.sjson.getEndTimes(),
                        captions = self.sjson.getCaptions();

                    if (self.loaded) {
                        if (self.rendered) {
                            self.renderCaption(start, end, captions);
                            self.updatePlayTime(state.videoPlayer.currentTime);
                        }
                    } else {
                        if (state.isTouch) {
                            self.subtitlesEl.find('li').html(
                                gettext(
                                    'Caption will be displayed when ' +
                                    'you start playing the video.'
                                )
                            );
                        } else {
                            self.renderCaption(start, end, captions);
                        }

                        self.bindHandlers();
                    }

                    self.loaded = true;
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    console.log('[Video info]: ERROR while fetching captions.');
                    console.log(
                        '[Video info]: STATUS:', textStatus +
                        ', MESSAGE:', '' + errorThrown
                    );
                    // If initial list of languages has more than 1 item, check
                    // for availability other transcripts.
                    if (_.keys(state.config.transcriptLanguages).length > 1) {
                        self.fetchAvailableTranslations();
                    } else {
                        self.hideCaptions(true, false);
                        self.hideSubtitlesEl.hide();
                        self.hideBottomCaptions(true);
                    }
                }
            });

            return true;
        },

        /**
        * @desc Fetch the list of available translations. Upon successful receipt,
        *    the list of available translations will be updated.
        *
        * @returns {jquery Promise}
        */
        fetchAvailableTranslations: function () {
            var self = this,
                state = this.state;

            return $.ajaxWithPrefix({
                url: state.config.transcriptAvailableTranslationsUrl,
                notifyOnError: false,
                success: function (response) {
                    var currentLanguages = state.config.transcriptLanguages,
                        newLanguages = _.pick(currentLanguages, response);

                    // Update property with available currently translations.
                    state.config.transcriptLanguages = newLanguages;
                    // Remove an old language menu.
                    self.container.find('.langs-list').remove();

                    if (_.keys(newLanguages).length) {
                        // And try again to fetch transcript.
                        self.fetchCaption();
                        self.renderLanguageMenu(newLanguages);
                    }
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    self.hideCaptions(true, false);
                    self.hideSubtitlesEl.hide();
                    self.hideBottomCaptions(true);
                }
            });
        },

        /**
        * @desc Recalculates and updates the height of the container of captions.
        *
        */
        onResize: function () {
            this.subtitlesEl
                .find('.spacing').first()
                .height(this.topSpacingHeight()).end()
                .find('.spacing').last()
                .height(this.bottomSpacingHeight());

            this.scrollCaption();
            this.setSubtitlesHeight();
        },

        /**
        * @desc Create any necessary DOM elements, attach them, and set their
        *     initial configuration for the Language menu.
        *
        * @param {object} languages Dictionary where key is language code,
        *     value - language label
        *
        */
        renderLanguageMenu: function (languages) {
            var self = this,
                state = this.state,
                menu = $('<ol class="langs-list menu">'),
                currentLang = state.getCurrentLanguage();

            if (_.keys(languages).length < 2) {
                return false;
            }

            this.showLanguageMenu = true;

            $.each(languages, function(code, label) {
                var li = $('<li data-lang-code="' + code + '" />'),
                    link = $('<a href="javascript:void(0);">' + label + '</a>');

                if (currentLang === code) {
                    li.addClass('is-active');
                }

                li.append(link);
                menu.append(li);
            });

            this.container.append(menu);

            menu.on('click', 'a', function (e) {
                var el = $(e.currentTarget).parent(),
                    state = self.state,
                    langCode = el.data('lang-code');

                if (state.lang !== langCode) {
                    state.lang = langCode;
                    state.storage.setItem('language', langCode);
                    el  .addClass('is-active')
                        .siblings('li')
                        .removeClass('is-active');

                    self.fetchCaption();
                }
            });
        },

        /**
        * @desc Create any necessary DOM elements, attach them, and set their
        *     initial configuration.
        *
        * @param {jQuery element} container Element in which captions will be
        *     inserted.
        * @param {array} start List of start times for the video.
        * @param {array} captions List of captions for the video.
        * @returns {object} jQuery's Promise object
        *
        */
        buildCaptions: function  (container, start, end, captions) {
            var process = function(text, index) {
                    var liEl = $('<li>', {
                        'data-index': index,
                        'data-start': start[index],
                        'data-end': end[index],
                        'tabindex': 0
                    }).html(text);

                    return liEl[0];
                };

            return AsyncProcess.array(captions, process).done(function (list) {
                container.append(list);
            });
        },

        /**
        * @desc Initiates creating of captions and set their initial configuration.
        *
        * @param {array} start List of start times for the video.
        * @param {array} captions List of captions for the video.
        *
        */
        renderCaption: function (start, end, captions) {
            var self = this;

            var onRender = function () {
                self.addPaddings();
                // Enables or disables automatic scrolling of the captions when the
                // video is playing. This feature has to be disabled when tabbing
                // through them as it interferes with that action. Initially, have
                // this flag enabled as we assume mouse use. Then, if the first
                // caption (through forward tabbing) or the last caption (through
                // backwards tabbing) gets the focus, disable that feature.
                // Re-enable it if tabbing then cycles out of the the captions.
                self.autoScrolling = true;
                // Keeps track of where the focus is situated in the array of
                // captions. Used to implement the automatic scrolling behavior and
                // decide if the outline around a caption has to be hidden or shown
                // on a mouseenter or mouseleave. Initially, no caption has the
                // focus, set the index to -1.
                self.currentCaptionIndex = -1;
                // Used to track if the focus is coming from a click or tabbing. This
                // has to be known to decide if, when a caption gets the focus, an
                // outline has to be drawn (tabbing) or not (mouse click).
                self.isMouseFocus = false;
                self.rendered = true;
                self.state.el.addClass('is-captions-rendered');
            };

            this.rendered = false;
            this.subtitlesEl.empty();
            this.setSubtitlesHeight();
            this.buildCaptions(this.subtitlesEl, start, end, captions).done(onRender);
        },

        /**
        * @desc Sets top and bottom spacing height and make sure they are taken
        *     out of the tabbing order.
        *
        */
        addPaddings: function () {

            this.subtitlesEl
                .prepend(
                    $('<li class="spacing">')
                        .height(this.topSpacingHeight())
                        .attr('tabindex', -1)
                )
                .append(
                    $('<li class="spacing">')
                        .height(this.bottomSpacingHeight())
                        .attr('tabindex', -1)
                );
        },

        /**
        * @desc
        * On mouseOver: Hides the outline of a caption that has been tabbed to.
        * On mouseOut: Shows the outline of a caption that has been tabbed to.
        *
        * @param {jquery Event} event
        *
        */
        captionMouseOverOut: function (event) {
            var caption = $(event.target),
                captionIndex = parseInt(caption.attr('data-index'), 10);

            if (captionIndex === this.currentCaptionIndex) {
                if (event.type === 'mouseover') {
                    caption.removeClass('focused');
                }
                else { // mouseout
                    caption.addClass('focused');
                }
            }
        },

        /**
        * @desc Handles mousedown event on concrete caption.
        *
        * @param {jquery Event} event
        *
        */
        captionMouseDown: function (event) {
            var caption = $(event.target);

            this.isMouseFocus = true;
            this.autoScrolling = true;
            caption.removeClass('focused');
            this.currentCaptionIndex = -1;
        },

        /**
        * @desc Handles click event on concrete caption.
        *
        * @param {jquery Event} event
        *
        */
        captionClick: function (event) {
            this.seekPlayer(event);
        },

        /**
        * @desc Handles focus event on concrete caption.
        *
        * @param {jquery Event} event
        *
        */
        captionFocus: function (event) {
            var caption = $(event.target),
                captionIndex = parseInt(caption.attr('data-index'), 10);
            // If the focus comes from a mouse click, hide the outline, turn on
            // automatic scrolling and set currentCaptionIndex to point outside of
            // caption list (ie -1) to disable mouseenter, mouseleave behavior.
            if (this.isMouseFocus) {
                this.autoScrolling = true;
                caption.removeClass('focused');
                this.currentCaptionIndex = -1;
            }
            // If the focus comes from tabbing, show the outline and turn off
            // automatic scrolling.
            else {
                this.currentCaptionIndex = captionIndex;
                caption.addClass('focused');
                // The second and second to last elements turn automatic scrolling
                // off again as it may have been enabled in captionBlur.
                if (
                    captionIndex <= 1 ||
                    captionIndex >= this.sjson.getSize() - 2
                ) {
                    this.autoScrolling = false;
                }
            }
        },

        /**
        * @desc Handles blur event on concrete caption.
        *
        * @param {jquery Event} event
        *
        */
        captionBlur: function (event) {
            var caption = $(event.target),
                captionIndex = parseInt(caption.attr('data-index'), 10);

            caption.removeClass('focused');
            // If we are on first or last index, we have to turn automatic scroll
            // on again when losing focus. There is no way to know in what
            // direction we are tabbing. So we could be on the first element and
            // tabbing back out of the captions or on the last element and tabbing
            // forward out of the captions.
            if (captionIndex === 0 ||
                captionIndex === this.sjson.getSize() - 1) {

                this.autoScrolling = true;
            }
        },

        /**
        * @desc Handles keydown event on concrete caption.
        *
        * @param {jquery Event} event
        *
        */
        captionKeyDown: function (event) {
            this.isMouseFocus = false;
            if (event.which === 13) { //Enter key
                this.seekPlayer(event);
            }
        },

        /**
        * @desc Scrolls caption container to make active caption visible.
        *
        */
        scrollCaption: function () {
            var el = this.subtitlesEl.find('.current:first');

            // Automatic scrolling gets disabled if one of the captions has
            // received focus through tabbing.
            if (
                !this.frozen &&
                el.length &&
                this.autoScrolling
            ) {
                this.subtitlesEl.scrollTo(
                    el,
                    {
                        offset: -1 * this.calculateOffset(el)
                    }
                );
            }
        },

        /**
        * @desc Updates flags on play
        *
        */
        play: function () {
            if (this.loaded) {
                if (!this.rendered) {
                    var start = this.sjson.getStartTimes(),
                        end = this.sjson.getEndTimes(),
                        captions = this.sjson.getCaptions();

                    this.renderCaption(start, end, captions);
                }

                this.playing = true;
            }
        },

        /**
        * @desc Updates flags on pause
        *
        */
        pause: function () {
            if (this.loaded) {
                this.playing = false;
            }
        },

        /**
        * @desc Updates captions UI on paying.
        *
        * @param {number} time Time in seconds.
        *
        */
        updatePlayTime: function (time) {
            var state = this.state,
                newIndex;

            if (this.loaded) {
                if (state.isFlashMode()) {
                    time = Time.convert(time, state.speed, '1.0');
                }

                time = Math.round(time * 1000 + 100);
                newIndex = this.sjson.search(time);
                if (
                    typeof newIndex !== 'undefined' &&
                    newIndex !== -1
                ) {
                    if(this.currentIndex !== newIndex){
                        if (typeof this.currentIndex !== 'undefined') {
                            this.subtitlesEl
                                .find('li.current')
                                .removeClass('current');
                        }

                        var currentEl = this.subtitlesEl
                            .find("li[data-index='" + newIndex + "']");

                        currentEl.addClass('current');

                        this.currentIndex = newIndex;
                        this.scrollCaption();

                        this.subtitlesBottomEl.html(currentEl.html());
                    }
                }
                else{
                    this.subtitlesBottomEl.html('');
                }
            }
        },

        /**
        * @desc Sends log to the server on caption seek.
        *
        * @param {jquery Event} event
        *
        */
        seekPlayer: function (event) {
            var state = this.state,
                time = parseInt($(event.target).data('start'), 10);

            if (state.isFlashMode()) {
                time = Math.round(Time.convert(time, '1.0', state.speed));
            }

            state.trigger(
                'videoPlayer.onCaptionSeek',
                {
                    'type': 'onCaptionSeek',
                    'time': time/1000
                }
            );

            event.preventDefault();
        },

        /**
        * @desc Calculates offset for paddings.
        *
        * @param {jquery element} element Top or bottom padding element.
        * @returns {number} Offset for the passed padding element.
        *
        */
        calculateOffset: function (element) {
            return this.captionHeight() / 2 - element.height() / 2;
        },

        /**
        * @desc Calculates offset for the top padding element.
        *
        * @returns {number} Offset for the passed top padding element.
        *
        */
        topSpacingHeight: function () {
            return this.calculateOffset(
                this.subtitlesEl.find('li:not(.spacing)').first()
            );
        },

        /**
        * @desc Calculates offset for the bottom padding element.
        *
        * @returns {number} Offset for the passed bottom padding element.
        *
        */
        bottomSpacingHeight: function () {
            return this.calculateOffset(
                this.subtitlesEl.find('li:not(.spacing)').last()
            );
        },

        /**
        * @desc Shows/Hides captions on click `CC` button
        *
        * @param {jquery Event} event
        *
        */
        toggle: function (event) {
            event.preventDefault();

            if (this.state.el.hasClass('closed')) {
                this.hideBottomCaptions(true);
                this.hideCaptions(false);
            } else {
                this.hideCaptions(true);
            }
        },

        toggleBottom: function (event) {
            event.preventDefault();

            if(this.subtitlesBottomEl.hasClass('is-close')) {
                this.hideCaptions(true);
                this.hideBottomCaptions(false);
            } else {
                this.hideBottomCaptions(true);
            }
        },

        /**
        * @desc Shows/Hides captions and updates the cookie.
        *
        * @param {boolean} hide_captions if `true` hides the caption,
        *     otherwise - show.
        * @param {boolean} update_cookie Flag to update or not the cookie.
        *
        */
        hideCaptions: function (hide_captions, update_cookie) {
            var hideSubtitlesEl = this.hideSubtitlesEl,
                state = this.state,
                type, text;

            if (typeof update_cookie === 'undefined') {
                update_cookie = true;
            }

            if (hide_captions) {
                type = 'hide_transcript';
                state.captionsHidden = true;
                state.el.addClass('closed');
                text = gettext('Turn on captions');
            } else {
                type = 'show_transcript';
                state.captionsHidden = false;
                state.el.removeClass('closed');
                this.scrollCaption();
                text = gettext('Turn off captions');
                this.hideBottomCaptions(true);
            }

            hideSubtitlesEl
                .attr('title', text)
                .text(gettext(text));

            if (state.videoPlayer) {
                state.videoPlayer.log(type, {
                    currentTime: state.videoPlayer.currentTime
                });
            }

            if (state.resizer) {
                if (state.isFullScreen) {
                    state.resizer.setMode('both');
                } else {
                    state.resizer.alignByWidthOnly();
                }
            }

            this.setSubtitlesHeight();
            if (update_cookie) {
                $.cookie('hide_captions', hide_captions, {
                    expires: 3650,
                    path: '/'
                });
            }
        },

        hideCaptionsSide: function(hide_captions){
            if(this.loaded) {
                if (hide_captions) {
                    this.hideSubtitlesSideEl.parent().css('display', 'none');
                    if(!this.state.captionsHidden) {
                        this.state.el.addClass('closed');
                    }
                }
                else {
                    this.hideSubtitlesSideEl.parent().css('display', 'block');
                    if(!this.state.captionsHidden){
                        console.log('this');
                        this.state.el.removeClass('closed');
                    }
                }
            }
        },


        hideBottomCaptions: function(hide_captions){
            var text = gettext('Turn off captions');
            if(hide_captions){
                text = gettext('Turn on captions');
                this.subtitlesBottomEl.css('display','none');
                this.subtitlesBottomEl.addClass('is-close');
            }
            else{
                this.subtitlesBottomEl.css('display','block');
                this.subtitlesBottomEl.removeClass('is-close');
            }
            this.hideSubtitlesEl.attr('title', text);
        },


        /**
        * @desc Return the caption container height.
        *
        * @returns {number} event Height of the container in pixels.
        *
        */
        captionHeight: function () {
            var state = this.state;

            if (state.isFullScreen) {
                return state.container.height() - state.videoControl.height;
            } else {
                return state.container.height();
            }
        },

        /**
        * @desc Sets the height of the caption container element.
        *
        */
        setSubtitlesHeight: function () {
            var height = 0,
                state = this.state;
            // on page load captionHidden = undefined
            if  ((state.captionsHidden === undefined && state.hide_captions) ||
                state.captionsHidden === true
            ) {
                // In case of html5 autoshowing subtitles, we adjust height of
                // subs, by height of scrollbar.
                height = state.videoControl.el.height() +
                    0.5 * state.videoControl.sliderEl.height();
                // Height of videoControl does not contain height of slider.
                // css is set to absolute, to avoid yanking when slider
                // autochanges its height.
            }

            this.subtitlesEl.css({
                maxHeight: this.captionHeight() - height
            });
        }
    };

    return VideoCaption;
});

}(RequireJS.define));

(function (require, $) {
    'use strict';

    // In the case when the Video constructor will be called before RequireJS finishes loading all of the Video
    // dependencies, we will have a mock function that will collect all the elements that must be initialized as
    // Video elements.
    //
    // Once RequireJS will load all of the necessary dependencies, main code will invoke the mock function with
    // the second parameter set to truthy value. This will trigger the actual Video constructor on all elements
    // that are stored in a temporary list.
    window.Video = (function () {
        // Temporary storage place for elements that must be initialized as Video elements.
        var tempCallStack = [];

        return function (element, processTempCallStack) {
            // If mock function was called with second parameter set to truthy value, we invoke the real `window.Video`
            // on all the stored elements so far.
            if (processTempCallStack) {
                $.each(tempCallStack, function (index, element) {
                    // By now, `window.Video` is the real constructor.
                    window.Video(element);
                });

                return;
            }

            // If normal call to `window.Video` constructor, store the element for later initializing.
            tempCallStack.push(element);

            // Real Video constructor returns the `state` object. The mock function will return an empty object.
            return {};
        };
    }());

    // Main module.
    require(
        [
            'video/01_initialize.js',
            'video/025_focus_grabber.js',
            'video/035_video_accessible_menu.js',
            'video/04_video_control.js',
            'video/05_video_quality_control.js',
            'video/06_video_progress_slider.js',
            'video/07_video_volume_control.js',
            'video/08_video_speed_control.js',
            'video/09_video_caption.js'
        ],
        function (
            initialize,
            FocusGrabber,
            VideoAccessibleMenu,
            VideoControl,
            VideoQualityControl,
            VideoProgressSlider,
            VideoVolumeControl,
            VideoSpeedControl,
            VideoCaption
        ) {
            var youtubeXhr = null,
                oldVideo = window.Video;

            window.Video = function (element) {
                var previousState = window.Video.previousState,
                    state;

                // Check for existance of previous state, uninitialize it if necessary, and create a new state. Store
                // new state for future invocation of this module consturctor function.
                if (previousState && previousState.videoPlayer) {
                    previousState.saveState(true);
                    $(window).off('unload', previousState.saveState);
                }

                state = {};
                // Because this constructor can be called multiple times on a single page (when the user switches
                // verticals, the page doesn't reload, but the content changes), we must will check each time if there
                // is a previous copy of 'state' object. If there is, we will make sure that copy exists cleanly. We
                // have to do this because when verticals switch, the code does not handle any Xmodule JS code that is
                // running - it simply removes DOM elements from the page. Any functions that were running during this,
                // and that will run afterwards (expecting the DOM elements to be present) must be stopped by hand.
                window.Video.previousState = state;

                state.modules = [
                    FocusGrabber,
                    VideoAccessibleMenu,
                    VideoControl,
                    VideoQualityControl,
                    VideoProgressSlider,
                    VideoVolumeControl,
                    VideoSpeedControl,
                    VideoCaption
                ];

                state.youtubeXhr = youtubeXhr;
                initialize(state, element);
                if (!youtubeXhr) {
                    youtubeXhr = state.youtubeXhr;
                }

                $(element).find('.video').data('video-player-state', state);

                // Because the 'state' object is only available inside this closure, we will also make it available to
                // the caller by returning it. This is necessary so that we can test Video with Jasmine.
                return state;
            };

            window.Video.clearYoutubeXhr = function () {
                youtubeXhr = null;
            };

            // Invoke the mock Video constructor so that the elements stored within it can be processed by the real
            // `window.Video` constructor.
            oldVideo(null, true);
        }
    );
}(window.RequireJS.require, window.jQuery));
